import {
  GenkitError
} from "@genkit-ai/core";
import { embedder, embedderActionMetadata } from "@genkit-ai/ai/embedder";
import { evaluator } from "@genkit-ai/ai/evaluator";
import {
  backgroundModel,
  model,
  modelActionMetadata
} from "@genkit-ai/ai/model";
import { reranker } from "@genkit-ai/ai/reranker";
import { indexer, retriever } from "@genkit-ai/ai/retriever";
function genkitPlugin(pluginName, initFn, resolveFn, listActionsFn) {
  return (genkit) => ({
    name: pluginName,
    initializer: async () => {
      await initFn(genkit);
    },
    resolver: async (action, target) => {
      if (resolveFn) {
        return await resolveFn(genkit, action, target);
      }
    },
    listActions: async () => {
      if (listActionsFn) {
        return await listActionsFn();
      }
      return [];
    }
  });
}
class GenkitPluginV2Instance {
  version = "v2";
  name;
  plugin;
  constructor(plugin) {
    this.name = plugin.name;
    this.plugin = plugin;
  }
  init() {
    if (!this.plugin.init) {
      return [];
    }
    return this.plugin.init();
  }
  list() {
    if (!this.plugin.list) {
      return [];
    }
    return this.plugin.list();
  }
  resolve(actionType, name) {
    if (!this.plugin.resolve) {
      return void 0;
    }
    return this.plugin.resolve(actionType, name);
  }
  async model(name) {
    const model2 = await this.resolve("model", name);
    if (!model2) {
      throw new GenkitError({
        message: `Failed to resolve model ${name} for plugin ${this.name}`,
        status: "NOT_FOUND"
      });
    }
    return model2;
  }
}
function genkitPluginV2(options) {
  return new GenkitPluginV2Instance(options);
}
function isPluginV2(plugin) {
  return plugin.version === "v2";
}
export {
  GenkitPluginV2Instance,
  backgroundModel,
  embedder,
  embedderActionMetadata,
  evaluator,
  genkitPlugin,
  genkitPluginV2,
  indexer,
  isPluginV2,
  model,
  modelActionMetadata,
  reranker,
  retriever
};
//# sourceMappingURL=plugin.mjs.map