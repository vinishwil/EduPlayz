import { GenkitError } from "genkit";
import process from "process";
import { extractMedia } from "../common/utils.js";
import {
  checkModelName,
  cleanSchema,
  extractText,
  extractVersion,
  modelName
} from "../common/utils.js";
function getApiKeyFromEnvVar() {
  return process.env.GEMINI_API_KEY || process.env.GOOGLE_API_KEY || process.env.GOOGLE_GENAI_API_KEY;
}
const MISSING_API_KEY_ERROR = new GenkitError({
  status: "FAILED_PRECONDITION",
  message: "Please pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\nFor more details see https://genkit.dev/docs/plugins/google-genai/"
});
const API_KEY_FALSE_ERROR = new GenkitError({
  status: "INVALID_ARGUMENT",
  message: "GoogleAI plugin was initialized with {apiKey: false} but no apiKey configuration was passed at call time."
});
function checkApiKey(pluginApiKey) {
  let apiKey;
  if (pluginApiKey !== false) {
    apiKey = pluginApiKey || getApiKeyFromEnvVar();
  }
  if (pluginApiKey !== false && !apiKey) {
    throw MISSING_API_KEY_ERROR;
  }
  return apiKey;
}
function calculateApiKey(pluginApiKey, requestApiKey) {
  let apiKey;
  if (pluginApiKey !== false) {
    apiKey = pluginApiKey || getApiKeyFromEnvVar();
  }
  apiKey = requestApiKey || apiKey;
  if (pluginApiKey === false && !requestApiKey) {
    return void 0;
  }
  if (!apiKey) {
    throw MISSING_API_KEY_ERROR;
  }
  return apiKey;
}
function extractVeoImage(request) {
  const media = request.messages.at(-1)?.content.find((p) => !!p.media)?.media;
  if (!media?.contentType?.startsWith("image/")) {
    return void 0;
  }
  const bytes = media?.url.split(",")[1];
  if (bytes) {
    return {
      bytesBase64Encoded: bytes,
      mimeType: media.contentType
    };
  }
  return void 0;
}
function extractVeoVideo(request) {
  const media = request.messages.at(-1)?.content.find((p) => !!p.media)?.media;
  if (!media?.contentType?.startsWith("video/")) {
    return void 0;
  }
  return {
    uri: media.url
  };
}
function extractImagenImage(request) {
  const image = extractMedia(request, {
    metadataType: "base",
    isDefault: true
  })?.url.split(",")[1];
  if (image) {
    return { bytesBase64Encoded: image };
  }
  return void 0;
}
function calculateRequestOptions(clientOptions, reqConfig) {
  if (!reqConfig) {
    return clientOptions;
  }
  let newOptions = { ...clientOptions };
  if (typeof reqConfig.timeout == "number") {
    newOptions.timeout = reqConfig.timeout;
  }
  if (typeof reqConfig.apiKey == "string") {
    newOptions.apiKey = reqConfig.apiKey;
  }
  if (typeof reqConfig.apiVersion == "string") {
    newOptions.apiVersion = reqConfig.apiVersion;
  }
  if (typeof reqConfig.apiClient == "string") {
    newOptions.apiClient = reqConfig.apiClient;
  }
  if (typeof reqConfig.baseUrl == "string") {
    newOptions.baseUrl = reqConfig.baseUrl;
  }
  if (reqConfig.customHeaders && typeof reqConfig.customHeaders === "object") {
    newOptions.customHeaders = reqConfig.customHeaders;
  }
  return newOptions;
}
function removeClientOptionOverrides(requestConfig) {
  let newConfig = { ...requestConfig };
  delete newConfig?.timeout;
  delete newConfig?.apiKey;
  delete newConfig?.apiVersion;
  delete newConfig?.apiClient;
  delete newConfig?.baseUrl;
  delete newConfig?.customHeaders;
  return newConfig;
}
export {
  API_KEY_FALSE_ERROR,
  MISSING_API_KEY_ERROR,
  calculateApiKey,
  calculateRequestOptions,
  checkApiKey,
  checkModelName,
  cleanSchema,
  extractImagenImage,
  extractText,
  extractVeoImage,
  extractVeoVideo,
  extractVersion,
  getApiKeyFromEnvVar,
  modelName,
  removeClientOptionOverrides
};
//# sourceMappingURL=utils.mjs.map