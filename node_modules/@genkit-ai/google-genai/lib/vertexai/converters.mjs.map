{"version":3,"sources":["../../src/vertexai/converters.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  GenerateRequest,\n  GenerateResponseData,\n  GenkitError,\n  MediaPart,\n  Operation,\n  z,\n} from 'genkit';\nimport { CandidateData, getBasicUsageStats } from 'genkit/model';\nimport {\n  HarmBlockThreshold,\n  HarmCategory,\n  ImagenInstance,\n  ImagenParameters,\n  ImagenPredictRequest,\n  ImagenPredictResponse,\n  ImagenPrediction,\n  SafetySetting,\n} from '../common/types.js';\nimport { extractMediaArray } from '../common/utils.js';\nimport { SafetySettingsSchema } from './gemini.js';\nimport { ImagenConfigSchemaType } from './imagen.js';\nimport { LyriaConfigSchemaType } from './lyria.js';\nimport {\n  ClientOptions,\n  LyriaInstance,\n  LyriaParameters,\n  LyriaPredictRequest,\n  LyriaPredictResponse,\n  LyriaPrediction,\n  VeoInstance,\n  VeoMedia,\n  VeoOperation,\n  VeoOperationRequest,\n  VeoPredictRequest,\n} from './types.js';\nimport {\n  checkSupportedMimeType,\n  extractMedia,\n  extractMimeType,\n  extractText,\n} from './utils.js';\nimport { VeoConfigSchemaType } from './veo.js';\n\nexport function toGeminiSafetySettings(\n  genkitSettings?: z.infer<typeof SafetySettingsSchema>[]\n): SafetySetting[] | undefined {\n  if (!genkitSettings) return undefined;\n  return genkitSettings.map((s) => {\n    return {\n      category: s.category as HarmCategory,\n      threshold: s.threshold as HarmBlockThreshold,\n    };\n  });\n}\n\nexport function toGeminiLabels(\n  labels?: Record<string, string>\n): Record<string, string> | undefined {\n  if (!labels) {\n    return undefined;\n  }\n  const keys = Object.keys(labels);\n  const newLabels: Record<string, string> = {};\n  for (const key of keys) {\n    const value = labels[key];\n    if (!key) {\n      continue;\n    }\n    newLabels[key] = value;\n  }\n\n  if (Object.keys(newLabels).length == 0) {\n    return undefined;\n  }\n  return newLabels;\n}\n\nexport function toImagenPredictRequest(\n  request: GenerateRequest<ImagenConfigSchemaType>\n): ImagenPredictRequest {\n  return {\n    instances: toImagenInstances(request),\n    parameters: toImagenParameters(request),\n  };\n}\n\nfunction toImagenInstances(\n  request: GenerateRequest<ImagenConfigSchemaType>\n): ImagenInstance[] {\n  let instance: ImagenInstance = {\n    prompt: extractText(request),\n  };\n\n  const imageMedia = extractMedia(request, {\n    metadataType: 'image',\n    isDefault: true,\n  });\n  if (imageMedia) {\n    const image = imageMedia.url.split(',')[1];\n    instance.image = {\n      bytesBase64Encoded: image,\n    };\n  }\n\n  const maskMedia = extractMedia(request, { metadataType: 'mask' });\n  if (maskMedia) {\n    const mask = maskMedia.url.split(',')[1];\n    instance.mask = {\n      image: {\n        bytesBase64Encoded: mask,\n      },\n    };\n  }\n\n  return [instance];\n}\n\nfunction toImagenParameters(\n  request: GenerateRequest<ImagenConfigSchemaType>\n): ImagenParameters {\n  const params = {\n    sampleCount: request.candidates ?? 1,\n    ...request?.config,\n  };\n\n  for (const k in params) {\n    if (!params[k]) delete params[k];\n  }\n\n  return params;\n}\n\nfunction fromImagenPrediction(p: ImagenPrediction, i: number): CandidateData {\n  const b64data = p.bytesBase64Encoded;\n  const mimeType = p.mimeType;\n  return {\n    index: i,\n    finishReason: 'stop',\n    message: {\n      role: 'model',\n      content: [\n        {\n          media: {\n            url: `data:${mimeType};base64,${b64data}`,\n            contentType: mimeType,\n          },\n        },\n      ],\n    },\n  };\n}\n\n/**\n *\n * @param response The response to convert\n * @param request The request (for usage stats)\n * @returns The converted response\n */\nexport function fromImagenResponse(\n  response: ImagenPredictResponse,\n  request: GenerateRequest\n): GenerateResponseData {\n  const candidates = response.predictions.map(fromImagenPrediction);\n  return {\n    candidates,\n    usage: {\n      ...getBasicUsageStats(request.messages, candidates),\n      custom: { generations: candidates.length },\n    },\n    custom: response,\n  };\n}\n\nexport function toLyriaPredictRequest(\n  request: GenerateRequest<LyriaConfigSchemaType>\n): LyriaPredictRequest {\n  return {\n    instances: toLyriaInstances(request),\n    parameters: toLyriaParameters(request),\n  };\n}\n\nfunction toLyriaInstances(\n  request: GenerateRequest<LyriaConfigSchemaType>\n): LyriaInstance[] {\n  let config = { ...request.config };\n  delete config.sampleCount; // Sample count goes in parameters, the rest go in instances\n  return [\n    {\n      prompt: extractText(request),\n      ...config,\n    },\n  ];\n}\n\nfunction toLyriaParameters(\n  request: GenerateRequest<LyriaConfigSchemaType>\n): LyriaParameters {\n  return {\n    sampleCount: request.config?.sampleCount || 1,\n  };\n}\n\nfunction fromLyriaPrediction(p: LyriaPrediction, i: number): CandidateData {\n  const b64data = p.bytesBase64Encoded;\n  const mimeType = p.mimeType;\n  return {\n    index: i,\n    finishReason: 'stop',\n    message: {\n      role: 'model',\n      content: [\n        {\n          media: {\n            url: `data:${mimeType};base64,${b64data}`,\n            contentType: mimeType,\n          },\n        },\n      ],\n    },\n  };\n}\n\nexport function fromLyriaResponse(\n  response: LyriaPredictResponse,\n  request: GenerateRequest\n): GenerateResponseData {\n  const candidates: CandidateData[] =\n    response.predictions.map(fromLyriaPrediction);\n  return {\n    candidates,\n    usage: {\n      ...getBasicUsageStats(request.messages, candidates),\n      custom: { generations: candidates.length },\n    },\n    custom: response,\n  };\n}\n\nexport function toVeoPredictRequest(\n  request: GenerateRequest<VeoConfigSchemaType>\n): VeoPredictRequest {\n  return {\n    instances: toVeoInstances(request),\n    parameters: { ...request.config },\n  };\n}\n\nfunction toVeoInstances(\n  request: GenerateRequest<VeoConfigSchemaType>\n): VeoInstance[] {\n  let instance: VeoInstance = {\n    prompt: extractText(request),\n  };\n\n  const supportedImageTypes = ['image/jpeg', 'image/png', 'image/webp'];\n  const supportedVideoTypes = [\n    'video/mov',\n    'video/mpeg',\n    'video/mp4',\n    'video/mpg',\n    'video/avi',\n    'video/wmv',\n    'video/mpegps',\n    'video/flv',\n  ];\n\n  const imageMedia = extractMedia(request, {\n    metadataType: 'image',\n    isDefault: true,\n  });\n  if (imageMedia) {\n    checkSupportedMimeType(imageMedia, supportedImageTypes);\n    instance.image = toVeoMedia(imageMedia);\n  }\n\n  const lastFrameMedia = extractMedia(request, { metadataType: 'lastFrame' });\n  if (lastFrameMedia) {\n    checkSupportedMimeType(lastFrameMedia, supportedImageTypes);\n    instance.lastFrame = toVeoMedia(lastFrameMedia);\n  }\n\n  const videoMedia = extractMedia(request, { metadataType: 'video' });\n  if (videoMedia) {\n    checkSupportedMimeType(videoMedia, supportedVideoTypes);\n    instance.video = toVeoMedia(videoMedia);\n  }\n\n  const referenceImages = extractMediaArray(request, {\n    metadataType: 'referenceImages',\n  });\n  if (referenceImages) {\n    instance.referenceImages = referenceImages.map((refImage) => ({\n      image: toVeoMedia(refImage.media),\n      referenceType: refImage.metadata?.referenceType as string,\n    }));\n  }\n\n  return [instance];\n}\n\nexport function toVeoMedia(media: MediaPart['media']): VeoMedia {\n  let mimeType = media.contentType;\n  if (!mimeType) {\n    mimeType = extractMimeType(media.url);\n    if (!mimeType) {\n      throw new GenkitError({\n        status: 'INVALID_ARGUMENT',\n        message: 'Content type is required.',\n      });\n    }\n  }\n  if (media.url.startsWith('data:')) {\n    return {\n      bytesBase64Encoded: media.url?.split(',')[1],\n      mimeType,\n    };\n  } else if (media.url.startsWith('gs://')) {\n    return {\n      gcsUri: media.url,\n      mimeType,\n    };\n  } else if (media.url.startsWith('http')) {\n    throw new GenkitError({\n      status: 'INVALID_ARGUMENT',\n      message:\n        'Veo does not support http(s) URIs. Please specify a Cloud Storage URI.',\n    });\n  } else {\n    // Assume it's a non-prefixed data url\n    return {\n      bytesBase64Encoded: media.url,\n      mimeType,\n    };\n  }\n}\n\nexport function fromVeoOperation(\n  fromOp: VeoOperation\n): Operation<GenerateResponseData> {\n  const toOp: Operation<GenerateResponseData> = { id: fromOp.name };\n  if (fromOp.done !== undefined) {\n    toOp.done = fromOp.done;\n  }\n  if (fromOp.error) {\n    toOp.error = { message: fromOp.error.message };\n  }\n  if (fromOp.clientOptions) {\n    toOp.metadata = {\n      clientOptions: fromOp.clientOptions,\n    };\n  }\n\n  if (fromOp.response) {\n    toOp.output = {\n      finishReason: 'stop',\n      raw: fromOp.response,\n      message: {\n        role: 'model',\n        content: fromOp.response.videos.map((veoMedia) => {\n          if (veoMedia.bytesBase64Encoded) {\n            return {\n              media: {\n                url: `data:${veoMedia.mimeType}:base64,${veoMedia.bytesBase64Encoded}`,\n                contentType: veoMedia.mimeType,\n              },\n            };\n          }\n\n          return {\n            media: {\n              url: veoMedia.gcsUri ?? '',\n              contentType: veoMedia.mimeType,\n            },\n          };\n        }),\n      },\n    };\n  }\n\n  return toOp;\n}\n\nexport function toVeoModel(op: Operation<GenerateResponseData>): string {\n  return op.id.substring(\n    op.id.indexOf('models/') + 7,\n    op.id.indexOf('/operations/')\n  );\n}\n\nexport function toVeoOperationRequest(\n  op: Operation<GenerateResponseData>\n): VeoOperationRequest {\n  return {\n    operationName: op.id,\n  };\n}\n\nexport function toVeoClientOptions(\n  op: Operation<GenerateResponseData>,\n  clientOpt: ClientOptions\n): ClientOptions {\n  return op.metadata?.clientOptions ?? clientOpt;\n}\n"],"mappings":"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","names":[]}