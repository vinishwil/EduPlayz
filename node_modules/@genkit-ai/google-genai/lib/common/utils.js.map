{"version":3,"sources":["../../src/common/utils.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  EmbedderReference,\n  GenkitError,\n  Part as GenkitPart,\n  JSONSchema,\n  MediaPart,\n  ModelReference,\n  getClientHeader as defaultGetClientHeader,\n  z,\n} from 'genkit';\nimport { GenerateRequest } from 'genkit/model';\nimport { applyGeminiPartialArgs } from './converters.js';\nimport {\n  GenerateContentCandidate,\n  GenerateContentResponse,\n  GenerateContentStreamResult,\n  Part,\n  isObject,\n} from './types.js';\n\n/**\n * Safely extracts the error message from the error.\n * @param e The error\n * @returns The error message\n */\nexport function extractErrMsg(e: unknown): string {\n  let errorMessage = 'An unknown error occurred';\n  if (e instanceof Error) {\n    errorMessage = e.message;\n  } else if (typeof e === 'string') {\n    errorMessage = e;\n  } else {\n    // Fallback for other types\n    try {\n      errorMessage = JSON.stringify(e);\n    } catch (stringifyError) {\n      errorMessage = 'Failed to stringify error object';\n    }\n  }\n  return errorMessage;\n}\n\n/**\n * Custom replacer function for JSON.stringify to truncate long string fields.\n * Truncates strings to the first 100 and last 10 characters\n * if the original string is longer than 110 characters.\n *\n * @param key The key of the property being stringified.\n * @param value The value of the property being stringified.\n * @return The transformed value, or the original value if no transformation is needed.\n */\nexport function stringTruncator(key: string, value: unknown): unknown {\n  const beginLength = 100;\n  const endLength = 10;\n  const totalLength = beginLength + endLength;\n  if (typeof value === 'string' && value.length > totalLength) {\n    const start = value.substring(0, 100);\n    const end = value.substring(value.length - 10);\n    return `${start}...[TRUNCATED]...${end}`;\n  }\n  return value; // Return the original value for other keys or non-string values\n}\n\n/**\n * Gets the un-prefixed model name from a modelReference\n */\nexport function extractVersion(\n  model: ModelReference<z.ZodTypeAny> | EmbedderReference<z.ZodTypeAny>\n): string {\n  return model.version ? model.version : checkModelName(model.name);\n}\n\n/**\n * Gets the model name without certain prefixes..\n * e.g. for \"models/googleai/gemini-2.5-pro\" it returns just 'gemini-2.5-pro'\n * @param name A string containing the model string with possible prefixes\n * @returns the model string stripped of certain prefixes\n */\nexport function modelName(name?: string): string | undefined {\n  if (!name) return name;\n\n  // Remove any of these prefixes:\n  const prefixesToRemove =\n    /background-model\\/|model\\/|models\\/|embedders\\/|googleai\\/|vertexai\\//g;\n  return name.replace(prefixesToRemove, '');\n}\n\n/**\n * Gets the suffix of a model string.\n * Throws if the string is empty.\n * @param name A string containing the model string\n * @returns the model string stripped of prefixes and guaranteed not empty.\n */\nexport function checkModelName(name?: string): string {\n  const version = modelName(name);\n  if (!version) {\n    throw new GenkitError({\n      status: 'INVALID_ARGUMENT',\n      message: 'Model name is required.',\n    });\n  }\n  return version;\n}\n\nexport function extractText(request: GenerateRequest) {\n  return (\n    request.messages\n      .at(-1)\n      ?.content.map((c) => c.text || '')\n      .join('') ?? ''\n  );\n}\n\nconst KNOWN_MIME_TYPES = {\n  jpg: 'image/jpeg',\n  jpeg: 'image/jpeg',\n  png: 'image/png',\n  mp4: 'video/mp4',\n  pdf: 'application/pdf',\n};\n\nexport function extractMimeType(url?: string): string {\n  if (!url) {\n    return '';\n  }\n\n  const dataPrefix = 'data:';\n  if (!url.startsWith(dataPrefix)) {\n    // Not a data url, try suffix\n    url.lastIndexOf('.');\n    const key = url.substring(url.lastIndexOf('.') + 1);\n    if (Object.keys(KNOWN_MIME_TYPES).includes(key)) {\n      return KNOWN_MIME_TYPES[key];\n    }\n    return '';\n  }\n\n  const commaIndex = url.indexOf(',');\n  if (commaIndex == -1) {\n    // Invalid - missing separator\n    return '';\n  }\n\n  // The part between 'data:' and the comma\n  let mimeType = url.substring(dataPrefix.length, commaIndex);\n  const base64Marker = ';base64';\n  if (mimeType.endsWith(base64Marker)) {\n    mimeType = mimeType.substring(0, mimeType.length - base64Marker.length);\n  }\n\n  return mimeType.trim();\n}\n\nexport function checkSupportedMimeType(\n  media: MediaPart['media'],\n  supportedTypes: string[]\n) {\n  if (!supportedTypes.includes(media.contentType ?? '')) {\n    throw new GenkitError({\n      status: 'INVALID_ARGUMENT',\n      message: `Invalid mimeType for ${displayUrl(media.url)}: \"${media.contentType}\". Supported mimeTypes: ${supportedTypes.join(', ')}`,\n    });\n  }\n}\n\n/**\n *\n * @param url The url to show (e.g. in an error message)\n * @returns The appropriately  sized url\n */\nexport function displayUrl(url: string): string {\n  if (url.length <= 50) {\n    return url;\n  }\n\n  return url.substring(0, 25) + '...' + url.substring(url.length - 25);\n}\n\nfunction isMediaPart(part: GenkitPart): part is MediaPart {\n  return (part as MediaPart).media !== undefined;\n}\n\n/**\n *\n * @param request A generate request to extract from\n * @param metadataType The media must have metadata matching this type if isDefault is false\n * @param isDefault 'true' allows missing metadata type to match as well.\n * @returns\n */\nexport function extractMedia(\n  request: GenerateRequest,\n  params: {\n    metadataType?: string;\n    /* Is there is no metadata type, it will match if isDefault is true */\n    isDefault?: boolean;\n  }\n): MediaPart['media'] | undefined {\n  const mediaArray = extractMediaArray(request, params);\n  if (mediaArray?.length) {\n    return mediaArray[0].media;\n  }\n\n  return undefined;\n}\n\n/**\n *\n * @param request A generate request to extract from\n * @param metadataType The media must have metadata matching this type if isDefault is false\n * @param isDefault 'true' allows missing metadata type to match as well.\n * @returns\n */\nexport function extractMediaArray(\n  request: GenerateRequest,\n  params: {\n    metadataType?: string;\n    /* If there is no metadata type, it will match if isDefault is true */\n    isDefault?: boolean;\n  }\n): MediaPart[] | undefined {\n  // MediaPart filter:  Keeps parts matching `params.metadataType`,\n  // or parts with no metadata type if `params.isDefault` is true.\n  // Keeps everything if no params are specified.\n  const matchesMediaParams = (part: MediaPart) => {\n    if (params.metadataType || params.isDefault) {\n      // We need to check the metadata type\n      const metadata = part.metadata;\n      if (!metadata?.type) {\n        return !!params.isDefault;\n      } else {\n        return metadata.type == params.metadataType;\n      }\n    }\n    return true;\n  };\n\n  const mediaArray = request.messages\n    .at(-1)\n    ?.content.filter(isMediaPart)\n    .filter(matchesMediaParams)\n    ?.map((mediaPart) => {\n      let media = mediaPart.media;\n      if (media && !media?.contentType) {\n        // Add the mimeType\n        media = {\n          url: media.url,\n          contentType: extractMimeType(media.url),\n        };\n      }\n\n      return {\n        media,\n        metadata: {\n          referenceType: mediaPart.metadata?.referenceType ?? 'asset',\n        },\n      };\n    });\n\n  if (mediaArray?.length) {\n    return mediaArray;\n  }\n\n  return undefined;\n}\n\n/**\n * Cleans a JSON schema by removing specific keys and standardizing types.\n *\n * @param {JSONSchema} schema The JSON schema to clean.\n * @returns {JSONSchema} The cleaned JSON schema.\n */\nexport function cleanSchema(schema: JSONSchema): JSONSchema {\n  const out = structuredClone(schema);\n  for (const key in out) {\n    if (key === '$schema' || key === 'additionalProperties') {\n      delete out[key];\n      continue;\n    }\n    if (typeof out[key] === 'object') {\n      out[key] = cleanSchema(out[key]);\n    }\n    // Zod nullish() and picoschema optional fields will produce type `[\"string\", \"null\"]`\n    // which is not supported by the model API. Convert them to just `\"string\"`.\n    if (key === 'type' && Array.isArray(out[key])) {\n      // find the first that's not `null`.\n      out[key] = out[key].find((t) => t !== 'null');\n    }\n  }\n  return out;\n}\n\n/**\n * Processes the streaming body of a Response object. It decodes the stream as\n * UTF-8 text, parses JSON objects from specially formatted lines (e.g., \"data: {}\"),\n * and returns both an async generator for individual responses and a promise\n * that resolves to the aggregated final response.\n *\n * @param response The Response object with a streaming body.\n * @returns An object containing:\n *  - stream: An AsyncGenerator yielding each GenerateContentResponse.\n *  - response: A Promise resolving to the aggregated GenerateContentResponse.\n */\nexport function processStream(response: Response): GenerateContentStreamResult {\n  if (!response.body) {\n    throw new Error('Error processing stream because response.body not found');\n  }\n  const inputStream = response.body.pipeThrough(\n    new TextDecoderStream('utf8', { fatal: true })\n  );\n  const responseStream = getResponseStream(inputStream);\n  const [stream1, stream2] = responseStream.tee();\n  return {\n    stream: generateResponseSequence(stream1),\n    response: getResponsePromise(stream2),\n  };\n}\n\nfunction getResponseStream(\n  inputStream: ReadableStream<string>\n): ReadableStream<GenerateContentResponse> {\n  const responseLineRE = /^data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n  const reader = inputStream.getReader();\n  const stream = new ReadableStream<GenerateContentResponse>({\n    start(controller) {\n      let currentText = '';\n      return pump();\n      function pump(): Promise<(() => Promise<void>) | undefined> {\n        return reader\n          .read()\n          .then(({ value, done }) => {\n            if (done) {\n              if (currentText.trim()) {\n                controller.error(new Error('Failed to parse stream'));\n                return;\n              }\n              controller.close();\n              return;\n            }\n\n            currentText += value;\n            let match = currentText.match(responseLineRE);\n            let parsedResponse: GenerateContentResponse;\n            while (match) {\n              try {\n                parsedResponse = JSON.parse(match[1]);\n              } catch (e) {\n                controller.error(\n                  new Error(`Error parsing JSON response: \"${match[1]}\"`)\n                );\n                return;\n              }\n              controller.enqueue(parsedResponse);\n              currentText = currentText.substring(match[0].length);\n              match = currentText.match(responseLineRE);\n            }\n            return pump();\n          })\n          .catch((e: Error) => {\n            let err = e;\n            err.stack = e.stack;\n            if (err.name === 'AbortError') {\n              err = new GenkitError({\n                status: 'ABORTED',\n                message: 'Request aborted when reading from the stream',\n              });\n            } else {\n              err = new Error('Error reading from the stream');\n            }\n            throw err;\n          });\n      }\n    },\n  });\n  return stream;\n}\n\nasync function* generateResponseSequence(\n  stream: ReadableStream<GenerateContentResponse>\n): AsyncGenerator<GenerateContentResponse> {\n  const reader = stream.getReader();\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    yield value;\n  }\n}\n\nasync function getResponsePromise(\n  stream: ReadableStream<GenerateContentResponse>\n): Promise<GenerateContentResponse> {\n  const allResponses: GenerateContentResponse[] = [];\n  const reader = stream.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      return aggregateResponses(allResponses);\n    }\n    allResponses.push(value);\n  }\n}\n\nfunction handleFunctionCall(\n  part: Part,\n  newPart: Partial<Part>,\n  activePartialToolRequest: Part | null\n): {\n  shouldContinue: boolean;\n  newActivePartialToolRequest: Part | null;\n} {\n  // If there's an active partial tool request, we're in the middle of a stream.\n  if (activePartialToolRequest) {\n    if (part.functionCall?.partialArgs) {\n      applyGeminiPartialArgs(\n        activePartialToolRequest.functionCall!.args!,\n        part.functionCall.partialArgs\n      );\n    }\n    // If `willContinue` is false, this is the end of the stream.\n    if (!part.functionCall!.willContinue) {\n      newPart.thoughtSignature = activePartialToolRequest.thoughtSignature;\n      part.functionCall = activePartialToolRequest.functionCall;\n      delete part.functionCall!.willContinue;\n      activePartialToolRequest = null;\n    } else {\n      // If `willContinue` is true, we're still in the middle of a stream.\n      // This is a partial result, so we skip adding it to the parts list.\n      return {\n        shouldContinue: true,\n        newActivePartialToolRequest: activePartialToolRequest,\n      };\n    }\n    // If `willContinue` is true on a part and there's no active partial request,\n    // this is the start of a new streaming tool call.\n  } else if (part.functionCall!.willContinue) {\n    activePartialToolRequest = {\n      ...part,\n      functionCall: {\n        ...part.functionCall,\n        args: part.functionCall!.args || {},\n      },\n    };\n    if (part.functionCall?.partialArgs) {\n      applyGeminiPartialArgs(\n        activePartialToolRequest.functionCall!.args!,\n        part.functionCall.partialArgs\n      );\n    }\n    // This is the start of a partial, so we skip adding it to the parts list.\n    return {\n      shouldContinue: true,\n      newActivePartialToolRequest: activePartialToolRequest,\n    };\n  }\n\n  // If we're here, it's a regular, non-streaming tool call.\n  newPart.functionCall = part.functionCall;\n  return {\n    shouldContinue: false,\n    newActivePartialToolRequest: activePartialToolRequest,\n  };\n}\n\nfunction aggregateResponses(\n  responses: GenerateContentResponse[]\n): GenerateContentResponse {\n  const lastResponse = responses.at(-1);\n  if (lastResponse === undefined) {\n    throw new Error(\n      'Error aggregating stream chunks because the final response in stream chunk is undefined'\n    );\n  }\n  const aggregatedResponse: GenerateContentResponse = {};\n  if (lastResponse.promptFeedback) {\n    aggregatedResponse.promptFeedback = lastResponse.promptFeedback;\n  }\n  let activePartialToolRequest: Part | null = null;\n  for (const response of responses) {\n    for (const candidate of response.candidates ?? []) {\n      const index = candidate.index ?? 0;\n      if (!aggregatedResponse.candidates) {\n        aggregatedResponse.candidates = [];\n      }\n      if (!aggregatedResponse.candidates[index]) {\n        aggregatedResponse.candidates[index] = {\n          index,\n        } as GenerateContentCandidate;\n      }\n      const aggregatedCandidate = aggregatedResponse.candidates[index];\n      aggregateMetadata(aggregatedCandidate, candidate, 'citationMetadata');\n      aggregateMetadata(aggregatedCandidate, candidate, 'groundingMetadata');\n      if (candidate.safetyRatings?.length) {\n        aggregatedCandidate.safetyRatings = (\n          aggregatedCandidate.safetyRatings ?? []\n        ).concat(candidate.safetyRatings);\n      }\n      if (candidate.finishReason !== undefined) {\n        aggregatedCandidate.finishReason = candidate.finishReason;\n      }\n      if (candidate.finishMessage !== undefined) {\n        aggregatedCandidate.finishMessage = candidate.finishMessage;\n      }\n\n      if (candidate.avgLogprobs !== undefined) {\n        aggregatedCandidate.avgLogprobs = candidate.avgLogprobs;\n      }\n      if (candidate.logprobsResult !== undefined) {\n        aggregatedCandidate.logprobsResult = candidate.logprobsResult;\n      }\n\n      /**\n       * Candidates should always have content and parts, but this handles\n       * possible malformed responses.\n       */\n      if (candidate.content && candidate.content.parts) {\n        if (!aggregatedCandidate.content) {\n          aggregatedCandidate.content = {\n            role: candidate.content.role || 'user',\n            parts: [],\n          };\n        }\n\n        for (const part of candidate.content.parts) {\n          const newPart: Partial<Part> = {};\n          if (part.thought) {\n            newPart.thought = part.thought;\n          }\n          if (part.thoughtSignature) {\n            newPart.thoughtSignature = part.thoughtSignature;\n          }\n          if (typeof part.text === 'string') {\n            newPart.text = part.text;\n          }\n          if (part.functionCall) {\n            // function calls are special, there can be partials, so we need aggregate\n            // the partials into final functionCall.\n            const { shouldContinue, newActivePartialToolRequest } =\n              handleFunctionCall(part, newPart, activePartialToolRequest);\n            if (shouldContinue) {\n              activePartialToolRequest = newActivePartialToolRequest;\n              continue;\n            }\n            activePartialToolRequest = newActivePartialToolRequest;\n          }\n          if (part.executableCode) {\n            newPart.executableCode = part.executableCode;\n          }\n          if (part.codeExecutionResult) {\n            newPart.codeExecutionResult = part.codeExecutionResult;\n          }\n          if (part.inlineData) {\n            newPart.inlineData = part.inlineData;\n          }\n          if (Object.keys(newPart).length === 0) {\n            newPart.text = '';\n          }\n          aggregatedCandidate.content.parts.push(newPart as Part);\n        }\n      }\n    }\n    if (response.usageMetadata) {\n      aggregatedResponse.usageMetadata = response.usageMetadata;\n    }\n  }\n  return aggregatedResponse;\n}\n\nfunction aggregateMetadata<K extends keyof GenerateContentCandidate>(\n  aggCandidate: GenerateContentCandidate,\n  chunkCandidate: GenerateContentCandidate,\n  fieldName: K\n) {\n  const chunkObj = chunkCandidate[fieldName];\n  const aggObj = aggCandidate[fieldName];\n  if (chunkObj === undefined) return; // Nothing to do\n\n  if (aggObj === undefined) {\n    aggCandidate[fieldName] = chunkObj;\n    return;\n  }\n\n  if (isObject(chunkObj)) {\n    for (const k of Object.keys(chunkObj)) {\n      if (Array.isArray(aggObj[k]) && Array.isArray(chunkObj[k])) {\n        aggObj[k] = aggObj[k].concat(chunkObj[k]);\n      } else {\n        // last one wins, also handles only one being an array.\n        aggObj[k] = chunkObj[k] ?? aggObj[k];\n      }\n    }\n  }\n}\n\nexport function getGenkitClientHeader() {\n  if (process.env.MONOSPACE_ENV == 'true') {\n    return defaultGetClientHeader() + ' firebase-studio-vm';\n  }\n  return defaultGetClientHeader();\n}\n\nexport const TEST_ONLY = { aggregateResponses };\n"],"mappings":"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","names":["defaultGetClientHeader"]}