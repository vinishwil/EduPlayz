{"version":3,"sources":["../../src/common/converters.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenkitError, ToolRequest, z } from 'genkit';\nimport {\n  CandidateData,\n  MessageData,\n  ModelReference,\n  Part,\n  TextPart,\n  ToolDefinition,\n} from 'genkit/model';\nimport { JSONPath } from 'jsonpath-plus';\nimport {\n  FunctionCallingMode,\n  FunctionDeclaration,\n  GenerateContentCandidate as GeminiCandidate,\n  Content as GeminiContent,\n  Part as GeminiPart,\n  PartialArg,\n  Schema,\n  SchemaType,\n  VideoMetadata,\n} from './types.js';\n\nexport function toGeminiTool(tool: ToolDefinition): FunctionDeclaration {\n  const declaration: FunctionDeclaration = {\n    name: tool.name.replace(/\\//g, '__'), // Gemini throws on '/' in tool name\n    description: tool.description,\n    parameters: toGeminiSchemaProperty(tool.inputSchema),\n  };\n  return declaration;\n}\n\nfunction toGeminiSchemaProperty(property?: ToolDefinition['inputSchema']) {\n  if (!property || !property.type) {\n    return undefined;\n  }\n  const baseSchema: Schema = {};\n  if (property.description) {\n    baseSchema.description = property.description;\n  }\n  if (property.enum) {\n    baseSchema.enum = property.enum;\n  }\n  if (property.nullable) {\n    baseSchema.nullable = property.nullable;\n  }\n  let propertyType;\n  // nullable schema can ALSO be defined as, for example, type=['string','null']\n  if (Array.isArray(property.type)) {\n    const types = property.type as string[];\n    if (types.includes('null')) {\n      baseSchema.nullable = true;\n    }\n    // grab the type that's not `null`\n    propertyType = types.find((t) => t !== 'null');\n  } else {\n    propertyType = property.type;\n  }\n  if (propertyType === 'object') {\n    const nestedProperties = {};\n    Object.keys(property.properties).forEach((key) => {\n      nestedProperties[key] = toGeminiSchemaProperty(property.properties[key]);\n    });\n    return {\n      ...baseSchema,\n      type: SchemaType.OBJECT,\n      properties: nestedProperties,\n      required: property.required,\n    };\n  } else if (propertyType === 'array') {\n    return {\n      ...baseSchema,\n      type: SchemaType.ARRAY,\n      items: toGeminiSchemaProperty(property.items),\n    };\n  } else {\n    const schemaType = SchemaType[propertyType.toUpperCase()] as SchemaType;\n    if (!schemaType) {\n      throw new GenkitError({\n        status: 'INVALID_ARGUMENT',\n        message: `Unsupported property type ${propertyType.toUpperCase()}`,\n      });\n    }\n    return {\n      ...baseSchema,\n      type: schemaType,\n    };\n  }\n}\n\nfunction toGeminiMedia(part: Part): GeminiPart {\n  let media: GeminiPart;\n  if (part.media?.url.startsWith('data:')) {\n    // Inline data\n    const dataUrl = part.media.url;\n    const b64Data = dataUrl.substring(dataUrl.indexOf(',')! + 1);\n    const contentType =\n      part.media.contentType ||\n      dataUrl.substring(dataUrl.indexOf(':')! + 1, dataUrl.indexOf(';'));\n    media = { inlineData: { mimeType: contentType, data: b64Data } };\n  } else {\n    // File data\n    if (!part.media?.contentType) {\n      throw Error(\n        'Must supply a `contentType` when sending File URIs to Gemini.'\n      );\n    }\n    media = {\n      fileData: {\n        mimeType: part.media.contentType,\n        fileUri: part.media.url,\n      },\n    };\n  }\n\n  // Video metadata\n  if (part.metadata?.videoMetadata) {\n    let videoMetadata = part.metadata.videoMetadata as VideoMetadata;\n    media.videoMetadata = { ...videoMetadata };\n  }\n\n  // Media resolution\n  if (part.metadata?.mediaResolution) {\n    media.mediaResolution = { ...part.metadata.mediaResolution };\n  }\n\n  return maybeAddGeminiThoughtSignature(part, media);\n}\n\nfunction toGeminiToolRequest(part: Part): GeminiPart {\n  if (!part.toolRequest?.input) {\n    throw Error('Invalid ToolRequestPart: input was missing.');\n  }\n  const functionCall: GeminiPart['functionCall'] = {\n    name: part.toolRequest.name,\n    args: part.toolRequest.input,\n  };\n  if (part.toolRequest.ref) {\n    functionCall.id = part.toolRequest.ref;\n  }\n  return maybeAddGeminiThoughtSignature(part, { functionCall });\n}\n\nfunction toGeminiToolResponse(part: Part): GeminiPart {\n  if (!part.toolResponse?.output) {\n    throw Error('Invalid ToolResponsePart: output was missing.');\n  }\n  const functionResponse: GeminiPart['functionResponse'] = {\n    name: part.toolResponse.name,\n    response: {\n      name: part.toolResponse.name,\n      content: part.toolResponse.output,\n    },\n  };\n  if (part.toolResponse.content) {\n    functionResponse.parts = part.toolResponse.content.map(toGeminiPart);\n  }\n  if (part.toolResponse.ref) {\n    functionResponse.id = part.toolResponse.ref;\n  }\n  return maybeAddGeminiThoughtSignature(part, {\n    functionResponse,\n  });\n}\n\nfunction toGeminiReasoning(part: Part): GeminiPart {\n  const out: GeminiPart = { thought: true };\n  if (part.reasoning?.length) {\n    out.text = part.reasoning;\n  }\n  return maybeAddGeminiThoughtSignature(part, out);\n}\n\nfunction toGeminiCustom(part: Part): GeminiPart {\n  if (part.custom?.codeExecutionResult) {\n    return maybeAddGeminiThoughtSignature(part, {\n      codeExecutionResult: part.custom.codeExecutionResult,\n    });\n  }\n  if (part.custom?.executableCode) {\n    return maybeAddGeminiThoughtSignature(part, {\n      executableCode: part.custom.executableCode,\n    });\n  }\n  throw new Error('Unsupported Custom Part type');\n}\n\nfunction toGeminiText(part: Part): GeminiPart {\n  return maybeAddGeminiThoughtSignature(part, { text: part.text ?? '' });\n}\n\nfunction maybeAddGeminiThoughtSignature(\n  part: Part,\n  geminiPart: GeminiPart\n): GeminiPart {\n  if (part.metadata?.thoughtSignature) {\n    return {\n      ...geminiPart,\n      thoughtSignature: part.metadata.thoughtSignature as string,\n    };\n  }\n  return geminiPart;\n}\n\nfunction toGeminiPart(part: Part): GeminiPart {\n  if (typeof part.text === 'string') {\n    return toGeminiText(part);\n  }\n  if (part.media) {\n    return toGeminiMedia(part);\n  }\n  if (part.toolRequest) {\n    return toGeminiToolRequest(part);\n  }\n  if (part.toolResponse) {\n    return toGeminiToolResponse(part);\n  }\n  if (typeof part.reasoning === 'string') {\n    return toGeminiReasoning(part);\n  }\n  if (part.custom) {\n    return toGeminiCustom(part);\n  }\n\n  throw new Error('Unsupported Part type ' + JSON.stringify(part));\n}\n\nfunction toGeminiRole(\n  role: MessageData['role'],\n  model?: ModelReference<z.ZodTypeAny>\n): string {\n  switch (role) {\n    case 'user':\n      return 'user';\n    case 'model':\n      return 'model';\n    case 'system':\n      if (model?.info?.supports?.systemRole) {\n        // We should have already pulled out the supported system messages,\n        // anything remaining is unsupported; throw an error.\n        throw new Error(\n          'system role is only supported for a single message in the first position'\n        );\n      } else {\n        throw new Error('system role is not supported');\n      }\n    case 'tool':\n      return 'function';\n    default:\n      return 'user';\n  }\n}\n\nexport function toGeminiMessage(\n  message: MessageData,\n  model?: ModelReference<z.ZodTypeAny>\n): GeminiContent {\n  let sortedParts = message.content;\n  if (message.role === 'tool') {\n    sortedParts = [...message.content].sort((a, b) => {\n      const aRef = a.toolResponse?.ref;\n      const bRef = b.toolResponse?.ref;\n      if (!aRef && !bRef) return 0;\n      if (!aRef) return 1;\n      if (!bRef) return -1;\n      return parseInt(aRef, 10) - parseInt(bRef, 10);\n    });\n  }\n  return {\n    role: toGeminiRole(message.role, model),\n    parts: sortedParts.map(toGeminiPart),\n  };\n}\n\nexport function toGeminiSystemInstruction(message: MessageData): GeminiContent {\n  return {\n    role: 'user',\n    parts: message.content.map(toGeminiPart),\n  };\n}\n\n/**\n * Converts mode from either genkit tool choice (lowercase)\n * or functionCallingConfig (uppercase).\n * @param from The mode to convert from\n * @returns\n */\nexport function toGeminiFunctionModeEnum(\n  from?: string\n  //genkitMode: 'auto' | 'required' | 'none'\n): FunctionCallingMode | undefined {\n  if (from === undefined) {\n    return undefined;\n  }\n  switch (from) {\n    case 'MODE_UNSPECIFIED': {\n      return FunctionCallingMode.MODE_UNSPECIFIED;\n    }\n    case 'required':\n    case 'ANY': {\n      return FunctionCallingMode.ANY;\n    }\n    case 'auto':\n    case 'AUTO': {\n      return FunctionCallingMode.AUTO;\n    }\n    case 'none':\n    case 'NONE': {\n      return FunctionCallingMode.NONE;\n    }\n    default:\n      throw new Error(`unsupported function calling mode: ${from}`);\n  }\n}\n\nfunction fromGeminiFinishReason(\n  reason: GeminiCandidate['finishReason']\n): CandidateData['finishReason'] {\n  if (!reason) return 'unknown';\n  switch (reason) {\n    case 'STOP':\n      return 'stop';\n    case 'MAX_TOKENS':\n      return 'length';\n    case 'SAFETY': // blocked for safety\n    case 'RECITATION': // blocked for reciting training data\n    case 'LANGUAGE': // blocked for using an unsupported language\n    case 'BLOCKLIST': // blocked for forbidden terms\n    case 'PROHIBITED_CONTENT': // blocked for potentially containing prohibited content\n    case 'SPII': // blocked for potentially containing Sensitive Personally Identifiable Information\n      return 'blocked';\n    case 'MALFORMED_FUNCTION_CALL':\n    case 'MISSING_THOUGHT_SIGNATURE':\n    case 'OTHER':\n      return 'other';\n    default:\n      return 'unknown';\n  }\n}\n\nfunction maybeAddThoughtSignature(geminiPart: GeminiPart, part: Part): Part {\n  if (geminiPart.thoughtSignature) {\n    return {\n      ...part,\n      metadata: {\n        ...part?.metadata,\n        thoughtSignature: geminiPart.thoughtSignature,\n      },\n    };\n  }\n  return part;\n}\n\nfunction fromGeminiThought(part: GeminiPart): Part {\n  return maybeAddThoughtSignature(part, {\n    reasoning: part.text || '',\n  });\n}\n\nfunction fromGeminiInlineData(part: GeminiPart): Part {\n  // Check if the required properties exist\n  if (\n    !part.inlineData ||\n    !part.inlineData.hasOwnProperty('mimeType') ||\n    !part.inlineData.hasOwnProperty('data')\n  ) {\n    throw new Error('Invalid GeminiPart: missing required properties');\n  }\n  const { mimeType, data } = part.inlineData;\n  // Combine data and mimeType into a data URL\n  const dataUrl = `data:${mimeType};base64,${data}`;\n\n  return maybeAddThoughtSignature(part, {\n    media: {\n      url: dataUrl,\n      contentType: mimeType,\n    },\n  });\n}\n\nfunction fromGeminiFileData(part: GeminiPart): Part {\n  if (\n    !part.fileData ||\n    !part.fileData.hasOwnProperty('mimeType') ||\n    !part.fileData.hasOwnProperty('fileUri')\n  ) {\n    throw new Error(\n      'Invalid Gemini File Data Part: missing required properties'\n    );\n  }\n\n  return maybeAddThoughtSignature(part, {\n    media: {\n      url: part.fileData?.fileUri,\n      contentType: part.fileData?.mimeType,\n    },\n  });\n}\n\n/**\n * Applies Gemini partial args to the target object.\n *\n * https://docs.cloud.google.com/vertex-ai/generative-ai/docs/reference/rest/v1/Content#PartialArg\n */\nexport function applyGeminiPartialArgs(\n  target: object,\n  partialArgs: PartialArg[]\n) {\n  for (const partialArg of partialArgs) {\n    if (!partialArg.jsonPath) {\n      continue;\n    }\n    let value: boolean | string | number | null | undefined;\n    if (partialArg.boolValue !== undefined) {\n      value = partialArg.boolValue;\n    } else if (partialArg.nullValue !== undefined) {\n      value = null;\n    } else if (partialArg.numberValue !== undefined) {\n      value = partialArg.numberValue;\n    } else if (partialArg.stringValue !== undefined) {\n      value = partialArg.stringValue;\n    }\n    if (value === undefined) {\n      continue;\n    }\n\n    let current: any = target;\n    const path = JSONPath.toPathArray(partialArg.jsonPath);\n    // ex: for path '$.data[0][0]' toPathArray returns: ['$', 'data', '0', '0']\n    // we skip the first (root) reference and dereference the rest.\n    for (let i = 1; i < path.length - 1; i++) {\n      const key = path[i];\n      const nextKey = path[i + 1];\n      if (current[key] === undefined) {\n        if (!isNaN(parseInt(nextKey, 10))) {\n          current[key] = [];\n        } else {\n          current[key] = {};\n        }\n      }\n      current = current[key];\n    }\n\n    const finalKey = path[path.length - 1];\n    if (\n      partialArg.stringValue !== undefined &&\n      typeof current[finalKey] === 'string'\n    ) {\n      current[finalKey] += partialArg.stringValue;\n    } else {\n      current[finalKey] = value as any;\n    }\n  }\n}\n\nfunction fromGeminiFunctionCall(\n  part: GeminiPart,\n  previousChunks?: CandidateData[]\n): Part {\n  if (!part.functionCall) {\n    throw Error(\n      'Invalid Gemini Function Call Part: missing function call data'\n    );\n  }\n  const req: Partial<ToolRequest> = {\n    name: part.functionCall.name,\n    input: part.functionCall.args,\n  };\n\n  if (part.functionCall.id) {\n    req.ref = part.functionCall.id;\n  }\n\n  if (part.functionCall.willContinue) {\n    req.partial = true;\n  }\n\n  handleFunctionCallPartials(req, part, previousChunks);\n\n  const toolRequest: Part = { toolRequest: req as ToolRequest };\n\n  return maybeAddThoughtSignature(part, toolRequest);\n}\n\nfunction handleFunctionCallPartials(\n  req: Partial<ToolRequest>,\n  part: GeminiPart,\n  previousChunks?: CandidateData[]\n) {\n  if (!part.functionCall) {\n    throw Error(\n      'Invalid Gemini Function Call Part: missing function call data'\n    );\n  }\n\n  // we try to find if there's a previous partial tool request part.\n  const prevPart = previousChunks?.at(-1)?.message.content?.at(-1);\n  const prevPartialToolRequestPart =\n    prevPart?.toolRequest && prevPart?.toolRequest.partial\n      ? prevPart\n      : undefined;\n\n  // if the current functionCall has partialArgs, we try to apply the diff to the\n  // potentially including the previous partial part.\n  if (part.functionCall.partialArgs) {\n    const newInput = prevPartialToolRequestPart?.toolRequest?.input\n      ? JSON.parse(JSON.stringify(prevPartialToolRequestPart.toolRequest.input))\n      : {};\n    applyGeminiPartialArgs(newInput, part.functionCall.partialArgs);\n    req.input = newInput;\n  }\n\n  // If there's a previous partial part, we copy some fields over, because the\n  // API will not return these.\n  if (prevPartialToolRequestPart) {\n    if (!req.name) {\n      req.name = prevPartialToolRequestPart.toolRequest.name;\n    }\n    if (!req.ref) {\n      req.ref = prevPartialToolRequestPart.toolRequest.ref;\n    }\n    // This is a special case for the final partial function call chunk from the API,\n    // it will have nothing... so we need to make sure to copy the input\n    // from the previous.\n    if (req.input === undefined) {\n      req.input = prevPartialToolRequestPart.toolRequest.input;\n    }\n  }\n}\n\nfunction fromGeminiFunctionResponse(part: GeminiPart): Part {\n  if (!part.functionResponse) {\n    throw new Error(\n      'Invalid Gemini Function Call Part: missing function call data'\n    );\n  }\n  const toolResponse: Part = {\n    toolResponse: {\n      name: part.functionResponse.name.replace(/__/g, '/'), // restore slashes\n      output: part.functionResponse.response,\n    },\n  };\n  if (part.functionResponse.id) {\n    toolResponse.toolResponse.ref = part.functionResponse.id;\n  }\n  return maybeAddThoughtSignature(part, toolResponse);\n}\n\nfunction fromExecutableCode(part: GeminiPart): Part {\n  if (!part.executableCode) {\n    throw new Error('Invalid GeminiPart: missing executableCode');\n  }\n  return maybeAddThoughtSignature(part, {\n    custom: {\n      executableCode: {\n        language: part.executableCode.language,\n        code: part.executableCode.code,\n      },\n    },\n  });\n}\n\nfunction fromCodeExecutionResult(part: GeminiPart): Part {\n  if (!part.codeExecutionResult) {\n    throw new Error('Invalid GeminiPart: missing codeExecutionResult');\n  }\n  return maybeAddThoughtSignature(part, {\n    custom: {\n      codeExecutionResult: {\n        outcome: part.codeExecutionResult.outcome,\n        output: part.codeExecutionResult.output,\n      },\n    },\n  });\n}\n\nfunction fromGeminiText(part: GeminiPart): Part {\n  return maybeAddThoughtSignature(part, { text: part.text } as TextPart);\n}\n\nfunction fromGeminiPart(\n  part: GeminiPart,\n  previousChunks?: CandidateData[]\n): Part {\n  if (part.thought) return fromGeminiThought(part as any);\n  if (typeof part.text === 'string') return fromGeminiText(part);\n  if (part.inlineData) return fromGeminiInlineData(part);\n  if (part.fileData) return fromGeminiFileData(part);\n  if (part.functionCall) return fromGeminiFunctionCall(part, previousChunks);\n  if (part.functionResponse) return fromGeminiFunctionResponse(part);\n  if (part.executableCode) return fromExecutableCode(part);\n  if (part.codeExecutionResult) return fromCodeExecutionResult(part);\n\n  throw new Error('Unsupported GeminiPart type ' + JSON.stringify(part));\n}\n\nexport function fromGeminiCandidate(\n  candidate: GeminiCandidate,\n  previousChunks?: CandidateData[]\n): CandidateData {\n  const parts = candidate.content?.parts || [];\n  const genkitCandidate: CandidateData = {\n    index: candidate.index || 0,\n    message: {\n      role: 'model',\n      content: parts\n        // the model sometimes returns empty parts, ignore those.\n        .filter((p) => Object.keys(p).length > 0)\n        .map((part) => fromGeminiPart(part, previousChunks)),\n    },\n    finishReason: fromGeminiFinishReason(candidate.finishReason),\n    finishMessage: candidate.finishMessage,\n    custom: {\n      safetyRatings: candidate.safetyRatings,\n      citationMetadata: candidate.citationMetadata,\n    },\n  };\n\n  return genkitCandidate;\n}\n"],"mappings":"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","names":[]}