"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var converters_exports = {};
__export(converters_exports, {
  applyGeminiPartialArgs: () => applyGeminiPartialArgs,
  fromGeminiCandidate: () => fromGeminiCandidate,
  toGeminiFunctionModeEnum: () => toGeminiFunctionModeEnum,
  toGeminiMessage: () => toGeminiMessage,
  toGeminiSystemInstruction: () => toGeminiSystemInstruction,
  toGeminiTool: () => toGeminiTool
});
module.exports = __toCommonJS(converters_exports);
var import_genkit = require("genkit");
var import_jsonpath_plus = require("jsonpath-plus");
var import_types = require("./types.js");
function toGeminiTool(tool) {
  const declaration = {
    name: tool.name.replace(/\//g, "__"),
    // Gemini throws on '/' in tool name
    description: tool.description,
    parameters: toGeminiSchemaProperty(tool.inputSchema)
  };
  return declaration;
}
function toGeminiSchemaProperty(property) {
  if (!property || !property.type) {
    return void 0;
  }
  const baseSchema = {};
  if (property.description) {
    baseSchema.description = property.description;
  }
  if (property.enum) {
    baseSchema.enum = property.enum;
  }
  if (property.nullable) {
    baseSchema.nullable = property.nullable;
  }
  let propertyType;
  if (Array.isArray(property.type)) {
    const types = property.type;
    if (types.includes("null")) {
      baseSchema.nullable = true;
    }
    propertyType = types.find((t) => t !== "null");
  } else {
    propertyType = property.type;
  }
  if (propertyType === "object") {
    const nestedProperties = {};
    Object.keys(property.properties).forEach((key) => {
      nestedProperties[key] = toGeminiSchemaProperty(property.properties[key]);
    });
    return {
      ...baseSchema,
      type: import_types.SchemaType.OBJECT,
      properties: nestedProperties,
      required: property.required
    };
  } else if (propertyType === "array") {
    return {
      ...baseSchema,
      type: import_types.SchemaType.ARRAY,
      items: toGeminiSchemaProperty(property.items)
    };
  } else {
    const schemaType = import_types.SchemaType[propertyType.toUpperCase()];
    if (!schemaType) {
      throw new import_genkit.GenkitError({
        status: "INVALID_ARGUMENT",
        message: `Unsupported property type ${propertyType.toUpperCase()}`
      });
    }
    return {
      ...baseSchema,
      type: schemaType
    };
  }
}
function toGeminiMedia(part) {
  let media;
  if (part.media?.url.startsWith("data:")) {
    const dataUrl = part.media.url;
    const b64Data = dataUrl.substring(dataUrl.indexOf(",") + 1);
    const contentType = part.media.contentType || dataUrl.substring(dataUrl.indexOf(":") + 1, dataUrl.indexOf(";"));
    media = { inlineData: { mimeType: contentType, data: b64Data } };
  } else {
    if (!part.media?.contentType) {
      throw Error(
        "Must supply a `contentType` when sending File URIs to Gemini."
      );
    }
    media = {
      fileData: {
        mimeType: part.media.contentType,
        fileUri: part.media.url
      }
    };
  }
  if (part.metadata?.videoMetadata) {
    let videoMetadata = part.metadata.videoMetadata;
    media.videoMetadata = { ...videoMetadata };
  }
  if (part.metadata?.mediaResolution) {
    media.mediaResolution = { ...part.metadata.mediaResolution };
  }
  return maybeAddGeminiThoughtSignature(part, media);
}
function toGeminiToolRequest(part) {
  if (!part.toolRequest?.input) {
    throw Error("Invalid ToolRequestPart: input was missing.");
  }
  const functionCall = {
    name: part.toolRequest.name,
    args: part.toolRequest.input
  };
  if (part.toolRequest.ref) {
    functionCall.id = part.toolRequest.ref;
  }
  return maybeAddGeminiThoughtSignature(part, { functionCall });
}
function toGeminiToolResponse(part) {
  if (!part.toolResponse?.output) {
    throw Error("Invalid ToolResponsePart: output was missing.");
  }
  const functionResponse = {
    name: part.toolResponse.name,
    response: {
      name: part.toolResponse.name,
      content: part.toolResponse.output
    }
  };
  if (part.toolResponse.content) {
    functionResponse.parts = part.toolResponse.content.map(toGeminiPart);
  }
  if (part.toolResponse.ref) {
    functionResponse.id = part.toolResponse.ref;
  }
  return maybeAddGeminiThoughtSignature(part, {
    functionResponse
  });
}
function toGeminiReasoning(part) {
  const out = { thought: true };
  if (part.reasoning?.length) {
    out.text = part.reasoning;
  }
  return maybeAddGeminiThoughtSignature(part, out);
}
function toGeminiCustom(part) {
  if (part.custom?.codeExecutionResult) {
    return maybeAddGeminiThoughtSignature(part, {
      codeExecutionResult: part.custom.codeExecutionResult
    });
  }
  if (part.custom?.executableCode) {
    return maybeAddGeminiThoughtSignature(part, {
      executableCode: part.custom.executableCode
    });
  }
  throw new Error("Unsupported Custom Part type");
}
function toGeminiText(part) {
  return maybeAddGeminiThoughtSignature(part, { text: part.text ?? "" });
}
function maybeAddGeminiThoughtSignature(part, geminiPart) {
  if (part.metadata?.thoughtSignature) {
    return {
      ...geminiPart,
      thoughtSignature: part.metadata.thoughtSignature
    };
  }
  return geminiPart;
}
function toGeminiPart(part) {
  if (typeof part.text === "string") {
    return toGeminiText(part);
  }
  if (part.media) {
    return toGeminiMedia(part);
  }
  if (part.toolRequest) {
    return toGeminiToolRequest(part);
  }
  if (part.toolResponse) {
    return toGeminiToolResponse(part);
  }
  if (typeof part.reasoning === "string") {
    return toGeminiReasoning(part);
  }
  if (part.custom) {
    return toGeminiCustom(part);
  }
  throw new Error("Unsupported Part type " + JSON.stringify(part));
}
function toGeminiRole(role, model) {
  switch (role) {
    case "user":
      return "user";
    case "model":
      return "model";
    case "system":
      if (model?.info?.supports?.systemRole) {
        throw new Error(
          "system role is only supported for a single message in the first position"
        );
      } else {
        throw new Error("system role is not supported");
      }
    case "tool":
      return "function";
    default:
      return "user";
  }
}
function toGeminiMessage(message, model) {
  let sortedParts = message.content;
  if (message.role === "tool") {
    sortedParts = [...message.content].sort((a, b) => {
      const aRef = a.toolResponse?.ref;
      const bRef = b.toolResponse?.ref;
      if (!aRef && !bRef) return 0;
      if (!aRef) return 1;
      if (!bRef) return -1;
      return parseInt(aRef, 10) - parseInt(bRef, 10);
    });
  }
  return {
    role: toGeminiRole(message.role, model),
    parts: sortedParts.map(toGeminiPart)
  };
}
function toGeminiSystemInstruction(message) {
  return {
    role: "user",
    parts: message.content.map(toGeminiPart)
  };
}
function toGeminiFunctionModeEnum(from) {
  if (from === void 0) {
    return void 0;
  }
  switch (from) {
    case "MODE_UNSPECIFIED": {
      return import_types.FunctionCallingMode.MODE_UNSPECIFIED;
    }
    case "required":
    case "ANY": {
      return import_types.FunctionCallingMode.ANY;
    }
    case "auto":
    case "AUTO": {
      return import_types.FunctionCallingMode.AUTO;
    }
    case "none":
    case "NONE": {
      return import_types.FunctionCallingMode.NONE;
    }
    default:
      throw new Error(`unsupported function calling mode: ${from}`);
  }
}
function fromGeminiFinishReason(reason) {
  if (!reason) return "unknown";
  switch (reason) {
    case "STOP":
      return "stop";
    case "MAX_TOKENS":
      return "length";
    case "SAFETY":
    // blocked for safety
    case "RECITATION":
    // blocked for reciting training data
    case "LANGUAGE":
    // blocked for using an unsupported language
    case "BLOCKLIST":
    // blocked for forbidden terms
    case "PROHIBITED_CONTENT":
    // blocked for potentially containing prohibited content
    case "SPII":
      return "blocked";
    case "MALFORMED_FUNCTION_CALL":
    case "MISSING_THOUGHT_SIGNATURE":
    case "OTHER":
      return "other";
    default:
      return "unknown";
  }
}
function maybeAddThoughtSignature(geminiPart, part) {
  if (geminiPart.thoughtSignature) {
    return {
      ...part,
      metadata: {
        ...part?.metadata,
        thoughtSignature: geminiPart.thoughtSignature
      }
    };
  }
  return part;
}
function fromGeminiThought(part) {
  return maybeAddThoughtSignature(part, {
    reasoning: part.text || ""
  });
}
function fromGeminiInlineData(part) {
  if (!part.inlineData || !part.inlineData.hasOwnProperty("mimeType") || !part.inlineData.hasOwnProperty("data")) {
    throw new Error("Invalid GeminiPart: missing required properties");
  }
  const { mimeType, data } = part.inlineData;
  const dataUrl = `data:${mimeType};base64,${data}`;
  return maybeAddThoughtSignature(part, {
    media: {
      url: dataUrl,
      contentType: mimeType
    }
  });
}
function fromGeminiFileData(part) {
  if (!part.fileData || !part.fileData.hasOwnProperty("mimeType") || !part.fileData.hasOwnProperty("fileUri")) {
    throw new Error(
      "Invalid Gemini File Data Part: missing required properties"
    );
  }
  return maybeAddThoughtSignature(part, {
    media: {
      url: part.fileData?.fileUri,
      contentType: part.fileData?.mimeType
    }
  });
}
function applyGeminiPartialArgs(target, partialArgs) {
  for (const partialArg of partialArgs) {
    if (!partialArg.jsonPath) {
      continue;
    }
    let value;
    if (partialArg.boolValue !== void 0) {
      value = partialArg.boolValue;
    } else if (partialArg.nullValue !== void 0) {
      value = null;
    } else if (partialArg.numberValue !== void 0) {
      value = partialArg.numberValue;
    } else if (partialArg.stringValue !== void 0) {
      value = partialArg.stringValue;
    }
    if (value === void 0) {
      continue;
    }
    let current = target;
    const path = import_jsonpath_plus.JSONPath.toPathArray(partialArg.jsonPath);
    for (let i = 1; i < path.length - 1; i++) {
      const key = path[i];
      const nextKey = path[i + 1];
      if (current[key] === void 0) {
        if (!isNaN(parseInt(nextKey, 10))) {
          current[key] = [];
        } else {
          current[key] = {};
        }
      }
      current = current[key];
    }
    const finalKey = path[path.length - 1];
    if (partialArg.stringValue !== void 0 && typeof current[finalKey] === "string") {
      current[finalKey] += partialArg.stringValue;
    } else {
      current[finalKey] = value;
    }
  }
}
function fromGeminiFunctionCall(part, previousChunks) {
  if (!part.functionCall) {
    throw Error(
      "Invalid Gemini Function Call Part: missing function call data"
    );
  }
  const req = {
    name: part.functionCall.name,
    input: part.functionCall.args
  };
  if (part.functionCall.id) {
    req.ref = part.functionCall.id;
  }
  if (part.functionCall.willContinue) {
    req.partial = true;
  }
  handleFunctionCallPartials(req, part, previousChunks);
  const toolRequest = { toolRequest: req };
  return maybeAddThoughtSignature(part, toolRequest);
}
function handleFunctionCallPartials(req, part, previousChunks) {
  if (!part.functionCall) {
    throw Error(
      "Invalid Gemini Function Call Part: missing function call data"
    );
  }
  const prevPart = previousChunks?.at(-1)?.message.content?.at(-1);
  const prevPartialToolRequestPart = prevPart?.toolRequest && prevPart?.toolRequest.partial ? prevPart : void 0;
  if (part.functionCall.partialArgs) {
    const newInput = prevPartialToolRequestPart?.toolRequest?.input ? JSON.parse(JSON.stringify(prevPartialToolRequestPart.toolRequest.input)) : {};
    applyGeminiPartialArgs(newInput, part.functionCall.partialArgs);
    req.input = newInput;
  }
  if (prevPartialToolRequestPart) {
    if (!req.name) {
      req.name = prevPartialToolRequestPart.toolRequest.name;
    }
    if (!req.ref) {
      req.ref = prevPartialToolRequestPart.toolRequest.ref;
    }
    if (req.input === void 0) {
      req.input = prevPartialToolRequestPart.toolRequest.input;
    }
  }
}
function fromGeminiFunctionResponse(part) {
  if (!part.functionResponse) {
    throw new Error(
      "Invalid Gemini Function Call Part: missing function call data"
    );
  }
  const toolResponse = {
    toolResponse: {
      name: part.functionResponse.name.replace(/__/g, "/"),
      // restore slashes
      output: part.functionResponse.response
    }
  };
  if (part.functionResponse.id) {
    toolResponse.toolResponse.ref = part.functionResponse.id;
  }
  return maybeAddThoughtSignature(part, toolResponse);
}
function fromExecutableCode(part) {
  if (!part.executableCode) {
    throw new Error("Invalid GeminiPart: missing executableCode");
  }
  return maybeAddThoughtSignature(part, {
    custom: {
      executableCode: {
        language: part.executableCode.language,
        code: part.executableCode.code
      }
    }
  });
}
function fromCodeExecutionResult(part) {
  if (!part.codeExecutionResult) {
    throw new Error("Invalid GeminiPart: missing codeExecutionResult");
  }
  return maybeAddThoughtSignature(part, {
    custom: {
      codeExecutionResult: {
        outcome: part.codeExecutionResult.outcome,
        output: part.codeExecutionResult.output
      }
    }
  });
}
function fromGeminiText(part) {
  return maybeAddThoughtSignature(part, { text: part.text });
}
function fromGeminiPart(part, previousChunks) {
  if (part.thought) return fromGeminiThought(part);
  if (typeof part.text === "string") return fromGeminiText(part);
  if (part.inlineData) return fromGeminiInlineData(part);
  if (part.fileData) return fromGeminiFileData(part);
  if (part.functionCall) return fromGeminiFunctionCall(part, previousChunks);
  if (part.functionResponse) return fromGeminiFunctionResponse(part);
  if (part.executableCode) return fromExecutableCode(part);
  if (part.codeExecutionResult) return fromCodeExecutionResult(part);
  throw new Error("Unsupported GeminiPart type " + JSON.stringify(part));
}
function fromGeminiCandidate(candidate, previousChunks) {
  const parts = candidate.content?.parts || [];
  const genkitCandidate = {
    index: candidate.index || 0,
    message: {
      role: "model",
      content: parts.filter((p) => Object.keys(p).length > 0).map((part) => fromGeminiPart(part, previousChunks))
    },
    finishReason: fromGeminiFinishReason(candidate.finishReason),
    finishMessage: candidate.finishMessage,
    custom: {
      safetyRatings: candidate.safetyRatings,
      citationMetadata: candidate.citationMetadata
    }
  };
  return genkitCandidate;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  applyGeminiPartialArgs,
  fromGeminiCandidate,
  toGeminiFunctionModeEnum,
  toGeminiMessage,
  toGeminiSystemInstruction,
  toGeminiTool
});
//# sourceMappingURL=converters.js.map