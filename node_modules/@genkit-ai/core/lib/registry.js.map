{"version":3,"sources":["../src/registry.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Dotprompt } from 'dotprompt';\nimport type * as z from 'zod';\nimport {\n  runOutsideActionRuntimeContext,\n  type Action,\n  type ActionMetadata,\n} from './action.js';\nimport {\n  BackgroundAction,\n  lookupBackgroundAction,\n} from './background-action.js';\nimport { ActionContext } from './context.js';\nimport { isDynamicActionProvider } from './dynamic-action-provider.js';\nimport { GenkitError } from './error.js';\nimport { logger } from './logging.js';\nimport type { PluginProvider } from './plugin.js';\nimport { toJsonSchema, type JSONSchema } from './schema.js';\n\nexport type AsyncProvider<T> = () => Promise<T>;\n\n/**\n * Type of a runnable action.\n */\nconst ACTION_TYPES = [\n  'custom',\n  'dynamic-action-provider',\n  'embedder',\n  'evaluator',\n  'executable-prompt',\n  'flow',\n  'indexer',\n  'model',\n  'background-model',\n  'check-operation',\n  'cancel-operation',\n  'prompt',\n  'reranker',\n  'retriever',\n  'tool',\n  'tool.v2',\n  'util',\n  'resource',\n] as const;\nexport type ActionType = (typeof ACTION_TYPES)[number];\n\nexport function isActionType(value: string): value is ActionType {\n  return (ACTION_TYPES as readonly string[]).includes(value);\n}\n\n/**\n * A schema is either a Zod schema or a JSON schema.\n */\nexport interface Schema {\n  schema?: z.ZodTypeAny;\n  jsonSchema?: JSONSchema;\n}\n\nfunction parsePluginName(registryKey: string) {\n  const tokens = registryKey.split('/');\n  if (tokens.length >= 4) {\n    return tokens[2];\n  }\n  return undefined;\n}\n\ninterface ParsedRegistryKey {\n  dynamicActionHost?: string;\n  actionType: ActionType;\n  pluginName?: string;\n  actionName: string;\n}\n\n/**\n * Parses the registry key into key parts as per the key format convention. Ex:\n *  - mcp-host:tool/my-tool\n *  - /model/googleai/gemini-2.0-flash\n *  - /prompt/my-plugin/folder/my-prompt\n *  - /util/generate\n */\nexport function parseRegistryKey(\n  registryKey: string\n): ParsedRegistryKey | undefined {\n  if (registryKey.startsWith('/dynamic-action-provider')) {\n    // Dynamic Action Provider format: 'dynamic-action-provider/mcp-host:tool/mytool' or 'mcp-host:tool/*'\n    const keyTokens = registryKey.split(':');\n    const hostTokens = keyTokens[0].split('/');\n    if (hostTokens.length < 3) {\n      return undefined;\n    }\n    if (keyTokens.length < 2) {\n      return {\n        actionType: 'dynamic-action-provider',\n        actionName: hostTokens[2],\n      };\n    }\n    const tokens = keyTokens[1].split('/');\n    if (tokens.length < 2 || !isActionType(tokens[0])) {\n      return undefined;\n    }\n    return {\n      dynamicActionHost: hostTokens[2],\n      actionType: tokens[0],\n      actionName: tokens.slice(1).join('/'),\n    };\n  }\n\n  const tokens = registryKey.split('/');\n  if (tokens.length < 3) {\n    // Invalid key format\n    return undefined;\n  }\n  // ex: /model/googleai/gemini-2.0-flash or /prompt/my-plugin/folder/my-prompt\n  if (tokens.length >= 4) {\n    return {\n      actionType: tokens[1] as ActionType,\n      pluginName: tokens[2],\n      actionName: tokens.slice(3).join('/'),\n    };\n  }\n  // ex: /util/generate\n  return {\n    actionType: tokens[1] as ActionType,\n    actionName: tokens[2],\n  };\n}\n\nexport type ActionsRecord = Record<string, Action<z.ZodTypeAny, z.ZodTypeAny>>;\nexport type ActionMetadataRecord = Record<string, ActionMetadata>;\n\n/**\n * The registry is used to store and lookup actions, trace stores, flow state stores, plugins, and schemas.\n */\nexport class Registry {\n  private actionsById: Record<\n    string,\n    | Action<z.ZodTypeAny, z.ZodTypeAny>\n    | PromiseLike<Action<z.ZodTypeAny, z.ZodTypeAny>>\n  > = {};\n  private pluginsByName: Record<string, PluginProvider> = {};\n  private schemasByName: Record<string, Schema> = {};\n  private valueByTypeAndName: Record<string, Record<string, any>> = {};\n  private allPluginsInitialized = false;\n  public apiStability: 'stable' | 'beta' = 'stable';\n\n  readonly dotprompt: Dotprompt;\n  readonly parent?: Registry;\n  /** Additional runtime context data for flows and tools. */\n  context?: ActionContext;\n\n  constructor(parent?: Registry) {\n    if (parent) {\n      this.parent = parent;\n      this.apiStability = parent?.apiStability;\n      this.dotprompt = parent.dotprompt;\n    } else {\n      this.dotprompt = new Dotprompt({\n        schemaResolver: async (name) => {\n          const resolvedSchema = await this.lookupSchema(name);\n          if (!resolvedSchema) {\n            throw new GenkitError({\n              message: `Schema '${name}' not found`,\n              status: 'NOT_FOUND',\n            });\n          }\n          return toJsonSchema(resolvedSchema);\n        },\n      });\n    }\n  }\n\n  /**\n   * Creates a new registry overlaid onto the provided registry.\n   * @param parent The parent registry.\n   * @returns The new overlaid registry.\n   */\n  static withParent(parent: Registry) {\n    return new Registry(parent);\n  }\n\n  async resolveActionNames(key: string): Promise<string[]> {\n    const parsedKey = parseRegistryKey(key);\n    if (parsedKey?.dynamicActionHost) {\n      const hostId = `/dynamic-action-provider/${parsedKey.dynamicActionHost}`;\n      const dap = await this.actionsById[hostId];\n      if (!dap || !isDynamicActionProvider(dap)) {\n        return [];\n      }\n      return (\n        await dap.listActionMetadata(parsedKey.actionType, parsedKey.actionName)\n      ).map((m) => `${hostId}:${parsedKey.actionType}/${m.name}`);\n    }\n    if (await this.lookupAction(key)) {\n      return [key];\n    }\n    return [];\n  }\n\n  /**\n   * Looks up an action in the registry.\n   * @param key The key of the action to lookup.\n   * @returns The action.\n   */\n  async lookupAction<\n    I extends z.ZodTypeAny,\n    O extends z.ZodTypeAny,\n    R extends Action<I, O>,\n  >(key: string): Promise<R> {\n    const parsedKey = parseRegistryKey(key);\n    if (\n      parsedKey?.dynamicActionHost &&\n      this.actionsById[\n        `/dynamic-action-provider/${parsedKey.dynamicActionHost}`\n      ]\n    ) {\n      // If it's a dynamic action provider, get the dynamic action.\n      const action = await this.getDynamicAction(parsedKey);\n      if (action) {\n        return action as R;\n      }\n    }\n\n    // We always try to initialize the plugin first.\n    if (parsedKey?.pluginName && this.pluginsByName[parsedKey.pluginName]) {\n      await this.initializePlugin(parsedKey.pluginName);\n\n      // If we don't see the key in the registry, we try to resolve\n      // the action with the dynamic resolver. If it exists, it will\n      // register the action in the registry.\n      if (!this.actionsById[key]) {\n        await this.resolvePluginAction(\n          parsedKey.pluginName,\n          parsedKey.actionType,\n          parsedKey.actionName\n        );\n      }\n    }\n\n    return (\n      ((await this.actionsById[key]) as R) || this.parent?.lookupAction(key)\n    );\n  }\n\n  /**\n   * Looks up a background action from the registry.\n   * @param key The key of the action to lookup.\n   * @returns The action.\n   */\n  async lookupBackgroundAction(\n    key: string\n  ): Promise<BackgroundAction | undefined> {\n    return lookupBackgroundAction(this, key);\n  }\n\n  /**\n   * Registers an action in the registry.\n   * @param type The type of the action to register.\n   * @param action The action to register.\n   */\n  registerAction<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(\n    type: ActionType,\n    action: Action<I, O>,\n    opts?: { namespace?: string }\n  ) {\n    if (type !== action.__action.actionType) {\n      throw new GenkitError({\n        status: 'INVALID_ARGUMENT',\n        message: `action type (${type}) does not match type on action (${action.__action.actionType})`,\n      });\n    }\n    if (\n      opts?.namespace &&\n      !action.__action.name.startsWith(`${opts.namespace}/`)\n    ) {\n      action.__action.name = `${opts.namespace}/${action.__action.name}`;\n    }\n    const key = `/${type}/${action.__action.name}`;\n    logger.debug(`registering ${key}`);\n    if (this.actionsById.hasOwnProperty(key)) {\n      logger.error(\n        `ERROR: ${key} already has an entry in the registry. Overwriting.`\n      );\n    }\n    this.actionsById[key] = action;\n    if (action.__registry) {\n      logger.error(`ERROR: ${key} already registered.`);\n    }\n    action.__registry = this;\n  }\n\n  /**\n   * Registers an action promise in the registry.\n   */\n  registerActionAsync<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(\n    type: ActionType,\n    name: string,\n    action: PromiseLike<Action<I, O>>,\n    opts?: { namespace?: string }\n  ) {\n    if (opts?.namespace && !name.startsWith(`${opts.namespace}/`)) {\n      name = `${opts.namespace}/${name}`;\n    }\n    const key = `/${type}/${name}`;\n    logger.debug(`registering ${key} (async)`);\n    if (this.actionsById.hasOwnProperty(key)) {\n      logger.error(\n        `ERROR: ${key} already has an entry in the registry. Overwriting.`\n      );\n    }\n    this.actionsById[key] = action;\n  }\n\n  /**\n   * Returns all actions that have been registered in the registry.\n   * @returns All actions in the registry as a map of <key, action>.\n   */\n  async listActions(): Promise<ActionsRecord> {\n    await this.initializeAllPlugins();\n    const actions: Record<string, Action<z.ZodTypeAny, z.ZodTypeAny>> = {};\n    await Promise.all(\n      Object.entries(this.actionsById).map(async ([key, action]) => {\n        actions[key] = await action;\n      })\n    );\n    return {\n      ...(await this.parent?.listActions()),\n      ...actions,\n    };\n  }\n\n  /**\n   * Returns all actions that are resolvable by plugins as well as those that are already\n   * in the registry.\n   *\n   * NOTE: this method should not be used in latency sensitive code paths.\n   * It may rely on \"admin\" API calls such as \"list models\", which may cause increased cold start latency.\n   *\n   * @returns All resolvable action metadata as a map of <key, action metadata>.\n   */\n  async listResolvableActions(): Promise<ActionMetadataRecord> {\n    let resolvableActions = {} as ActionMetadataRecord;\n    // We listActions for all plugins in parallel.\n    await Promise.all(\n      Object.entries(this.pluginsByName).map(async ([pluginName, plugin]) => {\n        if (plugin.listActions) {\n          try {\n            (await plugin.listActions()).forEach((meta) => {\n              if (!meta.name) {\n                throw new GenkitError({\n                  status: 'INVALID_ARGUMENT',\n                  message: `Invalid metadata when listing actions from ${pluginName} - name required`,\n                });\n              }\n              if (!meta.actionType) {\n                throw new GenkitError({\n                  status: 'INVALID_ARGUMENT',\n                  message: `Invalid metadata when listing actions from ${pluginName} - actionType required`,\n                });\n              }\n              resolvableActions[`/${meta.actionType}/${meta.name}`] = meta;\n            });\n          } catch (e) {\n            logger.error(`Error listing actions for ${pluginName}\\n`, e);\n          }\n        }\n      })\n    );\n    // Also add actions that are already registered, and expand DAP actions\n    for (const [key, action] of Object.entries(await this.listActions())) {\n      resolvableActions[key] = action.__action;\n      if (isDynamicActionProvider(action)) {\n        try {\n          // Include the dynamic actions\n          const dapPrefix = `/${action.__action.actionType}/${action.__action.name}`;\n          const dapMetadataRecord =\n            await action.getActionMetadataRecord(dapPrefix);\n          resolvableActions = { ...resolvableActions, ...dapMetadataRecord };\n        } catch (e) {\n          logger.error(\n            `Error listing actions for Dynamic Action Provider ${action.__action.name}`\n          );\n        }\n      }\n    }\n    return {\n      ...(await this.parent?.listResolvableActions()),\n      ...resolvableActions,\n    };\n  }\n\n  /**\n   * Initializes all plugins in the registry.\n   */\n  async initializeAllPlugins() {\n    if (this.allPluginsInitialized) {\n      return;\n    }\n    for (const pluginName of Object.keys(this.pluginsByName)) {\n      await this.initializePlugin(pluginName);\n    }\n    this.allPluginsInitialized = true;\n  }\n\n  /**\n   * Registers a plugin provider. This plugin must be initialized before it can be used by calling {@link initializePlugin} or {@link initializeAllPlugins}.\n   * @param name The name of the plugin to register.\n   * @param provider The plugin provider.\n   */\n  registerPluginProvider(name: string, provider: PluginProvider) {\n    if (this.pluginsByName[name]) {\n      throw new Error(`Plugin ${name} already registered`);\n    }\n    this.allPluginsInitialized = false;\n    let cached;\n    let isInitialized = false;\n    this.pluginsByName[name] = {\n      name: provider.name,\n      initializer: () => {\n        if (!isInitialized) {\n          cached = provider.initializer();\n          isInitialized = true;\n        }\n        return cached;\n      },\n      resolver: async (actionType: ActionType, actionName: string) => {\n        if (provider.resolver) {\n          await provider.resolver(actionType, actionName);\n        }\n      },\n      listActions: async () => {\n        if (provider.listActions) {\n          return await provider.listActions();\n        }\n        return [];\n      },\n    };\n  }\n\n  /**\n   * Looks up a plugin.\n   * @param name The name of the plugin to lookup.\n   * @returns The plugin provider.\n   */\n  lookupPlugin(name: string): PluginProvider | undefined {\n    return this.pluginsByName[name] || this.parent?.lookupPlugin(name);\n  }\n\n  /**\n   * Resolves a new Action dynamically by registering it.\n   * @param pluginName The name of the plugin\n   * @param actionType The type of the action\n   * @param actionName The name of the action\n   * @returns\n   */\n  async resolvePluginAction(\n    pluginName: string,\n    actionType: ActionType,\n    actionName: string\n  ) {\n    const plugin = this.pluginsByName[pluginName];\n    if (plugin) {\n      return await runOutsideActionRuntimeContext(async () => {\n        if (plugin.resolver) {\n          await plugin.resolver(actionType, actionName);\n        }\n      });\n    }\n  }\n\n  async getDynamicAction(\n    key: ParsedRegistryKey\n  ): Promise<Action<z.ZodTypeAny, z.ZodTypeAny> | undefined> {\n    if (key.actionName.includes('*')) {\n      // * means multiple actions, this returns exactly one.\n      return undefined;\n    }\n    const actionId = `/dynamic-action-provider/${key.dynamicActionHost}`;\n    const dap = await this.actionsById[actionId];\n    if (!dap || !isDynamicActionProvider(dap)) {\n      return undefined;\n    }\n    return await dap.getAction(key.actionType, key.actionName);\n  }\n\n  /**\n   * Initializes a plugin already registered with {@link registerPluginProvider}.\n   * @param name The name of the plugin to initialize.\n   * @returns The plugin.\n   */\n  async initializePlugin(name: string) {\n    if (this.pluginsByName[name]) {\n      return await runOutsideActionRuntimeContext(() =>\n        this.pluginsByName[name].initializer()\n      );\n    }\n  }\n\n  /**\n   * Registers a schema.\n   * @param name The name of the schema to register.\n   * @param data The schema to register (either a Zod schema or a JSON schema).\n   */\n  registerSchema(name: string, data: Schema) {\n    if (this.schemasByName[name]) {\n      throw new Error(`Schema ${name} already registered`);\n    }\n    this.schemasByName[name] = data;\n  }\n\n  registerValue(type: string, name: string, value: any) {\n    if (!this.valueByTypeAndName[type]) {\n      this.valueByTypeAndName[type] = {};\n    }\n    this.valueByTypeAndName[type][name] = value;\n  }\n\n  async lookupValue<T = unknown>(\n    type: string,\n    key: string\n  ): Promise<T | undefined> {\n    const pluginName = parsePluginName(key);\n    if (!this.valueByTypeAndName[type]?.[key] && pluginName) {\n      await this.initializePlugin(pluginName);\n    }\n    return (\n      (this.valueByTypeAndName[type]?.[key] as T) ||\n      this.parent?.lookupValue(type, key)\n    );\n  }\n\n  async listValues<T>(type: string): Promise<Record<string, T>> {\n    await this.initializeAllPlugins();\n    return {\n      ...((await this.parent?.listValues(type)) || {}),\n      ...(this.valueByTypeAndName[type] || {}),\n    } as Record<string, T>;\n  }\n\n  /**\n   * Looks up a schema.\n   * @param name The name of the schema to lookup.\n   * @returns The schema.\n   */\n  lookupSchema(name: string): Schema | undefined {\n    return this.schemasByName[name] || this.parent?.lookupSchema(name);\n  }\n}\n\n/**\n * An object that has a reference to Genkit Registry.\n */\nexport interface HasRegistry {\n  get registry(): Registry;\n}\n"],"mappings":"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","names":["tokens"]}