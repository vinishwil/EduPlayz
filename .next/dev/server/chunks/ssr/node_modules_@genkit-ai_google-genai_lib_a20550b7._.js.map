{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/common/types.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { z } from 'genkit';\n\n/** Function calling mode. */\nexport enum FunctionCallingMode {\n  /** Unspecified function calling mode. This value should not be used. */\n  MODE_UNSPECIFIED = 'MODE_UNSPECIFIED',\n  /**\n   * Default model behavior, model decides to predict either function calls\n   * or natural language response.\n   */\n  AUTO = 'AUTO',\n  /**\n   * Model is constrained to always predicting function calls only.\n   * If \"allowedFunctionNames\" are set, the predicted function calls will be\n   * limited to any one of \"allowedFunctionNames\", else the predicted\n   * function calls will be any one of the provided \"function_declarations\".\n   */\n  ANY = 'ANY',\n  /**\n   * Model will not predict any function calls. Model behavior is same as when\n   * not passing any function declarations.\n   */\n  NONE = 'NONE',\n}\n\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * The reason why the response is blocked.\n */\nexport enum BlockReason {\n  /** Unspecified block reason. */\n  BLOCKED_REASON_UNSPECIFIED = 'BLOCKED_REASON_UNSPECIFIED', // GoogleAI\n  BLOCK_REASON_UNSPECIFIED = 'BLOCK_REASON_UNSPECIFIED', // VertexAI\n\n  /** Candidates blocked due to safety. */\n  SAFETY = 'SAFETY',\n  /** Candidates blocked due to other reason. */\n  OTHER = 'OTHER',\n  /** terminology blocklist. */\n  BLOCKLIST = 'BLOCKLIST',\n  /** Candidates blocked due to prohibited content. */\n  PROHIBITED_CONTENT = 'PROHIBITED_CONTENT',\n}\n\n/**\n * Harm categories that would cause prompts or candidates to be blocked.\n * @public\n */\nexport enum HarmCategory {\n  HARM_CATEGORY_UNSPECIFIED = 'HARM_CATEGORY_UNSPECIFIED',\n  HARM_CATEGORY_HATE_SPEECH = 'HARM_CATEGORY_HATE_SPEECH',\n  HARM_CATEGORY_SEXUALLY_EXPLICIT = 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n  HARM_CATEGORY_HARASSMENT = 'HARM_CATEGORY_HARASSMENT',\n  HARM_CATEGORY_DANGEROUS_CONTENT = 'HARM_CATEGORY_DANGEROUS_CONTENT',\n  HARM_CATEGORY_CIVIC_INTEGRITY = 'HARM_CATEGORY_CIVIC_INTEGRITY',\n}\n\n/**\n * Probability based thresholds levels for blocking.\n */\nexport enum HarmBlockThreshold {\n  /** Unspecified harm block threshold. */\n  HARM_BLOCK_THRESHOLD_UNSPECIFIED = 'HARM_BLOCK_THRESHOLD_UNSPECIFIED',\n  /** Block low threshold and above (i.e. block more). */\n  BLOCK_LOW_AND_ABOVE = 'BLOCK_LOW_AND_ABOVE',\n  /** Block medium threshold and above. */\n  BLOCK_MEDIUM_AND_ABOVE = 'BLOCK_MEDIUM_AND_ABOVE',\n  /** Block only high threshold (i.e. block less). */\n  BLOCK_ONLY_HIGH = 'BLOCK_ONLY_HIGH',\n  /** Block none. */\n  BLOCK_NONE = 'BLOCK_NONE',\n  /** Turn off the safety filter. */\n  OFF = 'OFF',\n}\n\n/**\n * Probability that a prompt or candidate matches a harm category.\n * @public\n */\nexport enum HarmProbability {\n  /** Probability is unspecified. */\n  HARM_PROBABILITY_UNSPECIFIED = 'HARM_PROBABILITY_UNSPECIFIED',\n  /** Content has a negligible chance of being unsafe. */\n  NEGLIGIBLE = 'NEGLIGIBLE',\n  /** Content has a low chance of being unsafe. */\n  LOW = 'LOW',\n  /** Content has a medium chance of being unsafe. */\n  MEDIUM = 'MEDIUM',\n  /** Content has a high chance of being unsafe. */\n  HIGH = 'HIGH',\n}\n\n/**\n * The mode of the predictor to be used in dynamic retrieval.\n * @public\n */\nexport enum DynamicRetrievalMode {\n  // Unspecified function calling mode. This value should not be used.\n  MODE_UNSPECIFIED = 'MODE_UNSPECIFIED',\n  // Run retrieval only when system decides it is necessary.\n  MODE_DYNAMIC = 'MODE_DYNAMIC',\n}\n\n/**\n * Specifies the dynamic retrieval configuration for the given source.\n * @public\n */\nexport declare interface DynamicRetrievalConfig {\n  /**\n   * The mode of the predictor to be used in dynamic retrieval.\n   */\n  mode?: DynamicRetrievalMode;\n  /**\n   * The threshold to be used in dynamic retrieval. If not set, a system default\n   * value is used.\n   */\n  dynamicThreshold?: number;\n}\n\n/**\n * Defines a retrieval tool that model can call to access external knowledge.\n */\nexport declare interface GoogleSearchRetrievalTool {\n  /** Optional. {@link GoogleSearchRetrieval}. */\n  googleSearchRetrieval?: GoogleSearchRetrieval;\n  googleSearch?: GoogleSearchRetrieval;\n}\nexport function isGoogleSearchRetrievalTool(\n  tool: Tool\n): tool is GoogleSearchRetrievalTool {\n  return (\n    (tool as GoogleSearchRetrievalTool).googleSearchRetrieval !== undefined ||\n    (tool as GoogleSearchRetrievalTool).googleSearch !== undefined\n  );\n}\n\nexport declare interface UrlContextTool {\n  urlContext?: {};\n}\n\n/**\n * The FileSearch tool that retrieves knowledge from Semantic Retrieval corpora.\n * Files are imported to Semantic Retrieval corpora using the ImportFile API\n */\nexport declare interface FileSearchTool {\n  fileSearch: FileSearch;\n}\n\nexport declare interface FileSearch {\n  /**\n   * The names of the fileSearchStores to retrieve from.\n   * Example: fileSearchStores/my-file-search-store-123\n   */\n  fileSearchStoreNames: string[];\n  /**\n   * Metadata filter to apply to the semantic retrieval documents and chunks.\n   */\n  metadataFilter?: string;\n  /**\n   * The number of semantic retrieval chunks to retrieve.\n   */\n  topK?: number;\n}\nexport function isFileSearchTool(tool: Tool): tool is FileSearchTool {\n  return (tool as FileSearchTool).fileSearch !== undefined;\n}\n\n/**\n * Grounding support.\n */\nexport declare interface GroundingSupport {\n  /** Optional. Segment of the content this support belongs to. */\n  segment?: GroundingSupportSegment;\n  /**\n   * Optional. A array of indices (into {@link GroundingChunk}) specifying the\n   * citations associated with the claim. For instance [1,3,4] means\n   * that grounding_chunk[1], grounding_chunk[3],\n   * grounding_chunk[4] are the retrieved content attributed to the claim.\n   */\n  groundingChunkIndices?: number[];\n  /**\n   * Confidence score of the support references. Ranges from 0 to 1. 1 is the\n   * most confident. This list must have the same size as the\n   * groundingChunkIndices.\n   */\n  confidenceScores?: number[];\n}\n\n/**\n * Grounding support segment.\n */\nexport declare interface GroundingSupportSegment {\n  /** Optional. The index of a Part object within its parent Content object. */\n  partIndex?: number;\n  /**\n   * Optional. Start index in the given Part, measured in bytes.\n   * Offset from the start of the Part, inclusive, starting at zero.\n   */\n  startIndex?: number;\n  /**\n   * Optional. End index in the given Part, measured in bytes.\n   * Offset from the start of the Part, exclusive, starting at zero.\n   */\n  endIndex?: number;\n  /** Optional. The text corresponding to the segment from the response. */\n  text?: string;\n}\n\n/**\n * Harm severity levels\n */\nexport enum HarmSeverity {\n  /** Harm severity unspecified. */\n  HARM_SEVERITY_UNSPECIFIED = 'HARM_SEVERITY_UNSPECIFIED',\n  /** Negligible level of harm severity. */\n  HARM_SEVERITY_NEGLIGIBLE = 'HARM_SEVERITY_NEGLIGIBLE',\n  /** Low level of harm severity. */\n  HARM_SEVERITY_LOW = 'HARM_SEVERITY_LOW',\n  /** Medium level of harm severity. */\n  HARM_SEVERITY_MEDIUM = 'HARM_SEVERITY_MEDIUM',\n  /** High level of harm severity. */\n  HARM_SEVERITY_HIGH = 'HARM_SEVERITY_HIGH',\n}\n\n/**\n * Safety rating corresponding to the generated content.\n */\nexport declare interface SafetyRating {\n  /** The harm category. {@link HarmCategory} */\n  category?: HarmCategory;\n  /** The harm probability. {@link HarmProbability} */\n  probability?: HarmProbability;\n  /** The harm probability score. */\n  probabilityScore?: number;\n  /** The harm severity.level {@link HarmSeverity} */\n  severity?: HarmSeverity;\n  /** The harm severity score. */\n  severityScore?: number;\n}\n\n/**\n * If the prompt was blocked, this will be populated with `blockReason` and\n * the relevant `safetyRatings`.\n */\nexport declare interface PromptFeedback {\n  /** The reason why the response is blocked. {@link BlockReason}. */\n  blockReason: BlockReason;\n  /** Array of {@link SafetyRating} */\n  safetyRatings: SafetyRating[];\n  /** A readable block reason message. */\n  blockReasonMessage?: string;\n}\n\n/**\n * URI based data.\n */\nexport declare interface FileData {\n  /** The IANA standard MIME type of the source data. */\n  mimeType: string;\n  /** URI of the file. */\n  fileUri: string;\n}\n\n/**\n * Raw media bytes sent directly in the request. Text should not be sent as\n * raw bytes.\n */\nexport declare interface GenerativeContentBlob {\n  /**\n   * The MIME type of the source data. The only accepted values: \"image/png\" or\n   * \"image/jpeg\".\n   */\n  mimeType: string;\n  /** Base64 encoded data. */\n  data: string;\n}\n\n/**\n * A predicted FunctionCall returned from the model that contains a string\n * representating the FunctionDeclaration.name with the parameters and their\n * values.\n */\nexport declare interface FunctionCall {\n  /**\n   * The unique id of the function call. If populated, the client to execute the\n   * `function_call` and return the response with the matching `id`.\n   */\n  id?: string;\n  /** The name of the function specified in FunctionDeclaration.name. */\n  name?: string;\n  /** The arguments to pass to the function. */\n  args?: object;\n  /** Optional. The partial argument value of the function call. If provided, represents the arguments/fields that are streamed incrementally. */\n  partialArgs?: PartialArg[];\n  /** Optional. Whether this is the last part of the FunctionCall. If true, another partial message for the current FunctionCall is expected to follow. */\n  willContinue?: boolean;\n}\n\n/** Partial argument value of the function call. This data type is not supported in Gemini API. */\nexport declare interface PartialArg {\n  /** Optional. Represents a null value. */\n  nullValue?: 'NULL_VALUE';\n  /** Optional. Represents a double value. */\n  numberValue?: number;\n  /** Optional. Represents a string value. */\n  stringValue?: string;\n  /** Optional. Represents a boolean value. */\n  boolValue?: boolean;\n  /** Required. A JSON Path (RFC 9535) to the argument being streamed. https://datatracker.ietf.org/doc/html/rfc9535. e.g. \"$.foo.bar[0].data\". */\n  jsonPath?: string;\n  /** Optional. Whether this is not the last part of the same json_path. If true, another PartialArg message for the current json_path is expected to follow. */\n  willContinue?: boolean;\n}\n/**\n * The result output of a FunctionCall that contains a string representing\n * the FunctionDeclaration.name and a structured JSON object containing any\n * output from the function call. It is used as context to the model.\n */\nexport declare interface FunctionResponse {\n  /** Optional. The id of the function call this response is for. Populated by the client to match the corresponding function call `id`. */\n  id?: string;\n  /** The name of the function specified in FunctionDeclaration.name. */\n  name: string;\n  /** The expected response from the model. */\n  response: object;\n  /** List of parts that constitute a function response. Each part may\n      have a different IANA MIME type. */\n  parts?: FunctionResponsePart[];\n}\n\n/**\n * A datatype containing media that is part of a `FunctionResponse` message.\n *\n * A `FunctionResponsePart` consists of data which has an associated datatype. A\n * `FunctionResponsePart` can only contain one of the accepted types in\n * `FunctionResponsePart.data`.\n *\n * A `FunctionResponsePart` must have a fixed IANA MIME type identifying the\n * type and subtype of the media if the `inline_data` field is filled with raw\n * bytes.\n */\nexport class FunctionResponsePart {\n  /** Optional. Inline media bytes. */\n  inlineData?: FunctionResponseBlob;\n}\n\n/**\n * Raw media bytes for function response.\n *\n * Text should not be sent as raw bytes, use the FunctionResponse.response field.\n */\nexport class FunctionResponseBlob {\n  /** Required. The IANA standard MIME type of the source data. */\n  mimeType?: string;\n  /** Required. Inline media bytes.\n   * @remarks Encoded as base64 string. */\n  data?: string;\n  /** Optional. Display name of the blob.\n      Used to provide a label or filename to distinguish blobs. */\n  displayName?: string;\n}\n\n/**\n * The list of OpenAPI data types\n * as defined by https://swagger.io/docs/specification/data-models/data-types/\n */\nexport enum SchemaType {\n  /** String type. */\n  STRING = 'STRING',\n  /** Number type. */\n  NUMBER = 'NUMBER',\n  /** Integer type. */\n  INTEGER = 'INTEGER',\n  /** Boolean type. */\n  BOOLEAN = 'BOOLEAN',\n  /** Array type. */\n  ARRAY = 'ARRAY',\n  /** Object type. */\n  OBJECT = 'OBJECT',\n}\n\nexport declare interface Schema {\n  type?: SchemaType;\n  format?: string;\n  title?: string;\n  description?: string;\n  nullable?: boolean;\n  items?: Schema;\n  minItems?: number;\n  maxItems?: number;\n  properties?: Record<string, Schema>;\n  enum?: string[];\n  required?: string[];\n  example?: unknown;\n}\n\n/**\n * Schema for parameters passed to {@link FunctionDeclaration.parameters}.\n */\nexport declare interface FunctionDeclarationSchema {\n  /** The type of the parameter. */\n  type: SchemaType;\n  /** The format of the parameter. */\n  properties: Record<string, Schema>;\n  /** Optional. Description of the parameter. */\n  description?: string;\n  /** Optional. Array of required parameters. */\n  required?: string[];\n}\n\nexport declare interface FunctionDeclaration {\n  /**\n   * The name of the function to call. Must start with a letter or an\n   * underscore. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with\n   * a max length of 64.\n   */\n  name: string;\n  /**\n   * Optional. Description and purpose of the function. Model uses it to decide\n   * how and whether to call the function.\n   */\n  description?: string;\n  /**\n   * Optional. Describes the parameters to this function in JSON Schema Object\n   * format. Reflects the Open API 3.03 Parameter Object. string Key: the name\n   * of the parameter. Parameter names are case sensitive. Schema Value: the\n   * Schema defining the type used for the parameter. For function with no\n   * parameters, this can be left unset.\n   *\n   * @example with 1 required and 1 optional parameter: type: OBJECT properties:\n   * ```\n   * param1:\n   *\n   *   type: STRING\n   * param2:\n   *\n   *  type: INTEGER\n   * required:\n   *\n   *   - param1\n   * ```\n   */\n  parameters?: FunctionDeclarationSchema;\n}\n\n/**\n * Metadata on the generation request's token usage.\n */\nexport declare interface UsageMetadata {\n  /** Optional. Number of tokens in the request. */\n  promptTokenCount?: number;\n  /** Optional. Number of tokens in the response(s). */\n  candidatesTokenCount?: number;\n  /** Optional. Total number of tokens. */\n  totalTokenCount?: number;\n  /** Optional. Number of tokens in the cached content. */\n  cachedContentTokenCount?: number;\n  /** Optional. Number of tokens present in thoughts output. */\n  thoughtsTokenCount?: number;\n}\n\nexport const TaskTypeSchema = z.enum([\n  'RETRIEVAL_DOCUMENT',\n  'RETRIEVAL_QUERY',\n  'SEMANTIC_SIMILARITY',\n  'CLASSIFICATION',\n  'CLUSTERING',\n]);\n\nexport type TaskType = z.infer<typeof TaskTypeSchema>;\n\n/**\n * Reason that a candidate finished.\n * @public\n */\nexport enum FinishReason {\n  // Default value. This value is unused.\n  FINISH_REASON_UNSPECIFIED = 'FINISH_REASON_UNSPECIFIED',\n  // Natural stop point of the model or provided stop sequence.\n  STOP = 'STOP',\n  // The maximum number of tokens as specified in the request was reached.\n  MAX_TOKENS = 'MAX_TOKENS',\n  // The candidate content was flagged for safety reasons.\n  SAFETY = 'SAFETY',\n  // The candidate content was flagged for recitation reasons.\n  RECITATION = 'RECITATION',\n  // The candidate content was flagged for using an unsupported language.\n  LANGUAGE = 'LANGUAGE',\n  // Token generation stopped because the content contains forbidden terms.\n  BLOCKLIST = 'BLOCKLIST',\n  // Token generation stopped for potentially containing prohibited content.\n  PROHIBITED_CONTENT = 'PROHIBITED_CONTENT',\n  // Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n  SPII = 'SPII',\n  // The function call generated by the model is invalid.\n  MALFORMED_FUNCTION_CALL = 'MALFORMED_FUNCTION_CALL',\n  // At least one thought signature from a previous call is missing.\n  MISSING_THOUGHT_SIGNATURE = 'MISSING_THOUGHT_SIGNATURE',\n  // Unknown reason.\n  OTHER = 'OTHER',\n}\n\n/**\n * Represents a whole or partial calendar date, such as a birthday. The time of\n * day and time zone are either specified elsewhere or are insignificant. The\n * date is relative to the Gregorian Calendar. This can represent one of the\n * following:\n *\n *   A full date, with non-zero year, month, and day values.\n *   A month and day, with a zero year (for example, an anniversary).\n *   A year on its own, with a zero month and a zero day.\n *   A year and month, with a zero day (for example, a credit card expiration\n *   date).\n */\nexport declare interface GoogleDate {\n  /**\n   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a\n   * year.\n   */\n  year?: number;\n  /**\n   * Month of the date. Must be from 1 to 12, or 0 to specify a year without a\n   * month and day.\n   */\n  month?: number;\n  /**\n   * Day of the date. Must be from 1 to 31 and valid for the year and month.\n   * or 0 to specify a year by itself or a year and month where the day isn't\n   * significant\n   */\n  day?: number;\n}\n\n/**\n * Source attributions for content.\n */\nexport declare interface CitationSource {\n  /** Optional. Start index into the content. */\n  startIndex?: number;\n  /** Optional. End index into the content. */\n  endIndex?: number;\n  /** Optional. Url reference of the attribution. */\n  uri?: string;\n  /** Optional. License of the attribution. */\n  license?: string;\n  /** Optional. Title of the attribution. VertexAI only.*/\n  title?: string;\n  /** Optional. Publication date of the attribution. VertexAI only */\n  publicationDate?: GoogleDate;\n}\n\n/**\n * A collection of source attributions for a piece of content.\n */\nexport declare interface CitationMetadata {\n  /** Array of {@link CitationSource}. */\n  citations?: CitationSource[]; // VertexAI\n  citationSources?: CitationSource[]; // GoogleAI\n}\n\n/**\n * Google search entry point.\n */\nexport declare interface SearchEntryPoint {\n  /**\n   * Optional. Web content snippet that can be embedded in a web page or an app\n   * webview.\n   */\n  renderedContent?: string;\n  /** Optional. Base64 encoded JSON representing array of tuple. */\n  sdkBlob?: string;\n}\n\n/**\n * Grounding chunk from the web.\n */\nexport declare interface GroundingChunkWeb {\n  /** Optional. URI reference of the grounding chunk. */\n  uri?: string;\n  /** Optional. Title of the grounding chunk. */\n  title?: string;\n}\n\n/**\n * Grounding chunk from context retrieved by the retrieval tools.\n */\nexport declare interface GroundingChunkRetrievedContext {\n  /** Optional. URI reference of the attribution. */\n  uri?: string;\n  /** Optional. Title of the attribution. */\n  title?: string;\n}\n\n/**\n * Grounding chunk.\n */\nexport declare interface GroundingChunk {\n  /** Optional. Grounding chunk from the web. */\n  web?: GroundingChunkWeb;\n  /**\n   * Optional. Grounding chunk from context retrieved by the retrieval tools. (VertexAI only)\n   */\n  retrievedContext?: GroundingChunkRetrievedContext;\n}\n\n/**\n * Metadata related to retrieval in the grounding flow. GoogleAI only.\n * @public\n */\nexport declare interface RetrievalMetadata {\n  /**\n   * Score indicating how likely information from google search could help\n   * answer the prompt. The score is in the range [0, 1], where 0 is the least\n   * likely and 1 is the most likely. This score is only populated when google\n   * search grounding and dynamic retrieval is enabled. It will becompared to\n   * the threshold to determine whether to trigger google search.\n   */\n  googleSearchDynamicRetrievalScore?: number;\n}\n\n/**\n * A collection of grounding attributions for a piece of content.\n */\nexport declare interface GroundingMetadata {\n  /** Optional. Google search entry for the following-up web searches. {@link SearchEntryPoint} */\n  searchEntryPoint?: SearchEntryPoint;\n  /**\n   * Optional. Array of supporting references retrieved from specified\n   * grounding source. {@link GroundingChunk}.\n   */\n  groundingChunks?: GroundingChunk[];\n  /** Optional. Array of grounding support. {@link GroundingSupport}. */\n  groundingSupports?: GroundingSupport[];\n  /** Optional. Web search queries for the following-up web search. */\n  webSearchQueries?: string[];\n  /** Optional. Queries executed by the retrieval tools. VertexAI only*/\n  retrievalQueries?: string[];\n  /**\n   * Optional. Metadata related to retrieval in the grounding flow. GoogleAI only.\n   */\n  retrievalMetadata?: RetrievalMetadata;\n}\n\n/**\n * @public\n */\nexport enum ExecutableCodeLanguage {\n  LANGUAGE_UNSPECIFIED = 'LANGUAGE_UNSPECIFIED',\n  PYTHON = 'PYTHON',\n}\n\n/**\n * Code generated by the model that is meant to be executed, where the result\n * is returned to the model.\n * Only generated when using the code execution tool, in which the code will\n * be automatically executed, and a corresponding `CodeExecutionResult` will\n * also be generated.\n *\n * @public\n */\nexport declare interface ExecutableCode {\n  /**\n   * Programming language of the `code`.\n   */\n  language: ExecutableCodeLanguage;\n  /**\n   * The code to be executed.\n   */\n  code: string;\n}\n\n/**\n * Possible outcomes of code execution.\n * @public\n */\nexport enum Outcome {\n  /**\n   * Unspecified status. This value should not be used.\n   */\n  OUTCOME_UNSPECIFIED = 'OUTCOME_UNSPECIFIED',\n  /**\n   * Code execution completed successfully.\n   */\n  OUTCOME_OK = 'OUTCOME_OK',\n  /**\n   * Code execution finished but with a failure. `stderr` should contain the\n   * reason.\n   */\n  OUTCOME_FAILED = 'OUTCOME_FAILED',\n  /**\n   * Code execution ran for too long, and was cancelled. There may or may not\n   * be a partial output present.\n   */\n  OUTCOME_DEADLINE_EXCEEDED = 'OUTCOME_DEADLINE_EXCEEDED',\n}\n\n/**\n * Result of executing the `ExecutableCode`.\n * Only generated when using code execution, and always follows a `Part`\n * containing the `ExecutableCode`.\n * @public\n */\nexport declare interface CodeExecutionResult {\n  /**\n   * Outcome of the code execution.\n   */\n  outcome: Outcome;\n  /**\n   * Contains stdout when code execution is successful, stderr or other\n   * description otherwise.\n   */\n  output: string;\n}\n\n/**\n * Can be added in the same part as video media to specify\n * which part of the video to consider and how many frames\n * per second to analyze. VertexAI only.\n */\nexport declare interface VideoMetadata {\n  /**\n   * The video offset to start at. e.g. '3.5s'\n   */\n  startOffset?: string;\n  /**\n   * The video offset to end at e.g. '10.5s'\n   */\n  endOffset?: string;\n  /**\n   * The number of frames to consider per second\n   * 0.0 to 24.0.\n   */\n  fps?: number;\n}\n\nexport enum MediaResolutionLevel {\n  MEDIA_RESOUTION_LOW = 'MEDIA_RESOUTION_LOW',\n  MEDIA_RESOLUTION_MEDIUM = 'MEDIA_RESOLUTION_MEDIUM',\n  MEDIA_RESOLUTION_HIGH = 'MEDIA_RESOLUTION_HIGH',\n}\n\nexport declare interface MediaResolution {\n  level?: MediaResolutionLevel;\n}\n\n/**\n * This is a Gemini Part. (Users never see this\n * structure, it is just built by the converters.)\n */\nexport declare interface Part {\n  text?: string;\n  inlineData?: GenerativeContentBlob;\n  functionCall?: FunctionCall;\n  functionResponse?: FunctionResponse;\n  fileData?: FileData;\n  thought?: boolean;\n  thoughtSignature?: string;\n  executableCode?: ExecutableCode;\n  codeExecutionResult?: CodeExecutionResult;\n  videoMetadata?: VideoMetadata;\n  mediaResolution?: MediaResolution;\n}\n\n/**\n * The base structured datatype containing multi-part content of a message.\n */\nexport declare interface Content {\n  /** The producer of the content. */\n  role: string;\n  /** Array of {@link Part}. */\n  parts: Part[];\n}\n\n/**\n * Candidate for the logprobs token and score.\n * @public\n */\nexport declare interface LogprobsCandidate {\n  /** The candidate's token string value. */\n  token: string;\n  /** The candidate's token id value. */\n  tokenID: number;\n  /** The candidate's log probability. */\n  logProbability: number;\n}\n\n/**\n * Candidates with top log probabilities at each decoding step\n */\nexport declare interface TopCandidates {\n  /** Sorted by log probability in descending order. */\n  candidates: LogprobsCandidate[];\n}\n\n/**\n * Logprobs Result\n * @public\n */\nexport declare interface LogprobsResult {\n  /** Length = total number of decoding steps. */\n  topCandidates: TopCandidates[];\n  /**\n   * Length = total number of decoding steps.\n   * The chosen candidates may or may not be in topCandidates.\n   */\n  chosenCandidates: LogprobsCandidate[];\n}\n\n/**\n * A candidate returned as part of a GenerateContentResponse.\n * @public\n */\nexport declare interface GenerateContentCandidate {\n  index: number;\n  content: Content;\n  finishReason?: FinishReason;\n  finishMessage?: string;\n  safetyRatings?: SafetyRating[];\n  citationMetadata?: CitationMetadata;\n  /** Average log probability score of the candidate. GoogleAI only*/\n  avgLogprobs?: number;\n  /** Log-likelihood scores for the response tokens and top tokens. GoogleAI only*/\n  logprobsResult?: LogprobsResult;\n  /** Search grounding metadata. */\n  groundingMetadata?: GroundingMetadata;\n}\n\n/**\n * Individual response from generateContent and generateContentStream.\n * `generateContentStream()` will return one in each chunk until\n * the stream is done.\n * @public\n */\nexport declare interface GenerateContentResponse {\n  /** Candidate responses from the model. */\n  candidates?: GenerateContentCandidate[];\n  /** The prompt's feedback related to the content filters. */\n  promptFeedback?: PromptFeedback;\n  /** Metadata on the generation request's token usage. */\n  usageMetadata?: UsageMetadata;\n}\n\n/**\n * A FunctionDeclarationsTool is a piece of code that enables the system to\n * interact with external systems to perform an action, or set of actions,\n * outside of knowledge and scope of the model.\n * @public\n */\nexport declare interface FunctionDeclarationsTool {\n  /**\n   * Optional. One or more function declarations\n   * to be passed to the model along with the current user query. Model may\n   * decide to call a subset of these functions by populating\n   * [FunctionCall][content.part.functionCall] in the response. User should\n   * provide a [FunctionResponse][content.part.functionResponse] for each\n   * function call in the next turn. Based on the function responses, Model will\n   * generate the final response back to the user. Maximum 64 function\n   * declarations can be provided.\n   */\n  functionDeclarations?: FunctionDeclaration[];\n}\nexport function isFunctionDeclarationsTool(\n  tool: Tool\n): tool is FunctionDeclarationsTool {\n  return (tool as FunctionDeclarationsTool).functionDeclarations !== undefined;\n}\n\n/**\n * Google AI Only. Enables the model to execute code as part of generation.\n * @public\n */\nexport declare interface CodeExecutionTool {\n  /**\n   * Provide an empty object to enable code execution. This field may have\n   * subfields added in the future.\n   */\n  codeExecution: {};\n}\nexport function isCodeExecutionTool(tool: Tool): tool is CodeExecutionTool {\n  return (tool as CodeExecutionTool).codeExecution !== undefined;\n}\n\n/**\n * Vertex AI Only. Retrieve from Vertex AI Search datastore for grounding.\n */\nexport declare interface VertexAISearch {\n  /**\n   * Fully-qualified Vertex AI Search's datastore resource ID. See\n   * https://cloud.google.com/vertex-ai-search-and-conversation\n   *\n   * @example\n   * \"projects/<>/locations/<>/collections/<>/dataStores/<>\"\n   */\n  datastore: string;\n}\n\n/**\n * Vertex AI Only. Config of Vertex RagStore grounding checking.\n */\nexport declare interface RagResource {\n  /**\n   * Optional. Vertex RAG Store corpus resource name.\n   *\n   * @example\n   * `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`\n   */\n  ragCorpus?: string;\n\n  /**\n   * Optional. Set this field to select the files under the ragCorpora for\n   * retrieval.\n   */\n  ragFileIds?: string[];\n}\n\n/** Vertex AI Only. */\nexport declare interface VertexRagStore {\n  /**\n   * Optional. List of corpora for retrieval. Currently only support one corpus\n   * or multiple files from one corpus. In the future we may open up multiple\n   * corpora support.\n   */\n  ragResources?: RagResource[];\n\n  /** Optional. Number of top k results to return from the selected corpora. */\n  similarityTopK?: number;\n\n  /**\n   * Optional. If set this field, results with vector distance smaller than\n   * this threshold will be returned.\n   */\n  vectorDistanceThreshold?: number;\n}\n\n/**\n * Vertex AI Only. Defines a retrieval tool that model can call to access external knowledge.\n */\nexport declare interface Retrieval {\n  /**\n   * Optional. Set to use data source powered by Vertex AI Search. {@link\n   * VertexAISearch}.\n   */\n  vertexAiSearch?: VertexAISearch;\n\n  /** Optional. Set to use data source powered by Vertex RAG store. */\n  vertexRagStore?: VertexRagStore;\n\n  /**\n   * Optional. Disable using the result from this tool in detecting grounding\n   * attribution. This does not affect how the result is given to the model for\n   * generation.\n   */\n  disableAttribution?: boolean;\n}\n\n/**\n * Vertex AI Only. Defines a retrieval tool that model can call to access external knowledge.\n */\nexport declare interface RetrievalTool {\n  /** Optional. {@link Retrieval}. */\n  retrieval?: Retrieval;\n}\nexport function isRetrievalTool(tool: Tool): tool is RetrievalTool {\n  return (tool as RetrievalTool).retrieval !== undefined;\n}\n\nexport declare interface GoogleMaps {\n  enableWidget: boolean;\n}\nexport declare interface GoogleMapsTool {\n  googleMaps?: GoogleMaps;\n}\nexport function isGoogleMapsTool(tool: Tool): tool is GoogleMapsTool {\n  return (tool as GoogleMapsTool).googleMaps !== undefined;\n}\n\n/**\n * Tool to retrieve public web data for grounding, powered by Google.\n */\nexport declare interface GoogleSearchRetrieval {\n  /** Specifies the dynamic retrieval configuration for the given source. */\n  dynamicRetrievalConfig?: DynamicRetrievalConfig;\n}\n\n/**\n * Defines a tool that model can call to access external knowledge.\n * @public\n */\nexport declare type Tool =\n  | FunctionDeclarationsTool\n  | RetrievalTool // Vertex AI Only\n  | GoogleMapsTool // Vertex AI Only\n  | CodeExecutionTool // Google AI Only\n  | FileSearchTool // Google AI Only\n  | UrlContextTool // Google AI Only\n  | GoogleSearchRetrievalTool;\n\n/**\n * Configuration options for model generation and outputs.\n */\nexport declare interface GenerationConfig {\n  /** Optional. If true, the timestamp of the audio will be included in the response. */\n  audioTimestamp?: boolean;\n  /** Optional. Number of candidates to generate. */\n  candidateCount?: number;\n  /** Optional. Stop sequences. */\n  stopSequences?: string[];\n  /** Optional. The maximum number of output tokens to generate per message. */\n  maxOutputTokens?: number;\n  /** Optional. Controls the randomness of predictions. */\n  temperature?: number;\n  /** Optional. If specified, nucleus sampling will be used. */\n  topP?: number;\n  /** Optional. If specified, topK sampling will be used. */\n  topK?: number;\n  /**\n   * Google AI only. Presence penalty applied to the next token's logprobs if the token has\n   * already been seen in the response.\n   */\n  presencePenalty?: number;\n  /**\n   * Optional. Positive values penalize tokens that repeatedly appear in the generated text, decreasing the probability of repeating content.\n   * This maximum value for frequencyPenalty is up to, but not including, 2.0. Its minimum value is -2.0.\n  frequencyPenalty?: number;\n  /**\n   * Google AI Only. If True, export the logprobs results in response.\n   */\n  responseLogprobs?: boolean;\n  /**\n   * Google AI Only. Valid if responseLogProbs is set to True. This will set the number of top\n   * logprobs to return at each decoding step in the logprobsResult.\n   */\n  logprobs?: number;\n  /**\n   * Optional. Output response mimetype of the generated candidate text.\n   * Supported mimetype:\n   * - `text/plain`: (default) Text output.\n   * - `application/json`: JSON response in the candidates.\n   * The model needs to be prompted to output the appropriate response type,\n   * otherwise the behavior is undefined.\n   */\n  responseMimeType?: string;\n\n  /**\n   * Optional. The schema that generated candidate text must follow.  For more\n   * information, see\n   * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/control-generated-output.\n   * If set, a compatible responseMimeType must also be set.\n   */\n  responseSchema?: Schema;\n\n  /**\n   * Optional. Output schema of the generated response. This is an alternative to\n   * `response_schema` that accepts [JSON Schema](https://json-schema.org/).\n   *\n   * If set, `response_schema` must be omitted, but `response_mime_type` is\n   * required.\n   *\n   * While the full JSON Schema may be sent, not all features are supported.\n   * Specifically, only the following properties are supported:\n   *\n   * - `$id`\n   * - `$defs`\n   * - `$ref`\n   * - `$anchor`\n   * - `type`\n   * - `format`\n   * - `title`\n   * - `description`\n   * - `enum` (for strings and numbers)\n   * - `items`\n   * - `prefixItems`\n   * - `minItems`\n   * - `maxItems`\n   * - `minimum`\n   * - `maximum`\n   * - `anyOf`\n   * - `oneOf` (interpreted the same as `anyOf`)\n   * - `properties`\n   * - `additionalProperties`\n   * - `required`\n   *\n   * The non-standard `propertyOrdering` property may also be set.\n   *\n   * Cyclic references are unrolled to a limited degree and, as such, may only\n   * be used within non-required properties. (Nullable properties are not\n   * sufficient.) If `$ref` is set on a sub-schema, no other properties, except\n   * for than those starting as a `$`, may be set.\n   */\n  responseJsonSchema?: Record<string, any>;\n}\n\n/**\n * Safety setting that can be sent as part of request parameters.\n * @public\n */\nexport declare interface SafetySetting {\n  category: HarmCategory;\n  threshold: HarmBlockThreshold;\n}\n\nexport declare interface FunctionCallingConfig {\n  /** Optional. Function calling mode. */\n  mode?: FunctionCallingMode;\n\n  /**\n   * Optional. Function names to call. Only set when the Mode is ANY. Function\n   * names should match [FunctionDeclaration.name]. With mode set to ANY, model\n   * will predict a function call from the set of function names provided.\n   */\n  allowedFunctionNames?: string[];\n\n  /**\n   * When set to true, arguments of a single function call will be streamed out\n   * in multiple parts/contents/responses. Partial parameter results will be\n   * returned in the [FunctionCall.partial_args] field.\n   */\n  streamFunctionCallArguments?: boolean;\n}\n\nexport declare interface LatLng {\n  latitude?: number;\n  longitude?: number;\n}\n\nexport declare interface RetrievalConfig {\n  latLng?: LatLng;\n  languageCode?: string;\n}\n\n/** This config is shared for all tools provided in the request. */\nexport declare interface ToolConfig {\n  /** Function calling config. */\n  functionCallingConfig?: FunctionCallingConfig;\n  /** Retrieval config */\n  retrievalConfig?: RetrievalConfig;\n}\n\nexport declare interface GenerateContentRequest {\n  /** Array of {@link Content}.*/\n  contents: Content[];\n  /**\n   * Optional. The name of the cached content used as context to serve the prediction.\n   * This is the name of a `CachedContent` and not the cache object itself.\n   */\n  cachedContent?: string;\n  /** Optional.  {@link GenerationConfig}. */\n  generationConfig?: GenerationConfig;\n  /**\n   * Optional. Vertex AI Only. Custom metadata labels for organizing API calls and managing costs at scale. See\n   * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/add-labels-to-api-calls\n   */\n  labels?: Record<string, string>;\n  /** Optional. Array of {@link SafetySetting}. */\n  safetySettings?: SafetySetting[];\n  /**\n   * Optional. The user provided system instructions for the model.\n   * Note: only text should be used in parts of {@link Content}\n   */\n  systemInstruction?: string | Part | Content;\n  /** Optional. Array of {@link Tool}. */\n  tools?: Tool[];\n  /** Optional. This config is shared for all tools provided in the request. */\n  toolConfig?: ToolConfig;\n}\n\n/**\n * Result from calling generateContentStream.\n * It contains both the stream and the final aggregated response.\n * @public\n */\nexport declare interface GenerateContentStreamResult {\n  stream: AsyncGenerator<GenerateContentResponse>;\n  response: Promise<GenerateContentResponse>;\n}\n\nexport declare interface ImagenParameters {\n  sampleCount?: number;\n  aspectRatio?: string;\n  negativePrompt?: string; // Vertex only\n  seed?: number; // Vertex only\n  language?: string; // Vertex only\n  personGeneration?: string;\n  safetySetting?: string; // Vertex only\n  addWatermark?: boolean; // Vertex only\n  storageUri?: string; // Vertex only\n}\n\nexport declare interface ImagenPredictRequest {\n  instances: ImagenInstance[];\n  parameters: ImagenParameters;\n}\n\nexport declare interface ImagenPredictResponse {\n  predictions: ImagenPrediction[];\n}\n\nexport declare interface ImagenPrediction {\n  bytesBase64Encoded: string;\n  mimeType: string;\n}\n\nexport declare interface ImagenInstance {\n  prompt: string;\n  image?: { bytesBase64Encoded: string };\n  mask?: { image?: { bytesBase64Encoded: string } };\n}\n"],"names":["FunctionCallingMode","BlockReason","HarmCategory","HarmBlockThreshold","HarmProbability","DynamicRetrievalMode","HarmSeverity","SchemaType","FinishReason","ExecutableCodeLanguage","Outcome","MediaResolutionLevel"],"mappings":"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"}},
    {"offset": {"line": 217, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/common/converters.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenkitError, ToolRequest, z } from 'genkit';\nimport {\n  CandidateData,\n  MessageData,\n  ModelReference,\n  Part,\n  TextPart,\n  ToolDefinition,\n} from 'genkit/model';\nimport { JSONPath } from 'jsonpath-plus';\nimport {\n  FunctionCallingMode,\n  FunctionDeclaration,\n  GenerateContentCandidate as GeminiCandidate,\n  Content as GeminiContent,\n  Part as GeminiPart,\n  PartialArg,\n  Schema,\n  SchemaType,\n  VideoMetadata,\n} from './types.js';\n\nexport function toGeminiTool(tool: ToolDefinition): FunctionDeclaration {\n  const declaration: FunctionDeclaration = {\n    name: tool.name.replace(/\\//g, '__'), // Gemini throws on '/' in tool name\n    description: tool.description,\n    parameters: toGeminiSchemaProperty(tool.inputSchema),\n  };\n  return declaration;\n}\n\nfunction toGeminiSchemaProperty(property?: ToolDefinition['inputSchema']) {\n  if (!property || !property.type) {\n    return undefined;\n  }\n  const baseSchema: Schema = {};\n  if (property.description) {\n    baseSchema.description = property.description;\n  }\n  if (property.enum) {\n    baseSchema.enum = property.enum;\n  }\n  if (property.nullable) {\n    baseSchema.nullable = property.nullable;\n  }\n  let propertyType;\n  // nullable schema can ALSO be defined as, for example, type=['string','null']\n  if (Array.isArray(property.type)) {\n    const types = property.type as string[];\n    if (types.includes('null')) {\n      baseSchema.nullable = true;\n    }\n    // grab the type that's not `null`\n    propertyType = types.find((t) => t !== 'null');\n  } else {\n    propertyType = property.type;\n  }\n  if (propertyType === 'object') {\n    const nestedProperties = {};\n    Object.keys(property.properties).forEach((key) => {\n      nestedProperties[key] = toGeminiSchemaProperty(property.properties[key]);\n    });\n    return {\n      ...baseSchema,\n      type: SchemaType.OBJECT,\n      properties: nestedProperties,\n      required: property.required,\n    };\n  } else if (propertyType === 'array') {\n    return {\n      ...baseSchema,\n      type: SchemaType.ARRAY,\n      items: toGeminiSchemaProperty(property.items),\n    };\n  } else {\n    const schemaType = SchemaType[propertyType.toUpperCase()] as SchemaType;\n    if (!schemaType) {\n      throw new GenkitError({\n        status: 'INVALID_ARGUMENT',\n        message: `Unsupported property type ${propertyType.toUpperCase()}`,\n      });\n    }\n    return {\n      ...baseSchema,\n      type: schemaType,\n    };\n  }\n}\n\nfunction toGeminiMedia(part: Part): GeminiPart {\n  let media: GeminiPart;\n  if (part.media?.url.startsWith('data:')) {\n    // Inline data\n    const dataUrl = part.media.url;\n    const b64Data = dataUrl.substring(dataUrl.indexOf(',')! + 1);\n    const contentType =\n      part.media.contentType ||\n      dataUrl.substring(dataUrl.indexOf(':')! + 1, dataUrl.indexOf(';'));\n    media = { inlineData: { mimeType: contentType, data: b64Data } };\n  } else {\n    // File data\n    if (!part.media?.contentType) {\n      throw Error(\n        'Must supply a `contentType` when sending File URIs to Gemini.'\n      );\n    }\n    media = {\n      fileData: {\n        mimeType: part.media.contentType,\n        fileUri: part.media.url,\n      },\n    };\n  }\n\n  // Video metadata\n  if (part.metadata?.videoMetadata) {\n    let videoMetadata = part.metadata.videoMetadata as VideoMetadata;\n    media.videoMetadata = { ...videoMetadata };\n  }\n\n  // Media resolution\n  if (part.metadata?.mediaResolution) {\n    media.mediaResolution = { ...part.metadata.mediaResolution };\n  }\n\n  return maybeAddGeminiThoughtSignature(part, media);\n}\n\nfunction toGeminiToolRequest(part: Part): GeminiPart {\n  if (!part.toolRequest?.input) {\n    throw Error('Invalid ToolRequestPart: input was missing.');\n  }\n  const functionCall: GeminiPart['functionCall'] = {\n    name: part.toolRequest.name,\n    args: part.toolRequest.input,\n  };\n  if (part.toolRequest.ref) {\n    functionCall.id = part.toolRequest.ref;\n  }\n  return maybeAddGeminiThoughtSignature(part, { functionCall });\n}\n\nfunction toGeminiToolResponse(part: Part): GeminiPart {\n  if (!part.toolResponse?.output) {\n    throw Error('Invalid ToolResponsePart: output was missing.');\n  }\n  const functionResponse: GeminiPart['functionResponse'] = {\n    name: part.toolResponse.name,\n    response: {\n      name: part.toolResponse.name,\n      content: part.toolResponse.output,\n    },\n  };\n  if (part.toolResponse.content) {\n    functionResponse.parts = part.toolResponse.content.map(toGeminiPart);\n  }\n  if (part.toolResponse.ref) {\n    functionResponse.id = part.toolResponse.ref;\n  }\n  return maybeAddGeminiThoughtSignature(part, {\n    functionResponse,\n  });\n}\n\nfunction toGeminiReasoning(part: Part): GeminiPart {\n  const out: GeminiPart = { thought: true };\n  if (part.reasoning?.length) {\n    out.text = part.reasoning;\n  }\n  return maybeAddGeminiThoughtSignature(part, out);\n}\n\nfunction toGeminiCustom(part: Part): GeminiPart {\n  if (part.custom?.codeExecutionResult) {\n    return maybeAddGeminiThoughtSignature(part, {\n      codeExecutionResult: part.custom.codeExecutionResult,\n    });\n  }\n  if (part.custom?.executableCode) {\n    return maybeAddGeminiThoughtSignature(part, {\n      executableCode: part.custom.executableCode,\n    });\n  }\n  throw new Error('Unsupported Custom Part type');\n}\n\nfunction toGeminiText(part: Part): GeminiPart {\n  return maybeAddGeminiThoughtSignature(part, { text: part.text ?? '' });\n}\n\nfunction maybeAddGeminiThoughtSignature(\n  part: Part,\n  geminiPart: GeminiPart\n): GeminiPart {\n  if (part.metadata?.thoughtSignature) {\n    return {\n      ...geminiPart,\n      thoughtSignature: part.metadata.thoughtSignature as string,\n    };\n  }\n  return geminiPart;\n}\n\nfunction toGeminiPart(part: Part): GeminiPart {\n  if (typeof part.text === 'string') {\n    return toGeminiText(part);\n  }\n  if (part.media) {\n    return toGeminiMedia(part);\n  }\n  if (part.toolRequest) {\n    return toGeminiToolRequest(part);\n  }\n  if (part.toolResponse) {\n    return toGeminiToolResponse(part);\n  }\n  if (typeof part.reasoning === 'string') {\n    return toGeminiReasoning(part);\n  }\n  if (part.custom) {\n    return toGeminiCustom(part);\n  }\n\n  throw new Error('Unsupported Part type ' + JSON.stringify(part));\n}\n\nfunction toGeminiRole(\n  role: MessageData['role'],\n  model?: ModelReference<z.ZodTypeAny>\n): string {\n  switch (role) {\n    case 'user':\n      return 'user';\n    case 'model':\n      return 'model';\n    case 'system':\n      if (model?.info?.supports?.systemRole) {\n        // We should have already pulled out the supported system messages,\n        // anything remaining is unsupported; throw an error.\n        throw new Error(\n          'system role is only supported for a single message in the first position'\n        );\n      } else {\n        throw new Error('system role is not supported');\n      }\n    case 'tool':\n      return 'function';\n    default:\n      return 'user';\n  }\n}\n\nexport function toGeminiMessage(\n  message: MessageData,\n  model?: ModelReference<z.ZodTypeAny>\n): GeminiContent {\n  let sortedParts = message.content;\n  if (message.role === 'tool') {\n    sortedParts = [...message.content].sort((a, b) => {\n      const aRef = a.toolResponse?.ref;\n      const bRef = b.toolResponse?.ref;\n      if (!aRef && !bRef) return 0;\n      if (!aRef) return 1;\n      if (!bRef) return -1;\n      return parseInt(aRef, 10) - parseInt(bRef, 10);\n    });\n  }\n  return {\n    role: toGeminiRole(message.role, model),\n    parts: sortedParts.map(toGeminiPart),\n  };\n}\n\nexport function toGeminiSystemInstruction(message: MessageData): GeminiContent {\n  return {\n    role: 'user',\n    parts: message.content.map(toGeminiPart),\n  };\n}\n\n/**\n * Converts mode from either genkit tool choice (lowercase)\n * or functionCallingConfig (uppercase).\n * @param from The mode to convert from\n * @returns\n */\nexport function toGeminiFunctionModeEnum(\n  from?: string\n  //genkitMode: 'auto' | 'required' | 'none'\n): FunctionCallingMode | undefined {\n  if (from === undefined) {\n    return undefined;\n  }\n  switch (from) {\n    case 'MODE_UNSPECIFIED': {\n      return FunctionCallingMode.MODE_UNSPECIFIED;\n    }\n    case 'required':\n    case 'ANY': {\n      return FunctionCallingMode.ANY;\n    }\n    case 'auto':\n    case 'AUTO': {\n      return FunctionCallingMode.AUTO;\n    }\n    case 'none':\n    case 'NONE': {\n      return FunctionCallingMode.NONE;\n    }\n    default:\n      throw new Error(`unsupported function calling mode: ${from}`);\n  }\n}\n\nfunction fromGeminiFinishReason(\n  reason: GeminiCandidate['finishReason']\n): CandidateData['finishReason'] {\n  if (!reason) return 'unknown';\n  switch (reason) {\n    case 'STOP':\n      return 'stop';\n    case 'MAX_TOKENS':\n      return 'length';\n    case 'SAFETY': // blocked for safety\n    case 'RECITATION': // blocked for reciting training data\n    case 'LANGUAGE': // blocked for using an unsupported language\n    case 'BLOCKLIST': // blocked for forbidden terms\n    case 'PROHIBITED_CONTENT': // blocked for potentially containing prohibited content\n    case 'SPII': // blocked for potentially containing Sensitive Personally Identifiable Information\n      return 'blocked';\n    case 'MALFORMED_FUNCTION_CALL':\n    case 'MISSING_THOUGHT_SIGNATURE':\n    case 'OTHER':\n      return 'other';\n    default:\n      return 'unknown';\n  }\n}\n\nfunction maybeAddThoughtSignature(geminiPart: GeminiPart, part: Part): Part {\n  if (geminiPart.thoughtSignature) {\n    return {\n      ...part,\n      metadata: {\n        ...part?.metadata,\n        thoughtSignature: geminiPart.thoughtSignature,\n      },\n    };\n  }\n  return part;\n}\n\nfunction fromGeminiThought(part: GeminiPart): Part {\n  return maybeAddThoughtSignature(part, {\n    reasoning: part.text || '',\n  });\n}\n\nfunction fromGeminiInlineData(part: GeminiPart): Part {\n  // Check if the required properties exist\n  if (\n    !part.inlineData ||\n    !part.inlineData.hasOwnProperty('mimeType') ||\n    !part.inlineData.hasOwnProperty('data')\n  ) {\n    throw new Error('Invalid GeminiPart: missing required properties');\n  }\n  const { mimeType, data } = part.inlineData;\n  // Combine data and mimeType into a data URL\n  const dataUrl = `data:${mimeType};base64,${data}`;\n\n  return maybeAddThoughtSignature(part, {\n    media: {\n      url: dataUrl,\n      contentType: mimeType,\n    },\n  });\n}\n\nfunction fromGeminiFileData(part: GeminiPart): Part {\n  if (\n    !part.fileData ||\n    !part.fileData.hasOwnProperty('mimeType') ||\n    !part.fileData.hasOwnProperty('fileUri')\n  ) {\n    throw new Error(\n      'Invalid Gemini File Data Part: missing required properties'\n    );\n  }\n\n  return maybeAddThoughtSignature(part, {\n    media: {\n      url: part.fileData?.fileUri,\n      contentType: part.fileData?.mimeType,\n    },\n  });\n}\n\n/**\n * Applies Gemini partial args to the target object.\n *\n * https://docs.cloud.google.com/vertex-ai/generative-ai/docs/reference/rest/v1/Content#PartialArg\n */\nexport function applyGeminiPartialArgs(\n  target: object,\n  partialArgs: PartialArg[]\n) {\n  for (const partialArg of partialArgs) {\n    if (!partialArg.jsonPath) {\n      continue;\n    }\n    let value: boolean | string | number | null | undefined;\n    if (partialArg.boolValue !== undefined) {\n      value = partialArg.boolValue;\n    } else if (partialArg.nullValue !== undefined) {\n      value = null;\n    } else if (partialArg.numberValue !== undefined) {\n      value = partialArg.numberValue;\n    } else if (partialArg.stringValue !== undefined) {\n      value = partialArg.stringValue;\n    }\n    if (value === undefined) {\n      continue;\n    }\n\n    let current: any = target;\n    const path = JSONPath.toPathArray(partialArg.jsonPath);\n    // ex: for path '$.data[0][0]' toPathArray returns: ['$', 'data', '0', '0']\n    // we skip the first (root) reference and dereference the rest.\n    for (let i = 1; i < path.length - 1; i++) {\n      const key = path[i];\n      const nextKey = path[i + 1];\n      if (current[key] === undefined) {\n        if (!isNaN(parseInt(nextKey, 10))) {\n          current[key] = [];\n        } else {\n          current[key] = {};\n        }\n      }\n      current = current[key];\n    }\n\n    const finalKey = path[path.length - 1];\n    if (\n      partialArg.stringValue !== undefined &&\n      typeof current[finalKey] === 'string'\n    ) {\n      current[finalKey] += partialArg.stringValue;\n    } else {\n      current[finalKey] = value as any;\n    }\n  }\n}\n\nfunction fromGeminiFunctionCall(\n  part: GeminiPart,\n  previousChunks?: CandidateData[]\n): Part {\n  if (!part.functionCall) {\n    throw Error(\n      'Invalid Gemini Function Call Part: missing function call data'\n    );\n  }\n  const req: Partial<ToolRequest> = {\n    name: part.functionCall.name,\n    input: part.functionCall.args,\n  };\n\n  if (part.functionCall.id) {\n    req.ref = part.functionCall.id;\n  }\n\n  if (part.functionCall.willContinue) {\n    req.partial = true;\n  }\n\n  handleFunctionCallPartials(req, part, previousChunks);\n\n  const toolRequest: Part = { toolRequest: req as ToolRequest };\n\n  return maybeAddThoughtSignature(part, toolRequest);\n}\n\nfunction handleFunctionCallPartials(\n  req: Partial<ToolRequest>,\n  part: GeminiPart,\n  previousChunks?: CandidateData[]\n) {\n  if (!part.functionCall) {\n    throw Error(\n      'Invalid Gemini Function Call Part: missing function call data'\n    );\n  }\n\n  // we try to find if there's a previous partial tool request part.\n  const prevPart = previousChunks?.at(-1)?.message.content?.at(-1);\n  const prevPartialToolRequestPart =\n    prevPart?.toolRequest && prevPart?.toolRequest.partial\n      ? prevPart\n      : undefined;\n\n  // if the current functionCall has partialArgs, we try to apply the diff to the\n  // potentially including the previous partial part.\n  if (part.functionCall.partialArgs) {\n    const newInput = prevPartialToolRequestPart?.toolRequest?.input\n      ? JSON.parse(JSON.stringify(prevPartialToolRequestPart.toolRequest.input))\n      : {};\n    applyGeminiPartialArgs(newInput, part.functionCall.partialArgs);\n    req.input = newInput;\n  }\n\n  // If there's a previous partial part, we copy some fields over, because the\n  // API will not return these.\n  if (prevPartialToolRequestPart) {\n    if (!req.name) {\n      req.name = prevPartialToolRequestPart.toolRequest.name;\n    }\n    if (!req.ref) {\n      req.ref = prevPartialToolRequestPart.toolRequest.ref;\n    }\n    // This is a special case for the final partial function call chunk from the API,\n    // it will have nothing... so we need to make sure to copy the input\n    // from the previous.\n    if (req.input === undefined) {\n      req.input = prevPartialToolRequestPart.toolRequest.input;\n    }\n  }\n}\n\nfunction fromGeminiFunctionResponse(part: GeminiPart): Part {\n  if (!part.functionResponse) {\n    throw new Error(\n      'Invalid Gemini Function Call Part: missing function call data'\n    );\n  }\n  const toolResponse: Part = {\n    toolResponse: {\n      name: part.functionResponse.name.replace(/__/g, '/'), // restore slashes\n      output: part.functionResponse.response,\n    },\n  };\n  if (part.functionResponse.id) {\n    toolResponse.toolResponse.ref = part.functionResponse.id;\n  }\n  return maybeAddThoughtSignature(part, toolResponse);\n}\n\nfunction fromExecutableCode(part: GeminiPart): Part {\n  if (!part.executableCode) {\n    throw new Error('Invalid GeminiPart: missing executableCode');\n  }\n  return maybeAddThoughtSignature(part, {\n    custom: {\n      executableCode: {\n        language: part.executableCode.language,\n        code: part.executableCode.code,\n      },\n    },\n  });\n}\n\nfunction fromCodeExecutionResult(part: GeminiPart): Part {\n  if (!part.codeExecutionResult) {\n    throw new Error('Invalid GeminiPart: missing codeExecutionResult');\n  }\n  return maybeAddThoughtSignature(part, {\n    custom: {\n      codeExecutionResult: {\n        outcome: part.codeExecutionResult.outcome,\n        output: part.codeExecutionResult.output,\n      },\n    },\n  });\n}\n\nfunction fromGeminiText(part: GeminiPart): Part {\n  return maybeAddThoughtSignature(part, { text: part.text } as TextPart);\n}\n\nfunction fromGeminiPart(\n  part: GeminiPart,\n  previousChunks?: CandidateData[]\n): Part {\n  if (part.thought) return fromGeminiThought(part as any);\n  if (typeof part.text === 'string') return fromGeminiText(part);\n  if (part.inlineData) return fromGeminiInlineData(part);\n  if (part.fileData) return fromGeminiFileData(part);\n  if (part.functionCall) return fromGeminiFunctionCall(part, previousChunks);\n  if (part.functionResponse) return fromGeminiFunctionResponse(part);\n  if (part.executableCode) return fromExecutableCode(part);\n  if (part.codeExecutionResult) return fromCodeExecutionResult(part);\n\n  throw new Error('Unsupported GeminiPart type ' + JSON.stringify(part));\n}\n\nexport function fromGeminiCandidate(\n  candidate: GeminiCandidate,\n  previousChunks?: CandidateData[]\n): CandidateData {\n  const parts = candidate.content?.parts || [];\n  const genkitCandidate: CandidateData = {\n    index: candidate.index || 0,\n    message: {\n      role: 'model',\n      content: parts\n        // the model sometimes returns empty parts, ignore those.\n        .filter((p) => Object.keys(p).length > 0)\n        .map((part) => fromGeminiPart(part, previousChunks)),\n    },\n    finishReason: fromGeminiFinishReason(candidate.finishReason),\n    finishMessage: candidate.finishMessage,\n    custom: {\n      safetyRatings: candidate.safetyRatings,\n      citationMetadata: candidate.citationMetadata,\n    },\n  };\n\n  return genkitCandidate;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 755, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/common/utils.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  EmbedderReference,\n  GenkitError,\n  Part as GenkitPart,\n  JSONSchema,\n  MediaPart,\n  ModelReference,\n  getClientHeader as defaultGetClientHeader,\n  z,\n} from 'genkit';\nimport { GenerateRequest } from 'genkit/model';\nimport { applyGeminiPartialArgs } from './converters.js';\nimport {\n  GenerateContentCandidate,\n  GenerateContentResponse,\n  GenerateContentStreamResult,\n  Part,\n  isObject,\n} from './types.js';\n\n/**\n * Safely extracts the error message from the error.\n * @param e The error\n * @returns The error message\n */\nexport function extractErrMsg(e: unknown): string {\n  let errorMessage = 'An unknown error occurred';\n  if (e instanceof Error) {\n    errorMessage = e.message;\n  } else if (typeof e === 'string') {\n    errorMessage = e;\n  } else {\n    // Fallback for other types\n    try {\n      errorMessage = JSON.stringify(e);\n    } catch (stringifyError) {\n      errorMessage = 'Failed to stringify error object';\n    }\n  }\n  return errorMessage;\n}\n\n/**\n * Custom replacer function for JSON.stringify to truncate long string fields.\n * Truncates strings to the first 100 and last 10 characters\n * if the original string is longer than 110 characters.\n *\n * @param key The key of the property being stringified.\n * @param value The value of the property being stringified.\n * @return The transformed value, or the original value if no transformation is needed.\n */\nexport function stringTruncator(key: string, value: unknown): unknown {\n  const beginLength = 100;\n  const endLength = 10;\n  const totalLength = beginLength + endLength;\n  if (typeof value === 'string' && value.length > totalLength) {\n    const start = value.substring(0, 100);\n    const end = value.substring(value.length - 10);\n    return `${start}...[TRUNCATED]...${end}`;\n  }\n  return value; // Return the original value for other keys or non-string values\n}\n\n/**\n * Gets the un-prefixed model name from a modelReference\n */\nexport function extractVersion(\n  model: ModelReference<z.ZodTypeAny> | EmbedderReference<z.ZodTypeAny>\n): string {\n  return model.version ? model.version : checkModelName(model.name);\n}\n\n/**\n * Gets the model name without certain prefixes..\n * e.g. for \"models/googleai/gemini-2.5-pro\" it returns just 'gemini-2.5-pro'\n * @param name A string containing the model string with possible prefixes\n * @returns the model string stripped of certain prefixes\n */\nexport function modelName(name?: string): string | undefined {\n  if (!name) return name;\n\n  // Remove any of these prefixes:\n  const prefixesToRemove =\n    /background-model\\/|model\\/|models\\/|embedders\\/|googleai\\/|vertexai\\//g;\n  return name.replace(prefixesToRemove, '');\n}\n\n/**\n * Gets the suffix of a model string.\n * Throws if the string is empty.\n * @param name A string containing the model string\n * @returns the model string stripped of prefixes and guaranteed not empty.\n */\nexport function checkModelName(name?: string): string {\n  const version = modelName(name);\n  if (!version) {\n    throw new GenkitError({\n      status: 'INVALID_ARGUMENT',\n      message: 'Model name is required.',\n    });\n  }\n  return version;\n}\n\nexport function extractText(request: GenerateRequest) {\n  return (\n    request.messages\n      .at(-1)\n      ?.content.map((c) => c.text || '')\n      .join('') ?? ''\n  );\n}\n\nconst KNOWN_MIME_TYPES = {\n  jpg: 'image/jpeg',\n  jpeg: 'image/jpeg',\n  png: 'image/png',\n  mp4: 'video/mp4',\n  pdf: 'application/pdf',\n};\n\nexport function extractMimeType(url?: string): string {\n  if (!url) {\n    return '';\n  }\n\n  const dataPrefix = 'data:';\n  if (!url.startsWith(dataPrefix)) {\n    // Not a data url, try suffix\n    url.lastIndexOf('.');\n    const key = url.substring(url.lastIndexOf('.') + 1);\n    if (Object.keys(KNOWN_MIME_TYPES).includes(key)) {\n      return KNOWN_MIME_TYPES[key];\n    }\n    return '';\n  }\n\n  const commaIndex = url.indexOf(',');\n  if (commaIndex == -1) {\n    // Invalid - missing separator\n    return '';\n  }\n\n  // The part between 'data:' and the comma\n  let mimeType = url.substring(dataPrefix.length, commaIndex);\n  const base64Marker = ';base64';\n  if (mimeType.endsWith(base64Marker)) {\n    mimeType = mimeType.substring(0, mimeType.length - base64Marker.length);\n  }\n\n  return mimeType.trim();\n}\n\nexport function checkSupportedMimeType(\n  media: MediaPart['media'],\n  supportedTypes: string[]\n) {\n  if (!supportedTypes.includes(media.contentType ?? '')) {\n    throw new GenkitError({\n      status: 'INVALID_ARGUMENT',\n      message: `Invalid mimeType for ${displayUrl(media.url)}: \"${media.contentType}\". Supported mimeTypes: ${supportedTypes.join(', ')}`,\n    });\n  }\n}\n\n/**\n *\n * @param url The url to show (e.g. in an error message)\n * @returns The appropriately  sized url\n */\nexport function displayUrl(url: string): string {\n  if (url.length <= 50) {\n    return url;\n  }\n\n  return url.substring(0, 25) + '...' + url.substring(url.length - 25);\n}\n\nfunction isMediaPart(part: GenkitPart): part is MediaPart {\n  return (part as MediaPart).media !== undefined;\n}\n\n/**\n *\n * @param request A generate request to extract from\n * @param metadataType The media must have metadata matching this type if isDefault is false\n * @param isDefault 'true' allows missing metadata type to match as well.\n * @returns\n */\nexport function extractMedia(\n  request: GenerateRequest,\n  params: {\n    metadataType?: string;\n    /* Is there is no metadata type, it will match if isDefault is true */\n    isDefault?: boolean;\n  }\n): MediaPart['media'] | undefined {\n  const mediaArray = extractMediaArray(request, params);\n  if (mediaArray?.length) {\n    return mediaArray[0].media;\n  }\n\n  return undefined;\n}\n\n/**\n *\n * @param request A generate request to extract from\n * @param metadataType The media must have metadata matching this type if isDefault is false\n * @param isDefault 'true' allows missing metadata type to match as well.\n * @returns\n */\nexport function extractMediaArray(\n  request: GenerateRequest,\n  params: {\n    metadataType?: string;\n    /* If there is no metadata type, it will match if isDefault is true */\n    isDefault?: boolean;\n  }\n): MediaPart[] | undefined {\n  // MediaPart filter:  Keeps parts matching `params.metadataType`,\n  // or parts with no metadata type if `params.isDefault` is true.\n  // Keeps everything if no params are specified.\n  const matchesMediaParams = (part: MediaPart) => {\n    if (params.metadataType || params.isDefault) {\n      // We need to check the metadata type\n      const metadata = part.metadata;\n      if (!metadata?.type) {\n        return !!params.isDefault;\n      } else {\n        return metadata.type == params.metadataType;\n      }\n    }\n    return true;\n  };\n\n  const mediaArray = request.messages\n    .at(-1)\n    ?.content.filter(isMediaPart)\n    .filter(matchesMediaParams)\n    ?.map((mediaPart) => {\n      let media = mediaPart.media;\n      if (media && !media?.contentType) {\n        // Add the mimeType\n        media = {\n          url: media.url,\n          contentType: extractMimeType(media.url),\n        };\n      }\n\n      return {\n        media,\n        metadata: {\n          referenceType: mediaPart.metadata?.referenceType ?? 'asset',\n        },\n      };\n    });\n\n  if (mediaArray?.length) {\n    return mediaArray;\n  }\n\n  return undefined;\n}\n\n/**\n * Cleans a JSON schema by removing specific keys and standardizing types.\n *\n * @param {JSONSchema} schema The JSON schema to clean.\n * @returns {JSONSchema} The cleaned JSON schema.\n */\nexport function cleanSchema(schema: JSONSchema): JSONSchema {\n  const out = structuredClone(schema);\n  for (const key in out) {\n    if (key === '$schema' || key === 'additionalProperties') {\n      delete out[key];\n      continue;\n    }\n    if (typeof out[key] === 'object') {\n      out[key] = cleanSchema(out[key]);\n    }\n    // Zod nullish() and picoschema optional fields will produce type `[\"string\", \"null\"]`\n    // which is not supported by the model API. Convert them to just `\"string\"`.\n    if (key === 'type' && Array.isArray(out[key])) {\n      // find the first that's not `null`.\n      out[key] = out[key].find((t) => t !== 'null');\n    }\n  }\n  return out;\n}\n\n/**\n * Processes the streaming body of a Response object. It decodes the stream as\n * UTF-8 text, parses JSON objects from specially formatted lines (e.g., \"data: {}\"),\n * and returns both an async generator for individual responses and a promise\n * that resolves to the aggregated final response.\n *\n * @param response The Response object with a streaming body.\n * @returns An object containing:\n *  - stream: An AsyncGenerator yielding each GenerateContentResponse.\n *  - response: A Promise resolving to the aggregated GenerateContentResponse.\n */\nexport function processStream(response: Response): GenerateContentStreamResult {\n  if (!response.body) {\n    throw new Error('Error processing stream because response.body not found');\n  }\n  const inputStream = response.body.pipeThrough(\n    new TextDecoderStream('utf8', { fatal: true })\n  );\n  const responseStream = getResponseStream(inputStream);\n  const [stream1, stream2] = responseStream.tee();\n  return {\n    stream: generateResponseSequence(stream1),\n    response: getResponsePromise(stream2),\n  };\n}\n\nfunction getResponseStream(\n  inputStream: ReadableStream<string>\n): ReadableStream<GenerateContentResponse> {\n  const responseLineRE = /^data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n  const reader = inputStream.getReader();\n  const stream = new ReadableStream<GenerateContentResponse>({\n    start(controller) {\n      let currentText = '';\n      return pump();\n      function pump(): Promise<(() => Promise<void>) | undefined> {\n        return reader\n          .read()\n          .then(({ value, done }) => {\n            if (done) {\n              if (currentText.trim()) {\n                controller.error(new Error('Failed to parse stream'));\n                return;\n              }\n              controller.close();\n              return;\n            }\n\n            currentText += value;\n            let match = currentText.match(responseLineRE);\n            let parsedResponse: GenerateContentResponse;\n            while (match) {\n              try {\n                parsedResponse = JSON.parse(match[1]);\n              } catch (e) {\n                controller.error(\n                  new Error(`Error parsing JSON response: \"${match[1]}\"`)\n                );\n                return;\n              }\n              controller.enqueue(parsedResponse);\n              currentText = currentText.substring(match[0].length);\n              match = currentText.match(responseLineRE);\n            }\n            return pump();\n          })\n          .catch((e: Error) => {\n            let err = e;\n            err.stack = e.stack;\n            if (err.name === 'AbortError') {\n              err = new GenkitError({\n                status: 'ABORTED',\n                message: 'Request aborted when reading from the stream',\n              });\n            } else {\n              err = new Error('Error reading from the stream');\n            }\n            throw err;\n          });\n      }\n    },\n  });\n  return stream;\n}\n\nasync function* generateResponseSequence(\n  stream: ReadableStream<GenerateContentResponse>\n): AsyncGenerator<GenerateContentResponse> {\n  const reader = stream.getReader();\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    yield value;\n  }\n}\n\nasync function getResponsePromise(\n  stream: ReadableStream<GenerateContentResponse>\n): Promise<GenerateContentResponse> {\n  const allResponses: GenerateContentResponse[] = [];\n  const reader = stream.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      return aggregateResponses(allResponses);\n    }\n    allResponses.push(value);\n  }\n}\n\nfunction handleFunctionCall(\n  part: Part,\n  newPart: Partial<Part>,\n  activePartialToolRequest: Part | null\n): {\n  shouldContinue: boolean;\n  newActivePartialToolRequest: Part | null;\n} {\n  // If there's an active partial tool request, we're in the middle of a stream.\n  if (activePartialToolRequest) {\n    if (part.functionCall?.partialArgs) {\n      applyGeminiPartialArgs(\n        activePartialToolRequest.functionCall!.args!,\n        part.functionCall.partialArgs\n      );\n    }\n    // If `willContinue` is false, this is the end of the stream.\n    if (!part.functionCall!.willContinue) {\n      newPart.thoughtSignature = activePartialToolRequest.thoughtSignature;\n      part.functionCall = activePartialToolRequest.functionCall;\n      delete part.functionCall!.willContinue;\n      activePartialToolRequest = null;\n    } else {\n      // If `willContinue` is true, we're still in the middle of a stream.\n      // This is a partial result, so we skip adding it to the parts list.\n      return {\n        shouldContinue: true,\n        newActivePartialToolRequest: activePartialToolRequest,\n      };\n    }\n    // If `willContinue` is true on a part and there's no active partial request,\n    // this is the start of a new streaming tool call.\n  } else if (part.functionCall!.willContinue) {\n    activePartialToolRequest = {\n      ...part,\n      functionCall: {\n        ...part.functionCall,\n        args: part.functionCall!.args || {},\n      },\n    };\n    if (part.functionCall?.partialArgs) {\n      applyGeminiPartialArgs(\n        activePartialToolRequest.functionCall!.args!,\n        part.functionCall.partialArgs\n      );\n    }\n    // This is the start of a partial, so we skip adding it to the parts list.\n    return {\n      shouldContinue: true,\n      newActivePartialToolRequest: activePartialToolRequest,\n    };\n  }\n\n  // If we're here, it's a regular, non-streaming tool call.\n  newPart.functionCall = part.functionCall;\n  return {\n    shouldContinue: false,\n    newActivePartialToolRequest: activePartialToolRequest,\n  };\n}\n\nfunction aggregateResponses(\n  responses: GenerateContentResponse[]\n): GenerateContentResponse {\n  const lastResponse = responses.at(-1);\n  if (lastResponse === undefined) {\n    throw new Error(\n      'Error aggregating stream chunks because the final response in stream chunk is undefined'\n    );\n  }\n  const aggregatedResponse: GenerateContentResponse = {};\n  if (lastResponse.promptFeedback) {\n    aggregatedResponse.promptFeedback = lastResponse.promptFeedback;\n  }\n  let activePartialToolRequest: Part | null = null;\n  for (const response of responses) {\n    for (const candidate of response.candidates ?? []) {\n      const index = candidate.index ?? 0;\n      if (!aggregatedResponse.candidates) {\n        aggregatedResponse.candidates = [];\n      }\n      if (!aggregatedResponse.candidates[index]) {\n        aggregatedResponse.candidates[index] = {\n          index,\n        } as GenerateContentCandidate;\n      }\n      const aggregatedCandidate = aggregatedResponse.candidates[index];\n      aggregateMetadata(aggregatedCandidate, candidate, 'citationMetadata');\n      aggregateMetadata(aggregatedCandidate, candidate, 'groundingMetadata');\n      if (candidate.safetyRatings?.length) {\n        aggregatedCandidate.safetyRatings = (\n          aggregatedCandidate.safetyRatings ?? []\n        ).concat(candidate.safetyRatings);\n      }\n      if (candidate.finishReason !== undefined) {\n        aggregatedCandidate.finishReason = candidate.finishReason;\n      }\n      if (candidate.finishMessage !== undefined) {\n        aggregatedCandidate.finishMessage = candidate.finishMessage;\n      }\n\n      if (candidate.avgLogprobs !== undefined) {\n        aggregatedCandidate.avgLogprobs = candidate.avgLogprobs;\n      }\n      if (candidate.logprobsResult !== undefined) {\n        aggregatedCandidate.logprobsResult = candidate.logprobsResult;\n      }\n\n      /**\n       * Candidates should always have content and parts, but this handles\n       * possible malformed responses.\n       */\n      if (candidate.content && candidate.content.parts) {\n        if (!aggregatedCandidate.content) {\n          aggregatedCandidate.content = {\n            role: candidate.content.role || 'user',\n            parts: [],\n          };\n        }\n\n        for (const part of candidate.content.parts) {\n          const newPart: Partial<Part> = {};\n          if (part.thought) {\n            newPart.thought = part.thought;\n          }\n          if (part.thoughtSignature) {\n            newPart.thoughtSignature = part.thoughtSignature;\n          }\n          if (typeof part.text === 'string') {\n            newPart.text = part.text;\n          }\n          if (part.functionCall) {\n            // function calls are special, there can be partials, so we need aggregate\n            // the partials into final functionCall.\n            const { shouldContinue, newActivePartialToolRequest } =\n              handleFunctionCall(part, newPart, activePartialToolRequest);\n            if (shouldContinue) {\n              activePartialToolRequest = newActivePartialToolRequest;\n              continue;\n            }\n            activePartialToolRequest = newActivePartialToolRequest;\n          }\n          if (part.executableCode) {\n            newPart.executableCode = part.executableCode;\n          }\n          if (part.codeExecutionResult) {\n            newPart.codeExecutionResult = part.codeExecutionResult;\n          }\n          if (part.inlineData) {\n            newPart.inlineData = part.inlineData;\n          }\n          if (Object.keys(newPart).length === 0) {\n            newPart.text = '';\n          }\n          aggregatedCandidate.content.parts.push(newPart as Part);\n        }\n      }\n    }\n    if (response.usageMetadata) {\n      aggregatedResponse.usageMetadata = response.usageMetadata;\n    }\n  }\n  return aggregatedResponse;\n}\n\nfunction aggregateMetadata<K extends keyof GenerateContentCandidate>(\n  aggCandidate: GenerateContentCandidate,\n  chunkCandidate: GenerateContentCandidate,\n  fieldName: K\n) {\n  const chunkObj = chunkCandidate[fieldName];\n  const aggObj = aggCandidate[fieldName];\n  if (chunkObj === undefined) return; // Nothing to do\n\n  if (aggObj === undefined) {\n    aggCandidate[fieldName] = chunkObj;\n    return;\n  }\n\n  if (isObject(chunkObj)) {\n    for (const k of Object.keys(chunkObj)) {\n      if (Array.isArray(aggObj[k]) && Array.isArray(chunkObj[k])) {\n        aggObj[k] = aggObj[k].concat(chunkObj[k]);\n      } else {\n        // last one wins, also handles only one being an array.\n        aggObj[k] = chunkObj[k] ?? aggObj[k];\n      }\n    }\n  }\n}\n\nexport function getGenkitClientHeader() {\n  if (process.env.MONOSPACE_ENV == 'true') {\n    return defaultGetClientHeader() + ' firebase-studio-vm';\n  }\n  return defaultGetClientHeader();\n}\n\nexport const TEST_ONLY = { aggregateResponses };\n"],"names":["defaultGetClientHeader"],"mappings":"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"}},
    {"offset": {"line": 1210, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/googleai/client.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenkitError, StatusName } from 'genkit';\nimport { logger } from 'genkit/logging';\nimport {\n  extractErrMsg,\n  getGenkitClientHeader,\n  processStream,\n} from '../common/utils.js';\nimport {\n  ClientOptions,\n  EmbedContentRequest,\n  EmbedContentResponse,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GenerateContentStreamResult,\n  ImagenPredictRequest,\n  ImagenPredictResponse,\n  ListModelsResponse,\n  Model,\n  VeoOperation,\n  VeoPredictRequest,\n} from './types.js';\n\n/**\n * Lists available models.\n *\n * https://ai.google.dev/api/models#method:-models.list\n *\n * @param apiKey The API key to authenticate the request.\n * @param clientOptions Optional options to customize the request\n * @returns A promise that resolves to an array of Model objects.\n */\nexport async function listModels(\n  apiKey: string | undefined,\n  clientOptions?: ClientOptions\n): Promise<Model[]> {\n  const url = getGoogleAIUrl({\n    resourcePath: 'models',\n    queryParams: 'pageSize=1000',\n    clientOptions,\n  });\n  const fetchOptions = getFetchOptions({\n    method: 'GET',\n    apiKey,\n    clientOptions,\n  });\n  const response = await makeRequest(url, fetchOptions);\n  const modelResponse = JSON.parse(await response.text()) as ListModelsResponse;\n  return modelResponse.models;\n}\n\n/**\n * Generates content using the Google AI API.\n *\n * @param {string} apiKey The API key for authentication.\n * @param {string} model The name of the model to use for content generation.\n * @param {GenerateContentRequest} generateContentRequest The request object containing the content generation parameters.\n * @param {ClientOptions} [clientOptions] Optional client options.\n * @returns {Promise<GenerateContentResponse>} A promise that resolves to the content generation response.\n * @throws {Error} If the API request fails or the response cannot be parsed.\n */\nexport async function generateContent(\n  apiKey: string | undefined,\n  model: string,\n  generateContentRequest: GenerateContentRequest,\n  clientOptions?: ClientOptions\n): Promise<GenerateContentResponse> {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: 'generateContent',\n    clientOptions,\n  });\n  const fetchOptions = getFetchOptions({\n    method: 'POST',\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(generateContentRequest),\n  });\n  const response = await makeRequest(url, fetchOptions);\n\n  const responseJson = (await response.json()) as GenerateContentResponse;\n  return responseJson;\n}\n\n/**\n * Generates a stream of content using the Google AI API.\n *\n * @param {string} apiKey The API key for authentication.\n * @param {string} model The name of the model to use for content generation.\n * @param {GenerateContentRequest} generateContentRequest The request object containing the content generation parameters.\n * @param {ClientOptions} [clientOptions] Optional client options.\n * @returns {Promise<GenerateContentStreamResult>} A promise that resolves to an object containing a both the stream and aggregated response.\n * @throws {Error} If the API request fails.\n */\nexport async function generateContentStream(\n  apiKey: string | undefined,\n  model: string,\n  generateContentRequest: GenerateContentRequest,\n  clientOptions?: ClientOptions\n): Promise<GenerateContentStreamResult> {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: 'streamGenerateContent',\n    clientOptions,\n  });\n  const fetchOptions = getFetchOptions({\n    method: 'POST',\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(generateContentRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return processStream(response);\n}\n\n/**\n * Embeds content using the Google AI API.\n *\n * @param {string} apiKey The API key for authentication.\n * @param {string} model The name of the model to use for content embedding.\n * @param {EmbedContentRequest} embedContentRequest The request object containing the content to embed.\n * @param {ClientOptions} [clientOptions] Optional client options.\n * @returns {Promise<EmbedContentResponse>} A promise that resolves to the embedding response.\n * @throws {Error} If the API request fails or the response cannot be parsed.\n */\nexport async function embedContent(\n  apiKey: string | undefined,\n  model: string,\n  embedContentRequest: EmbedContentRequest,\n  clientOptions?: ClientOptions\n): Promise<EmbedContentResponse> {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: 'embedContent',\n    clientOptions,\n  });\n  const fetchOptions = getFetchOptions({\n    method: 'POST',\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(embedContentRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return response.json();\n}\n\nexport async function imagenPredict(\n  apiKey: string | undefined,\n  model: string,\n  imagenPredictRequest: ImagenPredictRequest,\n  clientOptions?: ClientOptions\n): Promise<ImagenPredictResponse> {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: 'predict',\n    clientOptions,\n  });\n\n  const fetchOptions = getFetchOptions({\n    method: 'POST',\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(imagenPredictRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return response.json() as Promise<ImagenPredictResponse>;\n}\n\nexport async function veoPredict(\n  apiKey: string | undefined,\n  model: string,\n  veoPredictRequest: VeoPredictRequest,\n  clientOptions?: ClientOptions\n): Promise<VeoOperation> {\n  const url = getGoogleAIUrl({\n    resourcePath: `models/${model}`,\n    resourceMethod: 'predictLongRunning',\n    clientOptions,\n  });\n\n  const fetchOptions = getFetchOptions({\n    method: 'POST',\n    apiKey,\n    clientOptions,\n    body: JSON.stringify(veoPredictRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return response.json() as Promise<VeoOperation>;\n}\n\nexport async function veoCheckOperation(\n  apiKey: string | undefined,\n  operation: string,\n  clientOptions?: ClientOptions\n): Promise<VeoOperation> {\n  const url = getGoogleAIUrl({\n    resourcePath: operation,\n    clientOptions,\n  });\n  const fetchOptions = getFetchOptions({\n    method: 'GET',\n    apiKey,\n    clientOptions,\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  return response.json() as Promise<VeoOperation>;\n}\n\n/**\n * Generates a Google AI URL.\n *\n * @param params - An object containing the parameters for the URL.\n * @param params.path - The path for the URL (the part after the version)\n * @param params.task - An optional task\n * @param params.queryParams - An optional string of '&' delimited query parameters.\n * @param params.clientOptions - An optional object containing client options.\n * @returns The generated Google AI URL.\n */\nexport function getGoogleAIUrl(params: {\n  resourcePath: string;\n  resourceMethod?: string;\n  queryParams?: string;\n  clientOptions?: ClientOptions;\n}): string {\n  // v1beta is the default because all the new experimental models\n  // are found here but not in v1.\n  const DEFAULT_API_VERSION = 'v1beta';\n  const DEFAULT_BASE_URL = 'https://generativelanguage.googleapis.com';\n\n  const apiVersion = params.clientOptions?.apiVersion || DEFAULT_API_VERSION;\n  const baseUrl = params.clientOptions?.baseUrl || DEFAULT_BASE_URL;\n\n  let url = `${baseUrl}/${apiVersion}/${params.resourcePath}`;\n  if (params.resourceMethod) {\n    url += `:${params.resourceMethod}`;\n  }\n  if (params.queryParams) {\n    url += `?${params.queryParams}`;\n  }\n  if (params.resourceMethod === 'streamGenerateContent') {\n    url += `${params.queryParams ? '&' : '?'}alt=sse`;\n  }\n  return url;\n}\n\nfunction getFetchOptions(params: {\n  method: 'POST' | 'GET';\n  apiKey: string | undefined;\n  body?: string;\n  clientOptions?: ClientOptions;\n}) {\n  const fetchOptions: RequestInit = {\n    method: params.method,\n    headers: getHeaders(params.apiKey, params.clientOptions),\n  };\n  if (params.body) {\n    fetchOptions.body = params.body;\n  }\n  const signal = getAbortSignal(params.clientOptions);\n  if (signal) {\n    fetchOptions.signal = signal;\n  }\n  return fetchOptions;\n}\n\nfunction getAbortSignal(\n  clientOptions?: ClientOptions\n): AbortSignal | undefined {\n  const hasTimeout = (clientOptions?.timeout ?? -1) >= 0;\n  if (clientOptions?.signal !== undefined || hasTimeout) {\n    const controller = new AbortController();\n    if (hasTimeout) {\n      setTimeout(() => controller.abort(), clientOptions?.timeout);\n    }\n    if (clientOptions?.signal) {\n      clientOptions.signal.addEventListener('abort', () => {\n        controller.abort();\n      });\n    }\n    return controller.signal;\n  }\n  return undefined;\n}\n\n/**\n * Constructs the headers for an API request.\n *\n * @param {string} apiKey The API key for authentication.\n * @param {ClientOptions} [clientOptions] Optional client options, containing custom headers.\n * @returns {HeadersInit} An object containing the headers to be included in the request.\n */\nfunction getHeaders(\n  apiKey?: string,\n  clientOptions?: ClientOptions\n): HeadersInit {\n  let customHeaders = {};\n  if (clientOptions?.customHeaders) {\n    customHeaders = structuredClone(clientOptions.customHeaders);\n    delete customHeaders['x-goog-api-key']; // Not allowed in user settings\n    delete customHeaders['x-goog-api-client']; // Not allowed in user settings\n  }\n  const headers: HeadersInit = {\n    ...customHeaders,\n    'Content-Type': 'application/json',\n    'x-goog-api-client': getGenkitClientHeader(),\n  };\n\n  if (apiKey) {\n    headers['x-goog-api-key'] = apiKey;\n  }\n\n  return headers;\n}\n\n/**\n * Makes a request to the specified URL with the provided options.\n *\n * @param {string} url The URL to make the request to.\n * @param {RequestInit} fetchOptions The options to pass to the `fetch` API.\n * @returns {Promise<Response>} A promise that resolves to the Response\n * @throws {Error} If the request fails\n */\nasync function makeRequest(\n  url: string,\n  fetchOptions: RequestInit\n): Promise<Response> {\n  try {\n    const response = await fetch(url, fetchOptions);\n    if (!response.ok) {\n      let errorText = await response.text();\n      let errorMessage = errorText;\n      try {\n        const json = JSON.parse(errorText);\n        if (json.error && json.error.message) {\n          errorMessage = json.error.message;\n        }\n      } catch (e) {\n        // Not JSON or expected format, use the raw text\n      }\n      let status: StatusName = 'UNKNOWN';\n      switch (response.status) {\n        case 429:\n          status = 'RESOURCE_EXHAUSTED';\n          break;\n        case 400:\n          status = 'INVALID_ARGUMENT';\n          break;\n        case 500:\n          status = 'INTERNAL';\n          break;\n        case 503:\n          status = 'UNAVAILABLE';\n          break;\n      }\n      throw new GenkitError({\n        status,\n        message: `Error fetching from ${url}: [${response.status} ${response.statusText}] ${errorMessage}`,\n      });\n    }\n    return response;\n  } catch (e: unknown) {\n    logger.error(e);\n    if (e instanceof GenkitError) {\n      throw e;\n    }\n    throw new Error(`Failed to fetch from ${url}: ${extractErrMsg(e)}`);\n  }\n}\n\nexport const TEST_ONLY = {\n  getFetchOptions,\n  getAbortSignal,\n  getHeaders,\n  makeRequest,\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1479, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/googleai/utils.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenerateRequest, GenkitError, z } from 'genkit';\nimport process from 'process';\nimport { extractMedia } from '../common/utils.js';\nimport { ClientOptions, ImagenInstance, VeoImage, VeoVideo } from './types.js';\n\nexport {\n  checkModelName,\n  cleanSchema,\n  extractText,\n  extractVersion,\n  modelName,\n} from '../common/utils.js';\n\n/**\n * Retrieves an API key from environment variables.\n *\n * @returns The API key as a string, or `undefined` if none of the specified\n *          environment variables are set.\n */\nexport function getApiKeyFromEnvVar(): string | undefined {\n  return (\n    process.env.GEMINI_API_KEY ||\n    process.env.GOOGLE_API_KEY ||\n    process.env.GOOGLE_GENAI_API_KEY\n  );\n}\n\nexport const MISSING_API_KEY_ERROR = new GenkitError({\n  status: 'FAILED_PRECONDITION',\n  message:\n    'Please pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\\n' +\n    'For more details see https://genkit.dev/docs/plugins/google-genai/',\n});\n\nexport const API_KEY_FALSE_ERROR = new GenkitError({\n  status: 'INVALID_ARGUMENT',\n  message:\n    'GoogleAI plugin was initialized with {apiKey: false} but no apiKey configuration was passed at call time.',\n});\n\n/**\n * Checks and retrieves an API key based on the provided argument and environment variables.\n *\n * - If `pluginApiKey` is a non-empty string, it's used as the API key.\n * - If `pluginApiKey` is `undefined` or an empty string, it attempts to fetch the API key from environment\n * - If `pluginApiKey` is `false`, key retrieval from the environment is skipped, and the function\n *   will return `undefined`. This mode indicates that the API key is expected to be provided\n *   at a later stage or in a different context.\n *\n * @param pluginApiKey - An optional API key string, `undefined` to check the environment, or `false` to bypass all checks in this function.\n * @returns The resolved API key as a string, or `undefined` if `pluginApiKey` is `false`.\n * @throws {Error} MISSING_API_KEY_ERROR - Thrown if `pluginApiKey` is not `false` and no API key\n *   can be found either in the `pluginApiKey` argument or from the environment.\n */\nexport function checkApiKey(\n  pluginApiKey: string | false | undefined\n): string | undefined {\n  let apiKey: string | undefined;\n\n  // Don't get the key from the environment if pluginApiKey is false\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n\n  // If pluginApiKey is false, then we don't throw because we are waiting for\n  // the apiKey passed into the individual call\n  if (pluginApiKey !== false && !apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\n\n/**\n * Calculates and returns the effective API key based on multiple potential sources.\n * The order of precedence for determining the API key is:\n * 1. `requestApiKey` (if provided)\n * 2. `pluginApiKey` (if provided and not `false`)\n * 3. Environment variable (if `pluginApiKey` is not `false` and `pluginApiKey` is not provided)\n *\n * @param pluginApiKey - The apiKey value provided during plugin initialization.\n * @param requestApiKey - The apiKey provided to an individual generate call.\n * @returns The resolved API key as a string.\n * @throws {Error} API_KEY_FALSE_ERROR - Thrown if `pluginApiKey` is `false` and `requestApiKey` is not provided\n * @throws {Error} MISSING_API_KEY_ERROR - Thrown if no API key can be resolved from any source\n */\nexport function calculateApiKey(\n  pluginApiKey: string | false | undefined,\n  requestApiKey: string | undefined\n): string | undefined {\n  let apiKey: string | undefined;\n\n  // Don't get the key from the environment if pluginApiKey is false\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n\n  apiKey = requestApiKey || apiKey;\n\n  if (pluginApiKey === false && !requestApiKey) {\n    return undefined;\n  }\n\n  if (!apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\n\nexport function extractVeoImage(\n  request: GenerateRequest\n): VeoImage | undefined {\n  const media = request.messages.at(-1)?.content.find((p) => !!p.media)?.media;\n  if (!media?.contentType?.startsWith('image/')) {\n    return undefined;\n  }\n  const bytes = media?.url.split(',')[1];\n  if (bytes) {\n    return {\n      bytesBase64Encoded: bytes,\n      mimeType: media.contentType,\n    };\n  }\n  return undefined;\n}\n\nexport function extractVeoVideo(\n  request: GenerateRequest\n): VeoVideo | undefined {\n  const media = request.messages.at(-1)?.content.find((p) => !!p.media)?.media;\n  if (!media?.contentType?.startsWith('video/')) {\n    return undefined;\n  }\n  return {\n    uri: media.url,\n  };\n}\n\nexport function extractImagenImage(\n  request: GenerateRequest\n): ImagenInstance['image'] | undefined {\n  const image = extractMedia(request, {\n    metadataType: 'base',\n    isDefault: true,\n  })?.url.split(',')[1];\n\n  if (image) {\n    return { bytesBase64Encoded: image };\n  }\n  return undefined;\n}\n\n/**\n * For each field in ClientOptions, if the request config object has\n * a matching non-empty/non-null field, it overrides the original.\n */\nexport function calculateRequestOptions<T extends z.ZodObject<any, any, any>>(\n  clientOptions: ClientOptions,\n  reqConfig?: z.infer<T>\n): ClientOptions {\n  if (!reqConfig) {\n    return clientOptions;\n  }\n\n  let newOptions = { ...clientOptions };\n\n  if (typeof reqConfig.timeout == 'number') {\n    newOptions.timeout = reqConfig.timeout;\n  }\n\n  if (typeof reqConfig.apiKey == 'string') {\n    newOptions.apiKey = reqConfig.apiKey;\n  }\n\n  if (typeof reqConfig.apiVersion == 'string') {\n    newOptions.apiVersion = reqConfig.apiVersion;\n  }\n\n  if (typeof reqConfig.apiClient == 'string') {\n    newOptions.apiClient = reqConfig.apiClient;\n  }\n\n  if (typeof reqConfig.baseUrl == 'string') {\n    newOptions.baseUrl = reqConfig.baseUrl;\n  }\n\n  if (reqConfig.customHeaders && typeof reqConfig.customHeaders === 'object') {\n    newOptions.customHeaders = reqConfig.customHeaders;\n  }\n\n  return newOptions;\n}\n\n/**\n * The config can have client option overrides, but they should not\n * be sent with the request like normal config.\n * @param requestConfig\n */\nexport function removeClientOptionOverrides<\n  T extends z.ZodObject<any, any, any>,\n>(requestConfig?: z.infer<T>): z.infer<T> {\n  let newConfig = { ...requestConfig };\n\n  delete newConfig?.timeout;\n  delete newConfig?.apiKey;\n  delete newConfig?.apiVersion;\n  delete newConfig?.apiClient;\n  delete newConfig?.baseUrl;\n  delete newConfig?.customHeaders;\n\n  return newConfig;\n}\n"],"names":["import_utils","process"],"mappings":"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"}},
    {"offset": {"line": 1665, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/googleai/types.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Content,\n  FinishReason,\n  GenerateContentCandidate,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GenerateContentStreamResult,\n  GenerationConfig,\n  GoogleSearchRetrievalTool,\n  HarmBlockThreshold,\n  HarmCategory,\n  ImagenInstance,\n  ImagenParameters,\n  ImagenPredictRequest,\n  ImagenPredictResponse,\n  ImagenPrediction,\n  Part,\n  SafetySetting,\n  TaskType,\n  TaskTypeSchema,\n  Tool,\n  ToolConfig,\n  UrlContextTool,\n} from '../common/types.js';\n\n// This makes it easier to import all types from one place.\nexport {\n  FinishReason,\n  HarmBlockThreshold,\n  HarmCategory,\n  TaskTypeSchema,\n  type Content,\n  type GenerateContentCandidate,\n  type GenerateContentRequest,\n  type GenerateContentResponse,\n  type GenerateContentStreamResult,\n  type GenerationConfig,\n  type GoogleSearchRetrievalTool,\n  type ImagenInstance,\n  type ImagenParameters,\n  type ImagenPredictRequest,\n  type ImagenPredictResponse,\n  type ImagenPrediction,\n  type Part,\n  type SafetySetting,\n  type Tool,\n  type ToolConfig,\n  type UrlContextTool,\n};\n\nexport interface GoogleAIPluginOptions {\n  /**\n   * Provide the API key to use to authenticate with the Gemini API. By\n   * default, an API key must be provided explicitly here or through the\n   * `GEMINI_API_KEY` or `GOOGLE_API_KEY` environment variables.\n   *\n   * If `false` is explicitly passed, the plugin will be configured to\n   * expect an `apiKey` option to be provided to the model config at\n   * call time.\n   **/\n  apiKey?: string | false;\n  apiVersion?: string;\n  baseUrl?: string;\n  experimental_debugTraces?: boolean;\n  /** Use `responseSchema` field instead of `responseJsonSchema`. */\n  legacyResponseSchema?: boolean;\n  /**\n   * Additional headers to send along with the request.\n   */\n  customHeaders?: Record<string, string>;\n}\n\n/**\n * Options passed to the client\n * @public\n */\nexport interface ClientOptions {\n  /**\n   * An object that may be used to abort asynchronous requests. The request may\n   * also be aborted due to the expiration of the timeout value, if provided.\n   *\n   * NOTE: AbortSignal is a client-only operation. Using it to cancel an\n   * operation will not cancel the request in the service. You will still\n   * be charged usage for any applicable operations.\n   */\n  signal?: AbortSignal;\n  /**\n   * Request timeout in milliseconds.\n   */\n  timeout?: number;\n  /**\n   * Api Key for Gemini API\n   */\n  apiKey?: string;\n  /**\n   * Version of API endpoint to call (e.g. \"v1\" or \"v1beta\"). If not specified,\n   * defaults to 'v1beta'.\n   */\n  apiVersion?: string;\n  /**\n   * Additional attribution information to include in the x-goog-api-client header.\n   * Used by wrapper SDKs.\n   */\n  apiClient?: string;\n  /**\n   * Base endpoint url. Defaults to \"https://generativelanguage.googleapis.com\"\n   */\n  baseUrl?: string;\n  /**\n   * Custom HTTP request headers.\n   */\n  customHeaders?: Headers | Record<string, string>;\n}\n\n/**\n * Params for calling embedContent\n * @public\n */\nexport interface EmbedContentRequest {\n  content: Content;\n  taskType?: TaskType;\n  title?: string;\n}\n\n/**\n * Gemini model object\n * @public\n */\nexport interface Model {\n  name: string;\n  baseModelId: string;\n  version: string;\n  displayName: string;\n  description: string;\n  inputTokenLimit: number;\n  outputTokenLimit: number;\n  supportedGenerationMethods: string[];\n  temperature: number;\n  maxTemperature: number;\n  topP: number;\n  topK: number;\n}\n\n/**\n * Response from calling listModels\n * @public\n */\nexport interface ListModelsResponse {\n  models: Model[];\n  nextPageToken?: string;\n}\n\n/**\n * Response from calling embedContent\n * @public\n */\nexport interface EmbedContentResponse {\n  embedding: ContentEmbedding;\n}\n\n/**\n * A single content embedding.\n * @public\n */\nexport interface ContentEmbedding {\n  values: number[];\n}\n\nexport declare interface VeoPredictRequest {\n  instances: VeoInstance[];\n  parameters: VeoParameters;\n}\n\nexport declare interface VeoParameters {\n  negativePrompt?: string;\n  aspectRatio?: string;\n  personGeneration?: string;\n  durationSeconds?: number;\n  enhancePrompt?: boolean;\n}\n\nexport declare interface VeoInstance {\n  prompt: string;\n  image?: VeoImage;\n  video?: VeoVideo;\n}\n\nexport declare interface VeoImage {\n  bytesBase64Encoded: string;\n  mimeType: string;\n}\n\nexport declare interface VeoVideo {\n  uri: string;\n}\n\nexport declare interface VeoOperation {\n  name: string;\n  done?: boolean;\n  error?: {\n    message: string;\n  };\n  response?: {\n    generateVideoResponse: {\n      generatedSamples: { video: { uri: string } }[];\n    };\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,gBAAA,CAAA;AAAA,SAAA,eAAA;IAAA,cAAA,IAAA,aAAA,YAAA;IAAA,oBAAA,IAAA,aAAA,kBAAA;IAAA,cAAA,IAAA,aAAA,YAAA;IAAA,gBAAA,IAAA,aAAA,cAAA;AAAA;AAAA,OAAA,OAAA,GAAA,aAAA;AAgBA,IAAA,eAuBO"}},
    {"offset": {"line": 1707, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/googleai/embedder.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  EmbedderAction,\n  embedderActionMetadata,\n  EmbedderInfo,\n  EmbedderReference,\n  z,\n} from 'genkit';\nimport { embedderRef } from 'genkit/embedder';\nimport { embedder as pluginEmbedder } from 'genkit/plugin';\nimport { embedContent } from './client.js';\nimport {\n  ClientOptions,\n  EmbedContentRequest,\n  GoogleAIPluginOptions,\n  Model,\n  TaskTypeSchema,\n} from './types.js';\nimport {\n  calculateApiKey,\n  checkApiKey,\n  checkModelName,\n  extractVersion,\n} from './utils.js';\n\nexport const EmbeddingConfigSchema = z\n  .object({\n    /** Override the API key provided at plugin initialization. */\n    apiKey: z.string().optional(),\n    /**\n     * The `task_type` parameter is defined as the intended downstream application to help the model\n     * produce better quality embeddings.\n     **/\n    taskType: TaskTypeSchema.optional(),\n    title: z.string().optional(),\n    version: z.string().optional(),\n    /**\n     * The `outputDimensionality` parameter allows you to specify the dimensionality of the embedding output.\n     * By default, the model generates embeddings with 768 dimensions. Models such as\n     * `text-embedding-004`, `text-embedding-005`, and `text-multilingual-embedding-002`\n     * allow the output dimensionality to be adjusted between 1 and 768.\n     * By selecting a smaller output dimensionality, users can save memory and storage space, leading to more efficient computations.\n     **/\n    outputDimensionality: z.number().min(1).optional(),\n  })\n  .passthrough();\nexport type EmbeddingConfigSchemaType = typeof EmbeddingConfigSchema;\nexport type EmbeddingConfig = z.infer<EmbeddingConfigSchemaType>;\n\n// This contains all the embedder config schema types\ntype ConfigSchemaType = EmbeddingConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: EmbedderInfo,\n  configSchema: ConfigSchemaType = EmbeddingConfigSchema\n): EmbedderReference<ConfigSchemaType> {\n  return embedderRef({\n    name: `googleai/${name}`,\n    configSchema,\n    info: info ?? {\n      dimensions: 768,\n      supports: {\n        input: ['text'],\n      },\n    },\n  });\n}\n\nconst GENERIC_MODEL = commonRef('embedder');\n\nconst KNOWN_MODELS = {\n  'text-embedding-004': commonRef('text-embedding-004'),\n  'gemini-embedding-001': commonRef('gemini-embedding-001'),\n};\nexport type KnownModels = keyof typeof KNOWN_MODELS; // For autocomplete\n\nexport function model(\n  version: string,\n  config: EmbeddingConfig = {}\n): EmbedderReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  return embedderRef({\n    name: `googleai/${name}`,\n    config,\n    configSchema: GENERIC_MODEL.configSchema,\n    info: {\n      ...GENERIC_MODEL.info,\n    },\n  });\n}\n\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return (\n    models\n      .filter((m) => m.supportedGenerationMethods.includes('embedContent'))\n      // Filter out deprecated\n      .filter((m) => !m.description || !m.description.includes('deprecated'))\n      .map((m) => {\n        const ref = model(m.name);\n        return embedderActionMetadata({\n          name: ref.name,\n          info: ref.info,\n          configSchema: ref.configSchema,\n        });\n      })\n  );\n}\n\nexport function listKnownModels(options?: GoogleAIPluginOptions) {\n  return Object.keys(KNOWN_MODELS).map((name) => defineEmbedder(name, options));\n}\n\nexport function defineEmbedder(\n  name: string,\n  pluginOptions?: GoogleAIPluginOptions\n): EmbedderAction {\n  checkApiKey(pluginOptions?.apiKey);\n  const ref = model(name);\n  const clientOptions: ClientOptions = {\n    apiVersion: pluginOptions?.apiVersion,\n    baseUrl: pluginOptions?.baseUrl,\n    customHeaders: pluginOptions?.customHeaders,\n  };\n\n  return pluginEmbedder(\n    {\n      name: ref.name,\n      configSchema: ref.configSchema,\n      info: ref.info,\n    },\n    async (request, _) => {\n      const embedApiKey = calculateApiKey(\n        pluginOptions?.apiKey,\n        request.options?.apiKey\n      );\n      const embedVersion = request.options?.version || extractVersion(ref);\n\n      const embeddings = await Promise.all(\n        request.input.map(async (doc) => {\n          const response = await embedContent(\n            embedApiKey,\n            embedVersion,\n            {\n              taskType: request.options?.taskType,\n              title: request.options?.title,\n              content: {\n                role: '',\n                parts: [{ text: doc.text }],\n              },\n              outputDimensionality: request.options?.outputDimensionality,\n            } as EmbedContentRequest,\n            clientOptions\n          );\n          const values = response.embedding.values;\n          return { embedding: values };\n        })\n      );\n      return { embeddings };\n    }\n  );\n}\n\nexport const TEST_ONLY = { KNOWN_MODELS };\n"],"names":["pluginEmbedder"],"mappings":"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"}},
    {"offset": {"line": 1859, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/googleai/gemini.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ActionMetadata, GenkitError, modelActionMetadata, z } from 'genkit';\nimport {\n  CandidateData,\n  GenerationCommonConfigDescriptions,\n  GenerationCommonConfigSchema,\n  ModelAction,\n  ModelInfo,\n  ModelMiddleware,\n  ModelReference,\n  getBasicUsageStats,\n  modelRef,\n} from 'genkit/model';\nimport { downloadRequestMedia } from 'genkit/model/middleware';\nimport { model as pluginModel } from 'genkit/plugin';\nimport { runInNewSpan } from 'genkit/tracing';\nimport {\n  fromGeminiCandidate,\n  toGeminiFunctionModeEnum,\n  toGeminiMessage,\n  toGeminiSystemInstruction,\n  toGeminiTool,\n} from '../common/converters.js';\nimport {\n  generateContent,\n  generateContentStream,\n  getGoogleAIUrl,\n} from './client.js';\nimport {\n  ClientOptions,\n  Content as GeminiMessage,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GenerationConfig,\n  GoogleAIPluginOptions,\n  GoogleSearchRetrievalTool,\n  Model,\n  SafetySetting,\n  Tool,\n  ToolConfig,\n  UrlContextTool,\n} from './types.js';\nimport {\n  calculateApiKey,\n  calculateRequestOptions,\n  checkApiKey,\n  checkModelName,\n  cleanSchema,\n  extractVersion,\n  removeClientOptionOverrides,\n} from './utils.js';\n\n/**\n * See https://ai.google.dev/gemini-api/docs/safety-settings#safety-filters.\n */\nconst SafetySettingsSchema = z\n  .object({\n    category: z.enum([\n      'HARM_CATEGORY_UNSPECIFIED',\n      'HARM_CATEGORY_HATE_SPEECH',\n      'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n      'HARM_CATEGORY_HARASSMENT',\n      'HARM_CATEGORY_DANGEROUS_CONTENT',\n    ]),\n    threshold: z.enum([\n      'BLOCK_LOW_AND_ABOVE',\n      'BLOCK_MEDIUM_AND_ABOVE',\n      'BLOCK_ONLY_HIGH',\n      'BLOCK_NONE',\n    ]),\n  })\n  .passthrough();\n\nconst VoiceConfigSchema = z\n  .object({\n    prebuiltVoiceConfig: z\n      .object({\n        // TODO: Make this an array of objects so we can also specify the description\n        // for each voiceName.\n        voiceName: z\n          .union([\n            z.enum([\n              'Zephyr',\n              'Puck',\n              'Charon',\n              'Kore',\n              'Fenrir',\n              'Leda',\n              'Orus',\n              'Aoede',\n              'Callirrhoe',\n              'Autonoe',\n              'Enceladus',\n              'Iapetus',\n              'Umbriel',\n              'Algieba',\n              'Despina',\n              'Erinome',\n              'Algenib',\n              'Rasalgethi',\n              'Laomedeia',\n              'Achernar',\n              'Alnilam',\n              'Schedar',\n              'Gacrux',\n              'Pulcherrima',\n              'Achird',\n              'Zubenelgenubi',\n              'Vindemiatrix',\n              'Sadachbia',\n              'Sadaltager',\n              'Sulafat',\n            ]),\n            // To allow any new string values\n            z.string(),\n          ])\n          .describe('Name of the preset voice to use')\n          .optional(),\n      })\n      .describe('Configuration for the prebuilt speaker to use')\n      .passthrough()\n      .optional(),\n  })\n  .describe('Configuration for the voice to use')\n  .passthrough();\n\nexport const GeminiConfigSchema = GenerationCommonConfigSchema.extend({\n  apiKey: z\n    .string()\n    .describe('Overrides the plugin-configured API key, if specified.')\n    .optional(),\n  baseUrl: z\n    .string()\n    .describe(\n      'Overrides the plugin-configured or default baseUrl, if specified.'\n    )\n    .optional(),\n  apiVersion: z\n    .string()\n    .describe(\n      'Overrides the plugin-configured or default apiVersion, if specified.'\n    )\n    .optional(),\n  safetySettings: z\n    .array(SafetySettingsSchema)\n    .describe(\n      'Adjust how likely you are to see responses that could be harmful. ' +\n        'Content is blocked based on the probability that it is harmful.'\n    )\n    .optional(),\n  codeExecution: z\n    .union([z.boolean(), z.object({}).strict()])\n    .describe('Enables the model to generate and run code.')\n    .optional(),\n  contextCache: z\n    .boolean()\n    .describe(\n      'Context caching allows you to save and reuse precomputed input ' +\n        'tokens that you wish to use repeatedly.'\n    )\n    .optional(),\n  functionCallingConfig: z\n    .object({\n      mode: z.enum(['MODE_UNSPECIFIED', 'AUTO', 'ANY', 'NONE']).optional(),\n      allowedFunctionNames: z.array(z.string()).optional(),\n    })\n    .describe(\n      'Controls how the model uses the provided tools (function declarations). ' +\n        'With AUTO (Default) mode, the model decides whether to generate a ' +\n        'natural language response or suggest a function call based on the ' +\n        'prompt and context. With ANY, the model is constrained to always ' +\n        'predict a function call and guarantee function schema adherence. ' +\n        'With NONE, the model is prohibited from making function calls.'\n    )\n    .passthrough()\n    .optional(),\n  responseModalities: z\n    .array(z.enum(['TEXT', 'IMAGE', 'AUDIO']))\n    .describe(\n      'The modalities to be used in response. Only supported for ' +\n        \"'gemini-2.0-flash-exp' model at present.\"\n    )\n    .optional(),\n  googleSearchRetrieval: z\n    .union([z.boolean(), z.object({}).passthrough()])\n    .describe(\n      'Retrieve public web data for grounding, powered by Google Search.'\n    )\n    .optional(),\n  fileSearch: z\n    .object({\n      fileSearchStoreNames: z\n        .array(z.string())\n        .describe(\n          'The names of the fileSearchStores to retrieve from. ' +\n            'Example: fileSearchStores/my-file-search-store-123'\n        ),\n      metadataFilter: z\n        .string()\n        .optional()\n        .describe(\n          'Metadata filter to apply to the semantic retrieval documents and chunks.'\n        ),\n      topK: z\n        .number()\n        .optional()\n        .describe('The number of semantic retrieval chunks to retrieve.'),\n    })\n    .passthrough()\n    .optional(),\n  urlContext: z\n    .union([z.boolean(), z.object({}).passthrough()])\n    .describe('Return grounding metadata from links included in the query')\n    .optional(),\n  temperature: z\n    .number()\n    .min(0)\n    .max(2)\n    .describe(\n      GenerationCommonConfigDescriptions.temperature +\n        ' The default value is 1.0.'\n    )\n    .optional(),\n  topP: z\n    .number()\n    .min(0)\n    .max(1)\n    .describe(\n      GenerationCommonConfigDescriptions.topP + ' The default value is 0.95.'\n    )\n    .optional(),\n  thinkingConfig: z\n    .object({\n      includeThoughts: z\n        .boolean()\n        .describe(\n          'Indicates whether to include thoughts in the response.' +\n            'If true, thoughts are returned only if the model supports ' +\n            'thought and thoughts are available.'\n        )\n        .optional(),\n      thinkingBudget: z\n        .number()\n        .min(0)\n        .max(24576)\n        .describe(\n          'For Gemini 2.5 - Indicates the thinking budget in tokens. 0 is DISABLED. ' +\n            '-1 is AUTOMATIC. The default values and allowed ranges are model ' +\n            'dependent. The thinking budget parameter gives the model guidance ' +\n            'on the number of thinking tokens it can use when generating a ' +\n            'response. A greater number of tokens is typically associated with ' +\n            'more detailed thinking, which is needed for solving more complex ' +\n            'tasks. '\n        )\n        .optional(),\n      thinkingLevel: z\n        .enum(['LOW', 'MEDIUM', 'HIGH'])\n        .describe(\n          'For Gemini 3.0 - Indicates the thinking level. A higher level ' +\n            'is associated with more detailed thinking, which is needed for solving ' +\n            'more complex tasks.'\n        )\n        .optional(),\n    })\n    .passthrough()\n    .optional(),\n}).passthrough();\nexport type GeminiConfigSchemaType = typeof GeminiConfigSchema;\nexport type GeminiConfig = z.infer<GeminiConfigSchemaType>;\n\nexport const GeminiTtsConfigSchema = GeminiConfigSchema.extend({\n  speechConfig: z\n    .object({\n      voiceConfig: VoiceConfigSchema.optional(),\n      multiSpeakerVoiceConfig: z\n        .object({\n          speakerVoiceConfigs: z\n            .array(\n              z\n                .object({\n                  speaker: z.string().describe('Name of the speaker to use'),\n                  voiceConfig: VoiceConfigSchema,\n                })\n                .describe(\n                  'Configuration for a single speaker in a multi speaker setup'\n                )\n                .passthrough()\n            )\n            .describe('Configuration for all the enabled speaker voices'),\n        })\n        .describe('Configuration for multi-speaker setup')\n        .passthrough()\n        .optional(),\n    })\n    .describe('Speech generation config')\n    .passthrough()\n    .optional(),\n}).passthrough();\nexport type GeminiTtsConfigSchemaType = typeof GeminiTtsConfigSchema;\nexport type GeminiTtsConfig = z.infer<GeminiTtsConfigSchemaType>;\n\nexport const GeminiImageConfigSchema = GeminiConfigSchema.extend({\n  imageConfig: z\n    .object({\n      aspectRatio: z\n        .enum([\n          '1:1',\n          '2:3',\n          '3:2',\n          '3:4',\n          '4:3',\n          '4:5',\n          '5:4',\n          '9:16',\n          '16:9',\n          '21:9',\n        ])\n        .optional(),\n      imageSize: z.enum(['1K', '2K', '4K']).optional(),\n    })\n    .passthrough()\n    .optional(),\n}).passthrough();\nexport type GeminiImageConfigSchemaType = typeof GeminiImageConfigSchema;\nexport type GeminiImageConfig = z.infer<GeminiImageConfigSchemaType>;\n\nexport const GemmaConfigSchema = GeminiConfigSchema.extend({\n  temperature: z\n    .number()\n    .min(0.0)\n    .max(1.0)\n    .describe(\n      GenerationCommonConfigDescriptions.temperature +\n        ' The default value is 1.0.'\n    )\n    .optional(),\n}).passthrough();\nexport type GemmaConfigSchemaType = typeof GemmaConfigSchema;\nexport type GemmaConfig = z.infer<GemmaConfigSchemaType>;\n\n// This contains all the Gemini config schema types\ntype ConfigSchemaType =\n  | GeminiConfigSchemaType\n  | GeminiTtsConfigSchemaType\n  | GeminiImageConfigSchemaType\n  | GemmaConfigSchemaType;\ntype ConfigSchema = z.infer<ConfigSchemaType>;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = GeminiConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `googleai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        multiturn: true,\n        media: true,\n        tools: true,\n        toolChoice: true,\n        systemRole: true,\n        constrained: 'no-tools',\n        output: ['text', 'json'],\n      },\n    },\n  });\n}\n\nconst GENERIC_MODEL = commonRef('gemini');\nconst GENERIC_TTS_MODEL = commonRef(\n  'gemini-tts',\n  {\n    supports: {\n      multiturn: false,\n      media: false,\n      tools: false,\n      toolChoice: false,\n      systemRole: false,\n      constrained: 'no-tools',\n    },\n  },\n  GeminiTtsConfigSchema\n);\nconst GENERIC_IMAGE_MODEL = commonRef(\n  'gemini-image',\n  {\n    supports: {\n      multiturn: true,\n      media: true,\n      tools: true,\n      toolChoice: true,\n      systemRole: true,\n      constrained: 'no-tools',\n    },\n  },\n  GeminiImageConfigSchema\n);\nconst GENERIC_GEMMA_MODEL = commonRef(\n  'gemma-generic',\n  undefined,\n  GemmaConfigSchema\n);\n\nconst KNOWN_GEMINI_MODELS = {\n  'gemini-3-pro-preview': commonRef('gemini-3-pro-preview'),\n  'gemini-2.5-pro': commonRef('gemini-2.5-pro'),\n  'gemini-2.5-flash': commonRef('gemini-2.5-flash'),\n  'gemini-2.5-flash-lite': commonRef('gemini-2.5-flash-lite'),\n  'gemini-2.0-flash': commonRef('gemini-2.0-flash'),\n  'gemini-2.0-flash-lite': commonRef('gemini-2.0-flash-lite'),\n};\nexport type KnownGeminiModels = keyof typeof KNOWN_GEMINI_MODELS;\nexport type GeminiModelName = `gemini-${string}`;\nexport function isGeminiModelName(value: string): value is GeminiModelName {\n  return (\n    value.startsWith('gemini-') &&\n    !value.endsWith('-tts') &&\n    !value.includes('-image')\n  );\n}\n\nconst KNOWN_TTS_MODELS = {\n  'gemini-2.5-flash-preview-tts': commonRef(\n    'gemini-2.5-flash-preview-tts',\n    { ...GENERIC_TTS_MODEL.info },\n    GeminiTtsConfigSchema\n  ),\n  'gemini-2.5-pro-preview-tts': commonRef(\n    'gemini-2.5-pro-preview-tts',\n    { ...GENERIC_TTS_MODEL.info },\n    GeminiTtsConfigSchema\n  ),\n};\nexport type KnownTtsModels = keyof typeof KNOWN_TTS_MODELS;\nexport type TTSModelName = `gemini-${string}-tts`;\nexport function isTTSModelName(value: string): value is TTSModelName {\n  return value.startsWith('gemini-') && value.endsWith('-tts');\n}\n\nconst KNOWN_IMAGE_MODELS = {\n  'gemini-3-pro-image-preview': commonRef(\n    'gemini-3-pro-image-preview',\n    { ...GENERIC_IMAGE_MODEL.info },\n    GeminiImageConfigSchema\n  ),\n  'gemini-2.5-flash-image-preview': commonRef(\n    'gemini-2.5-flash-image-preview',\n    { ...GENERIC_IMAGE_MODEL.info },\n    GeminiImageConfigSchema\n  ),\n  'gemini-2.5-flash-image': commonRef(\n    'gemini-2.5-flash-image',\n    { ...GENERIC_IMAGE_MODEL.info },\n    GeminiImageConfigSchema\n  ),\n} as const;\nexport type KnownImageModels = keyof typeof KNOWN_IMAGE_MODELS;\nexport type ImageModelName = `gemini-${string}-image${string}`;\nexport function isImageModelName(value: string): value is ImageModelName {\n  return value.startsWith('gemini-') && value.includes('-image');\n}\n\nconst KNOWN_GEMMA_MODELS = {\n  'gemma-3-12b-it': commonRef('gemma-3-12b-it', undefined, GemmaConfigSchema),\n  'gemma-3-1b-it': commonRef('gemma-3-1b-it', undefined, GemmaConfigSchema),\n  'gemma-3-27b-it': commonRef('gemma-3-27b-it', undefined, GemmaConfigSchema),\n  'gemma-3-4b-it': commonRef('gemma-3-4b-it', undefined, GemmaConfigSchema),\n  'gemma-3n-e4b-it': commonRef('gemma-3n-e4b-it', undefined, GemmaConfigSchema),\n} as const;\nexport type KnownGemmaModels = keyof typeof KNOWN_GEMMA_MODELS;\nexport type GemmaModelName = `gemma-${string}`;\nexport function isGemmaModelName(value: string): value is GemmaModelName {\n  return value.startsWith('gemma-');\n}\n\nconst KNOWN_MODELS = {\n  ...KNOWN_GEMINI_MODELS,\n  ...KNOWN_TTS_MODELS,\n  ...KNOWN_IMAGE_MODELS,\n  ...KNOWN_GEMMA_MODELS,\n};\n\nexport function model(\n  version: string,\n  config: ConfigSchema = {}\n): ModelReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n\n  if (isTTSModelName(name)) {\n    return modelRef({\n      name: `googleai/${name}`,\n      config,\n      configSchema: GeminiTtsConfigSchema,\n      info: { ...GENERIC_TTS_MODEL.info },\n    });\n  }\n\n  if (isImageModelName(name)) {\n    return modelRef({\n      name: `googleai/${name}`,\n      config,\n      configSchema: GeminiImageConfigSchema,\n      info: { ...GENERIC_IMAGE_MODEL.info },\n    });\n  }\n\n  if (isGemmaModelName(name)) {\n    return modelRef({\n      name: `googleai/${name}`,\n      config,\n      configSchema: GemmaConfigSchema,\n      info: { ...GENERIC_GEMMA_MODEL.info },\n    });\n  }\n\n  return modelRef({\n    name: `googleai/${name}`,\n    config,\n    configSchema: GeminiConfigSchema,\n    info: { ...GENERIC_MODEL.info },\n  });\n}\n\n// Takes a full list of models, filters for current Gemini models only\n// and returns a modelActionMetadata for each.\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return (\n    models\n      .filter((m) => m.supportedGenerationMethods.includes('generateContent'))\n      // Filter out deprecated\n      .filter((m) => !m.description || !m.description.includes('deprecated'))\n      .map((m) => {\n        const ref = model(m.name);\n        return modelActionMetadata({\n          name: ref.name,\n          info: ref.info,\n          configSchema: ref.configSchema,\n        });\n      })\n  );\n}\n\nexport function listKnownModels(options?: GoogleAIPluginOptions) {\n  return Object.keys(KNOWN_MODELS).map((name: string) =>\n    defineModel(name, options)\n  );\n}\n\n/**\n * Defines a new GoogleAI Gemini model.\n */\nexport function defineModel(\n  name: string,\n  pluginOptions?: GoogleAIPluginOptions\n): ModelAction {\n  checkApiKey(pluginOptions?.apiKey);\n  const ref = model(name);\n  const clientOptions: ClientOptions = {\n    apiVersion: pluginOptions?.apiVersion,\n    baseUrl: pluginOptions?.baseUrl,\n    customHeaders: pluginOptions?.customHeaders,\n  };\n\n  const middleware: ModelMiddleware[] = [];\n  if (ref.info?.supports?.media) {\n    // the gemini api doesn't support downloading media from http(s)\n    middleware.push(\n      downloadRequestMedia({\n        maxBytes: 1024 * 1024 * 10,\n        // don't downlaod files that have been uploaded using the Files API\n        filter: (part) => {\n          try {\n            const url = new URL(part.media.url);\n            if (\n              // Gemini can handle these URLs\n              [\n                'generativelanguage.googleapis.com',\n                'www.youtube.com',\n                'youtube.com',\n                'youtu.be',\n              ].includes(url.hostname)\n            )\n              return false;\n          } catch {}\n          return true;\n        },\n      })\n    );\n  }\n\n  return pluginModel(\n    {\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n      use: middleware,\n    },\n    async (request, { streamingRequested, sendChunk, abortSignal }) => {\n      const clientOpt = calculateRequestOptions(\n        { ...clientOptions, signal: abortSignal },\n        request.config\n      );\n\n      // Make a copy so that modifying the request will not produce side-effects\n      const messages = [...request.messages];\n      if (messages.length === 0) throw new Error('No messages provided.');\n\n      // Gemini does not support messages with role system and instead expects\n      // systemInstructions to be provided as a separate input. The first\n      // message detected with role=system will be used for systemInstructions.\n      let systemInstruction: GeminiMessage | undefined = undefined;\n      const systemMessage = messages.find((m) => m.role === 'system');\n      if (systemMessage) {\n        messages.splice(messages.indexOf(systemMessage), 1);\n        systemInstruction = toGeminiSystemInstruction(systemMessage);\n      }\n\n      const tools: Tool[] = [];\n      if (request.tools?.length) {\n        tools.push({\n          functionDeclarations: request.tools.map(toGeminiTool),\n        });\n      }\n\n      const requestOptions: ConfigSchema = {\n        ...request.config,\n      };\n      const {\n        apiKey: apiKeyFromConfig,\n        safetySettings: safetySettingsFromConfig,\n        codeExecution: codeExecutionFromConfig,\n        version: versionFromConfig,\n        functionCallingConfig,\n        googleSearchRetrieval,\n        fileSearch,\n        urlContext,\n        tools: toolsFromConfig,\n        ...restOfConfigOptions\n      } = requestOptions;\n\n      if (codeExecutionFromConfig) {\n        tools.push({\n          codeExecution:\n            codeExecutionFromConfig === true ? {} : codeExecutionFromConfig,\n        });\n      }\n\n      if (toolsFromConfig) {\n        tools.push(...(toolsFromConfig as any[]));\n      }\n\n      if (googleSearchRetrieval) {\n        tools.push({\n          googleSearch:\n            googleSearchRetrieval === true ? {} : googleSearchRetrieval,\n        } as GoogleSearchRetrievalTool);\n      }\n\n      if (fileSearch) {\n        tools.push({\n          fileSearch,\n        });\n      }\n\n      if (urlContext) {\n        tools.push({\n          urlContext: urlContext === true ? {} : urlContext,\n        } as UrlContextTool);\n      }\n\n      let toolConfig: ToolConfig | undefined;\n      if (functionCallingConfig) {\n        toolConfig = {\n          functionCallingConfig: {\n            allowedFunctionNames: functionCallingConfig.allowedFunctionNames,\n            mode: toGeminiFunctionModeEnum(functionCallingConfig.mode),\n          },\n        };\n      } else if (request.toolChoice) {\n        toolConfig = {\n          functionCallingConfig: {\n            mode: toGeminiFunctionModeEnum(request.toolChoice),\n          },\n        };\n      }\n\n      // Cannot use tools with JSON mode\n      const jsonMode =\n        request.output?.format === 'json' ||\n        (request.output?.contentType === 'application/json' &&\n          tools.length === 0);\n\n      const generationConfig: GenerationConfig = {\n        ...removeClientOptionOverrides(restOfConfigOptions),\n        candidateCount: request.candidates || undefined,\n        responseMimeType: jsonMode ? 'application/json' : undefined,\n      };\n\n      if (request.output?.constrained && jsonMode) {\n        if (pluginOptions?.legacyResponseSchema) {\n          generationConfig.responseSchema = cleanSchema(request.output.schema);\n        } else {\n          generationConfig.responseJsonSchema = request.output.schema;\n        }\n      }\n\n      const msg = toGeminiMessage(messages[messages.length - 1], ref);\n\n      let generateContentRequest: GenerateContentRequest = {\n        systemInstruction,\n        generationConfig,\n        tools: tools.length ? tools : undefined,\n        toolConfig,\n        safetySettings: safetySettingsFromConfig?.filter(\n          (setting) => setting.category !== 'HARM_CATEGORY_UNSPECIFIED'\n        ) as SafetySetting[],\n        contents: messages.map((message) => toGeminiMessage(message, ref)),\n      };\n\n      const modelVersion = versionFromConfig || extractVersion(ref);\n\n      const generateApiKey = calculateApiKey(\n        pluginOptions?.apiKey,\n        requestOptions.apiKey\n      );\n\n      const callGemini = async () => {\n        let response: GenerateContentResponse;\n\n        if (streamingRequested) {\n          const result = await generateContentStream(\n            generateApiKey,\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n          const chunks: CandidateData[] = [];\n          for await (const item of result.stream) {\n            item.candidates?.forEach((candidate) => {\n              const c = fromGeminiCandidate(candidate, chunks);\n              chunks.push(c);\n              sendChunk({\n                index: c.index,\n                content: c.message.content,\n              });\n            });\n          }\n          response = await result.response;\n        } else {\n          response = await generateContent(\n            generateApiKey,\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n        }\n\n        const candidates = response.candidates || [];\n        if (response.candidates?.['undefined']) {\n          candidates.push(response.candidates['undefined']);\n        }\n        if (!candidates.length) {\n          throw new GenkitError({\n            status: 'FAILED_PRECONDITION',\n            message: 'No valid candidates returned.',\n          });\n        }\n\n        const candidateData =\n          candidates.map((c) => fromGeminiCandidate(c)) || [];\n\n        return {\n          candidates: candidateData,\n          custom: response,\n          usage: {\n            ...getBasicUsageStats(request.messages, candidateData),\n            inputTokens: response.usageMetadata?.promptTokenCount,\n            outputTokens: response.usageMetadata?.candidatesTokenCount,\n            thoughtsTokens: response.usageMetadata?.thoughtsTokenCount,\n            totalTokens: response.usageMetadata?.totalTokenCount,\n            cachedContentTokens:\n              response.usageMetadata?.cachedContentTokenCount,\n          },\n        };\n      };\n\n      // If debugTraces is enabled, we wrap the actual model call with a span, add raw\n      // API params as for input.\n      return pluginOptions?.experimental_debugTraces\n        ? await runInNewSpan(\n            {\n              metadata: {\n                name: streamingRequested ? 'sendMessageStream' : 'sendMessage',\n              },\n            },\n            async (metadata) => {\n              metadata.input = {\n                apiEndpoint: getGoogleAIUrl({\n                  resourcePath: '',\n                  clientOptions: clientOpt,\n                }),\n                cache: {},\n                model: modelVersion,\n                generateContentOptions: generateContentRequest,\n                parts: msg.parts,\n                options: clientOpt,\n              };\n              const response = await callGemini();\n              metadata.output = response.custom;\n              return response;\n            }\n          )\n        : await callGemini();\n    }\n  );\n}\n\nexport const TEST_ONLY = { KNOWN_MODELS };\n"],"names":["pluginModel"],"mappings":"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"}},
    {"offset": {"line": 2403, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/googleai/imagen.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  MediaPart,\n  MessageData,\n  modelActionMetadata,\n  z,\n} from 'genkit';\nimport {\n  getBasicUsageStats,\n  modelRef,\n  type GenerateRequest,\n  type ModelAction,\n  type ModelInfo,\n  type ModelReference,\n} from 'genkit/model';\nimport { model as pluginModel } from 'genkit/plugin';\nimport { imagenPredict } from './client.js';\nimport type {\n  ClientOptions,\n  GoogleAIPluginOptions,\n  ImagenParameters,\n  ImagenPredictRequest,\n  ImagenPrediction,\n  Model,\n} from './types.js';\nimport {\n  calculateApiKey,\n  checkApiKey,\n  checkModelName,\n  extractImagenImage,\n  extractText,\n  extractVersion,\n  modelName,\n} from './utils.js';\n\n/**\n * See https://ai.google.dev/gemini-api/docs/image-generation#imagen-model\n */\nexport const ImagenConfigSchema = z\n  .object({\n    apiKey: z\n      .string()\n      .describe('Override the API key provided at plugin initialization.')\n      .optional(),\n\n    numberOfImages: z\n      .number()\n      .describe(\n        'The number of images to generate, from 1 to 4 (inclusive). The default is 1.'\n      )\n      .optional(),\n    aspectRatio: z\n      .enum(['1:1', '9:16', '16:9', '3:4', '4:3'])\n      .describe('Desired aspect ratio of the output image.')\n      .optional(),\n    personGeneration: z\n      .enum(['dont_allow', 'allow_adult', 'allow_all'])\n      .describe(\n        'Control if/how images of people will be generated by the model.'\n      )\n      .optional(),\n  })\n  .passthrough();\nexport type ImagenConfigSchemaType = typeof ImagenConfigSchema;\nexport type ImagenConfig = z.infer<ImagenConfigSchemaType>;\n\n// This contains all the schemas for imagen models.\ntype ConfigSchemaType = ImagenConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = ImagenConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `googleai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        media: true,\n        multiturn: false,\n        tools: false,\n        toolChoice: false,\n        systemRole: false,\n        output: ['media'],\n      },\n    },\n  });\n}\n\n// Allow all the capabilities for unknown future models\nconst GENERIC_MODEL = commonRef('imagen', {\n  supports: {\n    media: true,\n    multiturn: true,\n    tools: true,\n    systemRole: true,\n    output: ['media'],\n  },\n});\n\nconst KNOWN_MODELS = {\n  'imagen-4.0-fast-generate-001': commonRef('imagen-4.0-fast-generate-001'),\n  'imagen-4.0-generate-001': commonRef('imagen-4.0-generate-001'),\n  'imagen-4.0-ultra-generate-001': commonRef('imagen-4.0-ultra-generate-001'),\n} as const;\nexport type KnownModels = keyof typeof KNOWN_MODELS; // For autocomplete\n\n// For conditional types in index.ts model()\nexport type ImagenModelName = `imagen-${string}`;\nexport function isImagenModelName(value?: string): value is ImagenModelName {\n  return !!value?.startsWith('imagen-');\n}\n\nexport function model(\n  version: string,\n  config: ImagenConfig = {}\n): ModelReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  if (KNOWN_MODELS[name]) {\n    return KNOWN_MODELS[name].withConfig(config);\n  }\n\n  return modelRef({\n    name: `googleai/${name}`,\n    config,\n    configSchema: ImagenConfigSchema,\n    info: {\n      ...GENERIC_MODEL.info,\n    },\n  });\n}\n\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return models\n    .filter(\n      (m) =>\n        m.supportedGenerationMethods.includes('predict') &&\n        isImagenModelName(modelName(m.name))\n    )\n    .filter((m) => !m.description || !m.description.includes('deprecated'))\n    .map((m) => {\n      const ref = model(m.name);\n      return modelActionMetadata({\n        name: ref.name,\n        info: ref.info,\n        configSchema: ref.configSchema,\n      });\n    });\n}\n\nexport function listKnownModels(options?: GoogleAIPluginOptions) {\n  return Object.keys(KNOWN_MODELS).map((name: string) =>\n    defineModel(name, options)\n  );\n}\n\nexport function defineModel(\n  name: string,\n  pluginOptions?: GoogleAIPluginOptions\n): ModelAction {\n  checkApiKey(pluginOptions?.apiKey);\n  const ref = model(name);\n  const clientOptions: ClientOptions = {\n    apiVersion: pluginOptions?.apiVersion,\n    baseUrl: pluginOptions?.baseUrl,\n    customHeaders: pluginOptions?.customHeaders,\n  };\n\n  return pluginModel(\n    {\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n    },\n    async (request, { abortSignal }) => {\n      const clientOpt = { ...clientOptions, signal: abortSignal };\n      const imagenPredictRequest: ImagenPredictRequest = {\n        instances: [\n          {\n            prompt: extractText(request),\n            image: extractImagenImage(request),\n          },\n        ],\n        parameters: toImagenParameters(request),\n      };\n\n      const predictApiKey = calculateApiKey(\n        pluginOptions?.apiKey,\n        request.config?.apiKey\n      );\n\n      const response = await imagenPredict(\n        predictApiKey,\n        extractVersion(ref),\n        imagenPredictRequest,\n        clientOpt\n      );\n\n      if (!response.predictions || response.predictions.length == 0) {\n        throw new Error(\n          'Model returned no predictions. Possibly due to content filters.'\n        );\n      }\n\n      const message: MessageData = {\n        role: 'model',\n        content: response.predictions.map(fromImagenPrediction),\n      };\n\n      return {\n        finishReason: 'stop',\n        message,\n        usage: getBasicUsageStats(request.messages, message),\n        custom: response,\n      };\n    }\n  );\n}\n\nfunction fromImagenPrediction(p: ImagenPrediction): MediaPart {\n  const b64data = p.bytesBase64Encoded;\n  const mimeType = p.mimeType;\n  return {\n    media: {\n      url: `data:${mimeType};base64,${b64data}`,\n      contentType: mimeType,\n    },\n  };\n}\n\nfunction toImagenParameters(\n  request: GenerateRequest<typeof ImagenConfigSchema>\n): ImagenParameters {\n  const out = {\n    sampleCount: request.config?.numberOfImages ?? 1,\n    ...request?.config,\n  };\n\n  for (const k in out) {\n    if (!out[k]) delete out[k];\n  }\n\n  // This is not part of the request parameters sent to the endpoint\n  // It's pulled out and used separately\n  delete out.apiKey;\n\n  return out;\n}\n\nexport const TEST_ONLY = {\n  toImagenParameters,\n  fromImagenPrediction,\n  GENERIC_MODEL,\n  KNOWN_MODELS,\n};\n"],"names":["pluginModel"],"mappings":"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"}},
    {"offset": {"line": 2605, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/googleai/veo.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  GenerateResponseData,\n  Operation,\n  modelActionMetadata,\n  z,\n} from 'genkit';\nimport {\n  BackgroundModelAction,\n  modelRef,\n  type GenerateRequest,\n  type ModelInfo,\n  type ModelReference,\n} from 'genkit/model';\nimport { backgroundModel as pluginBackgroundModel } from 'genkit/plugin';\nimport { veoCheckOperation, veoPredict } from './client.js';\nimport {\n  ClientOptions,\n  GoogleAIPluginOptions,\n  Model,\n  VeoOperation,\n  VeoParameters,\n  VeoPredictRequest,\n} from './types.js';\nimport {\n  calculateApiKey,\n  checkModelName,\n  extractText,\n  extractVeoImage,\n  extractVeoVideo,\n  extractVersion,\n  modelName,\n} from './utils.js';\n\n/**\n * See https://ai.google.dev/gemini-api/docs/video\n */\nexport const VeoConfigSchema = z\n  .object({\n    // NOTE: Documentation notes numberOfVideos parameter to pick the number of\n    // output videos, but this setting does not seem to work\n    negativePrompt: z.string().optional(),\n    aspectRatio: z\n      .enum(['9:16', '16:9'])\n      .describe('Desired aspect ratio of the output video.')\n      .optional(),\n    personGeneration: z\n      .enum(['dont_allow', 'allow_adult', 'allow_all'])\n      .describe(\n        'Control if/how images of people will be generated by the model.'\n      )\n      .optional(),\n    durationSeconds: z\n      .number()\n      .step(1)\n      .min(5)\n      .max(8)\n      .describe('Length of each output video in seconds, between 5 and 8.')\n      .optional(),\n    enhancePrompt: z\n      .boolean()\n      .describe('Enable or disable the prompt rewriter. Enabled by default.')\n      .optional(),\n  })\n  .passthrough();\nexport type VeoConfigSchemaType = typeof VeoConfigSchema;\nexport type VeoConfig = z.infer<VeoConfigSchemaType>;\n\n// This contains all the Veo config schema types\ntype ConfigSchemaType = VeoConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = VeoConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `googleai/${name}`,\n    configSchema,\n    info:\n      info ??\n      ({\n        supports: {\n          media: true,\n          multiturn: false,\n          tools: false,\n          systemRole: false,\n          output: ['media'],\n          longRunning: true,\n        },\n      } as ModelInfo), // TODO(ifielker): Remove this cast if we fix longRunning\n  });\n}\n\nconst GENERIC_MODEL = commonRef('veo');\n\nconst KNOWN_MODELS = {\n  'veo-3.1-generate-preview': commonRef('veo-3.1-generate-preview'),\n  'veo-3.1-fast-generate-preview': commonRef('veo-3.1-fast-generate-preview'),\n  'veo-3.0-generate-001': commonRef('veo-3.0-generate-001'),\n  'veo-3.0-fast-generate-001': commonRef('veo-3.0-fast-generate-001'),\n  'veo-2.0-generate-001': commonRef('veo-2.0-generate-001'),\n} as const;\nexport type KnownModels = keyof typeof KNOWN_MODELS; // For autocomplete\nexport type VeoModelName = `veo-${string}`;\nexport function isVeoModelName(value?: string): value is VeoModelName {\n  return !!value?.startsWith('veo-');\n}\n\nexport function model(\n  version: string,\n  config: VeoConfig = {}\n): ModelReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  return modelRef({\n    name: `googleai/${name}`,\n    config,\n    configSchema: VeoConfigSchema,\n    info: { ...GENERIC_MODEL.info },\n  });\n}\n\n// Takes a full list of models, filters for current Veo models only\n// and returns a modelActionMetadata for each.\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return (\n    models\n      .filter(\n        (m) =>\n          m.supportedGenerationMethods.includes('predictLongRunning') &&\n          isVeoModelName(modelName(m.name))\n      )\n      // Filter out deprecated\n      .filter((m) => !m.description || !m.description.includes('deprecated'))\n      .map((m) => {\n        const ref = model(m.name);\n        return modelActionMetadata({\n          name: ref.name,\n          info: ref.info,\n          configSchema: ref.configSchema,\n        });\n      })\n  );\n}\n\nexport function listKnownModels(options?: GoogleAIPluginOptions) {\n  return Object.keys(KNOWN_MODELS).map((name: string) =>\n    defineModel(name, options)\n  );\n}\n\n/**\n * Defines a new GoogleAI Veo model.\n */\nexport function defineModel(\n  name: string,\n  pluginOptions?: GoogleAIPluginOptions\n): BackgroundModelAction<VeoConfigSchemaType> {\n  const ref = model(name);\n  const clientOptions: ClientOptions = {\n    apiVersion: pluginOptions?.apiVersion,\n    baseUrl: pluginOptions?.baseUrl,\n    customHeaders: pluginOptions?.customHeaders,\n  };\n\n  return pluginBackgroundModel({\n    name: ref.name,\n    ...ref.info,\n    configSchema: ref.configSchema,\n    async start(request) {\n      const apiKey = calculateApiKey(pluginOptions?.apiKey, undefined);\n      const veoPredictRequest: VeoPredictRequest = {\n        instances: [\n          {\n            prompt: extractText(request),\n            image: extractVeoImage(request),\n            video: extractVeoVideo(request),\n          },\n        ],\n        parameters: toVeoParameters(request),\n      };\n\n      const response = await veoPredict(\n        apiKey,\n        extractVersion(ref),\n        veoPredictRequest,\n        clientOptions\n      );\n\n      return fromVeoOperation(response);\n    },\n    async check(operation) {\n      const apiKey = calculateApiKey(pluginOptions?.apiKey, undefined);\n      const response = await veoCheckOperation(\n        apiKey,\n        operation.id,\n        clientOptions\n      );\n      return fromVeoOperation(response);\n    },\n  });\n}\n\nfunction toVeoParameters(\n  request: GenerateRequest<VeoConfigSchemaType>\n): VeoParameters {\n  const out = {\n    ...request?.config,\n  };\n\n  for (const k in out) {\n    // undefined is handled by JSON.stringify\n    // false is needed so we can set enhancePrompt to false\n    if (out[k] === null) delete out[k];\n  }\n\n  // This is not part of the request parameters sent to the endpoint\n  // It's pulled out and used separately\n  delete out.apiKey;\n\n  // This was used to help us figure out which model. We no longer need\n  // it here.\n  delete out.version;\n\n  return out;\n}\n\nfunction fromVeoOperation(\n  apiOp: VeoOperation\n): Operation<GenerateResponseData> {\n  const res = { id: apiOp.name } as Operation<GenerateResponseData>;\n  if (apiOp.done !== undefined) {\n    res.done = apiOp.done;\n  }\n\n  if (apiOp.error) {\n    res.error = { message: apiOp.error.message };\n  }\n\n  if (\n    apiOp.response &&\n    apiOp.response.generateVideoResponse &&\n    apiOp.response.generateVideoResponse.generatedSamples\n  ) {\n    res.output = {\n      finishReason: 'stop',\n      raw: apiOp.response,\n      message: {\n        role: 'model',\n        content: apiOp.response.generateVideoResponse.generatedSamples.map(\n          (s) => {\n            return {\n              media: {\n                url: s.video.uri,\n              },\n            };\n          }\n        ),\n      },\n    };\n  }\n\n  return res;\n}\n\nexport const TEST_ONLY = {\n  toVeoParameters,\n  fromVeoOperation,\n  GENERIC_MODEL,\n  KNOWN_MODELS,\n};\n"],"names":["pluginBackgroundModel"],"mappings":"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"}},
    {"offset": {"line": 2806, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/googleai/index.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ActionMetadata, EmbedderReference, ModelReference, z } from 'genkit';\nimport { logger } from 'genkit/logging';\nimport {\n  GenkitPluginV2,\n  ResolvableAction,\n  genkitPluginV2,\n} from 'genkit/plugin';\nimport { ActionType } from 'genkit/registry';\nimport { extractErrMsg } from '../common/utils.js';\nimport { listModels } from './client.js';\nimport { GoogleAIPluginOptions } from './types.js';\nimport { calculateApiKey } from './utils.js';\n\n// These are namespaced because they all intentionally have\n// functions of the same name with the same arguments.\n// (All exports from these files are used here)\nimport * as embedder from './embedder.js';\nimport * as gemini from './gemini.js';\nimport * as imagen from './imagen.js';\nimport * as veo from './veo.js';\n\nexport { type EmbeddingConfig } from './embedder.js';\nexport { type GeminiConfig, type GeminiTtsConfig } from './gemini.js';\nexport { type ImagenConfig } from './imagen.js';\nexport { type GoogleAIPluginOptions };\n\nasync function initializer(options?: GoogleAIPluginOptions) {\n  return [\n    ...imagen.listKnownModels(options),\n    ...gemini.listKnownModels(options),\n    ...embedder.listKnownModels(options),\n    ...veo.listKnownModels(options),\n  ];\n}\n\nasync function resolver(\n  actionType: ActionType,\n  actionName: string,\n  options: GoogleAIPluginOptions\n): Promise<ResolvableAction | undefined> {\n  switch (actionType) {\n    case 'model':\n      if (veo.isVeoModelName(actionName)) {\n        return undefined;\n      } else if (imagen.isImagenModelName(actionName)) {\n        return await imagen.defineModel(actionName, options);\n      } else {\n        // gemini, tts, image, gemma, unknown models\n        return await gemini.defineModel(actionName, options);\n      }\n      break;\n    case 'background-model':\n      if (veo.isVeoModelName(actionName)) {\n        return await veo.defineModel(actionName, options);\n      }\n      break;\n    case 'embedder':\n      return await embedder.defineEmbedder(actionName, options);\n      break;\n  }\n  return undefined;\n}\n\nasync function listActions(\n  options?: GoogleAIPluginOptions\n): Promise<ActionMetadata[]> {\n  // Don't attempt to list models if apiKey is set to false.\n  if (options?.apiKey === false) {\n    return [];\n  }\n  try {\n    const apiKey = calculateApiKey(options?.apiKey, undefined);\n    const allModels = await listModels(apiKey, {\n      baseUrl: options?.baseUrl,\n      apiVersion: options?.apiVersion,\n    });\n\n    return [\n      ...gemini.listActions(allModels),\n      ...imagen.listActions(allModels),\n      ...veo.listActions(allModels),\n      ...embedder.listActions(allModels),\n    ];\n  } catch (e: unknown) {\n    logger.error(extractErrMsg(e));\n    return [];\n  }\n}\n\n/**\n * Google Gemini Developer API plugin.\n */\nexport function googleAIPlugin(\n  options?: GoogleAIPluginOptions\n): GenkitPluginV2 {\n  let listActionsCache;\n  return genkitPluginV2({\n    name: 'googleai',\n    init: async () => await initializer(options),\n    resolve: async (actionType: ActionType, actionName: string) =>\n      await resolver(actionType, actionName, options || {}),\n    list: async () => {\n      if (listActionsCache) return listActionsCache;\n      listActionsCache = await listActions(options);\n      return listActionsCache;\n    },\n  });\n}\n\nexport type GoogleAIPlugin = {\n  (pluginOptions?: GoogleAIPluginOptions): GenkitPluginV2;\n  model(\n    name: gemini.KnownGemmaModels | (gemini.GemmaModelName & {}),\n    config: gemini.GemmaConfig\n  ): ModelReference<gemini.GemmaConfigSchemaType>;\n  model(\n    name: gemini.KnownTtsModels | (gemini.TTSModelName & {}),\n    config: gemini.GeminiTtsConfig\n  ): ModelReference<gemini.GeminiTtsConfigSchemaType>;\n  model(\n    name: gemini.KnownImageModels | (gemini.ImageModelName & {}),\n    config: gemini.GeminiImageConfig\n  ): ModelReference<gemini.GeminiImageConfigSchemaType>;\n  model(\n    name: gemini.KnownGeminiModels | (gemini.GeminiModelName & {}),\n    config?: gemini.GeminiConfig\n  ): ModelReference<gemini.GeminiConfigSchemaType>;\n  model(\n    name: imagen.KnownModels | (imagen.ImagenModelName & {}),\n    config?: imagen.ImagenConfig\n  ): ModelReference<imagen.ImagenConfigSchemaType>;\n  model(\n    name: veo.KnownModels | (veo.VeoModelName & {}),\n    config?: veo.VeoConfig\n  ): ModelReference<veo.VeoConfigSchemaType>;\n  model(name: string, config?: any): ModelReference<z.ZodTypeAny>;\n\n  embedder(\n    name: string,\n    config?: embedder.EmbeddingConfig\n  ): EmbedderReference<embedder.EmbeddingConfigSchemaType>;\n};\n\n/**\n * Google Gemini Developer API plugin.\n */\nexport const googleAI = googleAIPlugin as GoogleAIPlugin;\n(googleAI as any).model = (\n  name: string,\n  config?: any\n): ModelReference<z.ZodTypeAny> => {\n  if (veo.isVeoModelName(name)) {\n    return veo.model(name, config);\n  }\n  if (imagen.isImagenModelName(name)) {\n    return imagen.model(name, config);\n  }\n  // gemma, tts, image, gemini and unknown model families.\n  return gemini.model(name, config);\n};\ngoogleAI.embedder = (\n  name: string,\n  config?: embedder.EmbeddingConfig\n): EmbedderReference<embedder.EmbeddingConfigSchemaType> => {\n  return embedder.model(name, config);\n};\n\nexport default googleAI;\n"],"names":["import_utils"],"mappings":"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"}},
    {"offset": {"line": 2943, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/vertexai/utils.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenkitError, z } from 'genkit';\nimport { GoogleAuth } from 'google-auth-library';\nimport type {\n  ClientOptions,\n  ExpressClientOptions,\n  GlobalClientOptions,\n  RegionalClientOptions,\n  VertexPluginOptions,\n} from './types.js';\n\nexport {\n  checkModelName,\n  checkSupportedMimeType,\n  cleanSchema,\n  extractMedia,\n  extractMimeType,\n  extractText,\n  extractVersion,\n  modelName,\n} from '../common/utils.js';\n\nconst CLOUD_PLATFORM_OAUTH_SCOPE =\n  'https://www.googleapis.com/auth/cloud-platform';\n\nfunction parseFirebaseProjectId(): string | undefined {\n  if (!process.env.FIREBASE_CONFIG) return undefined;\n  try {\n    return JSON.parse(process.env.FIREBASE_CONFIG).projectId as string;\n  } catch {\n    return undefined;\n  }\n}\n\nlet __mockDerivedOptions: ClientOptions | undefined = undefined;\nfunction setMockDerivedOptions(options: ClientOptions | undefined): void {\n  __mockDerivedOptions = options;\n}\nexport const TEST_ONLY = { setMockDerivedOptions };\n\nexport async function getDerivedOptions(\n  options?: VertexPluginOptions,\n  AuthClass: typeof GoogleAuth = GoogleAuth // Injectable testing\n): Promise<ClientOptions> {\n  if (__mockDerivedOptions) {\n    return Promise.resolve(__mockDerivedOptions);\n  }\n\n  // Figure out the type of preferred options if possible\n  // The order of the if statements is important.\n  if (options?.location == 'global') {\n    return await getGlobalDerivedOptions(AuthClass, options);\n  } else if (options?.location) {\n    return await getRegionalDerivedOptions(AuthClass, options);\n  } else if (options?.apiKey !== undefined) {\n    // apiKey = false still indicates apiKey expectation\n    return getExpressDerivedOptions(options);\n  }\n\n  // If we got here then we're relying on environment variables.\n  // Try regional first, it's the most common usage.\n  try {\n    const regionalOptions = await getRegionalDerivedOptions(AuthClass, options);\n    return regionalOptions;\n  } catch (e: unknown) {\n    /* no-op - try global next */\n  }\n  try {\n    const globalOptions = await getGlobalDerivedOptions(AuthClass, options);\n    return globalOptions;\n  } catch (e: unknown) {\n    /* no-op - try express last */\n  }\n  try {\n    const expressOptions = getExpressDerivedOptions(options);\n    return expressOptions;\n  } catch (e: unknown) {\n    /* no-op */\n  }\n\n  // We did not have enough information in the options or in environment variables\n  // to properly determine client options.\n  throw new GenkitError({\n    status: 'INVALID_ARGUMENT',\n    message:\n      'Unable to determine client options. Please set either apiKey or projectId and location',\n  });\n}\n\nasync function getGlobalDerivedOptions(\n  AuthClass: typeof GoogleAuth,\n  options?: VertexPluginOptions\n): Promise<GlobalClientOptions> {\n  let authOptions = options?.googleAuth;\n  let authClient: GoogleAuth;\n  const providedProjectId =\n    options?.projectId ||\n    process.env.GCLOUD_PROJECT ||\n    parseFirebaseProjectId();\n  if (process.env.GCLOUD_SERVICE_ACCOUNT_CREDS) {\n    const serviceAccountCreds = JSON.parse(\n      process.env.GCLOUD_SERVICE_ACCOUNT_CREDS\n    );\n    authOptions = {\n      credentials: serviceAccountCreds,\n      scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n      projectId: providedProjectId,\n    };\n    authClient = new AuthClass(authOptions);\n  } else {\n    authClient = new AuthClass(\n      authOptions ?? {\n        scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n        projectId: providedProjectId,\n      }\n    );\n  }\n\n  const projectId =\n    options?.projectId ||\n    process.env.GCLOUD_PROJECT ||\n    (await authClient.getProjectId());\n\n  if (!projectId) {\n    throw new Error(\n      `VertexAI Plugin is missing the 'project' configuration. Please set the 'GCLOUD_PROJECT' environment variable or explicitly pass 'project' into genkit config.`\n    );\n  }\n\n  const clientOpt: GlobalClientOptions = {\n    kind: 'global',\n    location: 'global',\n    projectId,\n    authClient,\n  };\n  if (options?.apiKey) {\n    clientOpt.apiKey = options.apiKey;\n  }\n\n  return clientOpt;\n}\n\nfunction getExpressDerivedOptions(\n  options?: VertexPluginOptions\n): ExpressClientOptions {\n  const apiKey = checkApiKey(options?.apiKey);\n  return {\n    kind: 'express',\n    apiKey,\n  };\n}\n\nasync function getRegionalDerivedOptions(\n  AuthClass: typeof GoogleAuth,\n  options?: VertexPluginOptions\n): Promise<RegionalClientOptions> {\n  let authOptions = options?.googleAuth;\n  let authClient: GoogleAuth;\n  const providedProjectId =\n    options?.projectId ||\n    process.env.GCLOUD_PROJECT ||\n    parseFirebaseProjectId();\n  if (process.env.GCLOUD_SERVICE_ACCOUNT_CREDS) {\n    const serviceAccountCreds = JSON.parse(\n      process.env.GCLOUD_SERVICE_ACCOUNT_CREDS\n    );\n    authOptions = {\n      credentials: serviceAccountCreds,\n      scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n      projectId: providedProjectId,\n    };\n    authClient = new AuthClass(authOptions);\n  } else {\n    authClient = new AuthClass(\n      authOptions ?? {\n        scopes: [CLOUD_PLATFORM_OAUTH_SCOPE],\n        projectId: providedProjectId,\n      }\n    );\n  }\n\n  const projectId =\n    options?.projectId ||\n    process.env.GCLOUD_PROJECT ||\n    (await authClient.getProjectId());\n  const location =\n    options?.location || process.env.GCLOUD_LOCATION || 'us-central1';\n\n  if (!location) {\n    throw new Error(\n      `VertexAI Plugin is missing the 'location' configuration. Please set the 'GCLOUD_LOCATION' environment variable or explicitly pass 'location' into genkit config.`\n    );\n  }\n  if (!projectId) {\n    throw new Error(\n      `VertexAI Plugin is missing the 'project' configuration. Please set the 'GCLOUD_PROJECT' environment variable or explicitly pass 'project' into genkit config.`\n    );\n  }\n\n  const clientOpt: RegionalClientOptions = {\n    kind: 'regional',\n    location,\n    projectId,\n    authClient,\n  };\n  if (options?.apiKey) {\n    clientOpt.apiKey = options.apiKey;\n  }\n  return clientOpt;\n}\n\nexport type RequestClientOptions = ClientOptions & {\n  signal: AbortSignal;\n};\n\n/**\n * If location or apiKey are present in reqConfig, they will\n * override the values in the clientOptions. The newOptions will\n * contain the clientOptions with those overrides.\n * @param clientOptions The client options\n * @param reqConfig The request config\n */\nexport function calculateRequestOptions<T extends z.ZodObject<any, any, any>>(\n  clientOptions: RequestClientOptions,\n  reqConfig?: z.infer<T>\n): RequestClientOptions;\nexport function calculateRequestOptions<T extends z.ZodObject<any, any, any>>(\n  clientOptions: ClientOptions,\n  reqConfig?: z.infer<T>\n): ClientOptions;\nexport function calculateRequestOptions<T extends z.ZodObject<any, any, any>>(\n  clientOptions: RequestClientOptions | ClientOptions,\n  reqConfig?: z.infer<T>\n): RequestClientOptions | ClientOptions {\n  let newOptions = { ...clientOptions };\n  if (\n    reqConfig?.location &&\n    typeof reqConfig.location == 'string' &&\n    newOptions.kind != 'express' &&\n    newOptions.location != reqConfig.location\n  ) {\n    // Override the location if it's specified in the request\n    if (reqConfig.location == 'global') {\n      newOptions.location = 'global';\n      newOptions.kind = 'global';\n    } else {\n      newOptions.kind = 'regional';\n      newOptions.location = reqConfig.location;\n    }\n  }\n  if (\n    clientOptions.kind == 'express' &&\n    reqConfig?.apiKey &&\n    typeof reqConfig.apiKey == 'string'\n  ) {\n    newOptions.apiKey = calculateApiKey(clientOptions.apiKey, reqConfig.apiKey);\n  } else if (reqConfig?.apiKey && typeof reqConfig.apiKey == 'string') {\n    // Regional or Global can still use APIKey for billing (not auth)\n    newOptions.apiKey = reqConfig.apiKey;\n  }\n  return newOptions;\n}\n\n/**\n * Retrieves an API key from environment variables.\n *\n * @returns The API key as a string, or `undefined` if none of the specified\n *          environment variables are set.\n */\nexport function getApiKeyFromEnvVar(): string | undefined {\n  return (\n    process.env.VERTEX_API_KEY ||\n    process.env.GOOGLE_API_KEY ||\n    process.env.GOOGLE_GENAI_API_KEY\n  );\n}\n\nexport const MISSING_API_KEY_ERROR = new GenkitError({\n  status: 'FAILED_PRECONDITION',\n  message:\n    'Please pass in the API key or set the VERTEX_API_KEY or GOOGLE_API_KEY environment variable.\\n' +\n    'For more details see https://genkit.dev/docs/integrations/google-genai',\n});\n\nexport const API_KEY_FALSE_ERROR = new GenkitError({\n  status: 'INVALID_ARGUMENT',\n  message:\n    'VertexAI plugin was initialized with {apiKey: false} but no apiKey configuration was passed at call time.',\n});\n\nexport const NOT_SUPPORTED_IN_EXPRESS_ERROR = new GenkitError({\n  status: 'PERMISSION_DENIED',\n  message:\n    'This method or model is not supported in Vertex AI Express Mode.\\n' +\n    'For more details see https://cloud.google.com/vertex-ai/generative-ai/docs/start/express-mode/vertex-ai-express-mode-api-reference',\n});\n\n/**\n * Checks and retrieves an API key based on the provided argument and environment variables.\n *\n * - If `pluginApiKey` is a non-empty string, it's used as the API key.\n * - If `pluginApiKey` is `undefined` or an empty string, it attempts to fetch the API key from environment\n * - If `pluginApiKey` is `false`, key retrieval from the environment is skipped, and the function\n *   will return `undefined`. This mode indicates that the API key is expected to be provided\n *   at a later stage or in a different context.\n *\n * @param pluginApiKey - An optional API key string, `undefined` to check the environment, or `false` to bypass all checks in this function.\n * @returns The resolved API key as a string, or `undefined` if `pluginApiKey` is `false`.\n * @throws {Error} MISSING_API_KEY_ERROR - Thrown if `pluginApiKey` is not `false` and no API key\n *   can be found either in the `pluginApiKey` argument or from the environment.\n */\nexport function checkApiKey(\n  pluginApiKey: string | false | undefined\n): string | undefined {\n  let apiKey: string | undefined;\n\n  // Don't get the key from the environment if pluginApiKey is false\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n\n  // If pluginApiKey is false, then we don't throw because we are waiting for\n  // the apiKey passed into the individual call\n  if (pluginApiKey !== false && !apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\n\n/**\n * Calculates and returns the effective API key based on multiple potential sources.\n * The order of precedence for determining the API key is:\n * 1. `requestApiKey` (if provided)\n * 2. `pluginApiKey` (if provided and not `false`)\n * 3. Environment variable (if `pluginApiKey` is not `false` and `pluginApiKey` is not provided)\n *\n * @param pluginApiKey - The apiKey value provided during plugin initialization.\n * @param requestApiKey - The apiKey provided to an individual generate call.\n * @returns The resolved API key as a string.\n * @throws {Error} API_KEY_FALSE_ERROR - Thrown if `pluginApiKey` is `false` and `requestApiKey` is not provided\n * @throws {Error} MISSING_API_KEY_ERROR - Thrown if no API key can be resolved from any source\n */\nexport function calculateApiKey(\n  pluginApiKey: string | false | undefined,\n  requestApiKey: string | undefined\n): string {\n  let apiKey: string | undefined;\n\n  // Don't get the key from the environment if pluginApiKey is false\n  if (pluginApiKey !== false) {\n    apiKey = pluginApiKey || getApiKeyFromEnvVar();\n  }\n\n  apiKey = requestApiKey || apiKey;\n\n  if (pluginApiKey === false && !requestApiKey) {\n    throw API_KEY_FALSE_ERROR;\n  }\n\n  if (!apiKey) {\n    throw MISSING_API_KEY_ERROR;\n  }\n  return apiKey;\n}\n\n/** Vertex Express Mode lets you try a *subset* of Vertex AI features */\nexport function checkSupportedResourceMethod(params: {\n  clientOptions: ClientOptions;\n  resourcePath?: string;\n  resourceMethod?: string;\n}) {\n  if (params.resourcePath == '') {\n    // This is how we get a base url for metadata\n    return;\n  }\n\n  const supportedExpressMethods = [\n    'countTokens',\n    'generateContent',\n    'streamGenerateContent',\n  ];\n\n  if (\n    params.clientOptions.kind === 'express' &&\n    (!supportedExpressMethods.includes(params.resourceMethod ?? '') ||\n      params.resourcePath?.includes('endpoints/'))\n  ) {\n    throw NOT_SUPPORTED_IN_EXPRESS_ERROR;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3215, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/vertexai/client.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenkitError, StatusName } from 'genkit';\nimport { logger } from 'genkit/logging';\nimport { GoogleAuth } from 'google-auth-library';\nimport {\n  extractErrMsg,\n  getGenkitClientHeader,\n  processStream,\n} from '../common/utils.js';\nimport {\n  ClientOptions,\n  EmbedContentRequest,\n  EmbedContentResponse,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GenerateContentStreamResult,\n  ImagenPredictRequest,\n  ImagenPredictResponse,\n  ListModelsResponse,\n  LyriaPredictRequest,\n  LyriaPredictResponse,\n  Model,\n  VeoOperation,\n  VeoOperationRequest,\n  VeoPredictRequest,\n} from './types.js';\nimport { calculateApiKey, checkSupportedResourceMethod } from './utils.js';\n\nexport async function listModels(\n  clientOptions: ClientOptions\n): Promise<Model[]> {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: false,\n    resourcePath: 'publishers/google/models',\n    clientOptions,\n  });\n  const fetchOptions = await getFetchOptions({\n    method: 'GET',\n    clientOptions,\n  });\n  const response = await makeRequest(url, fetchOptions);\n  const modelResponse = (await response.json()) as ListModelsResponse;\n  return modelResponse.publisherModels;\n}\n\nexport async function generateContent(\n  model: string,\n  generateContentRequest: GenerateContentRequest,\n  clientOptions: ClientOptions\n): Promise<GenerateContentResponse> {\n  let url: string;\n  if (model.includes('endpoints/')) {\n    // Tuned model\n    url = getVertexAIUrl({\n      includeProjectAndLocation: !model.startsWith('projects/'),\n      resourcePath: model,\n      resourceMethod: 'generateContent',\n      clientOptions,\n    });\n  } else {\n    url = getVertexAIUrl({\n      includeProjectAndLocation: true,\n      resourcePath: `publishers/google/models/${model}`,\n      resourceMethod: 'generateContent',\n      clientOptions,\n    });\n  }\n  const fetchOptions = await getFetchOptions({\n    method: 'POST',\n    clientOptions,\n    body: JSON.stringify(generateContentRequest),\n  });\n  const response = await makeRequest(url, fetchOptions);\n\n  const responseJson = (await response.json()) as GenerateContentResponse;\n  return responseJson;\n}\n\nexport async function generateContentStream(\n  model: string,\n  generateContentRequest: GenerateContentRequest,\n  clientOptions: ClientOptions\n): Promise<GenerateContentStreamResult> {\n  let url: string;\n  if (model.includes('endpoints/')) {\n    // Tuned model\n    url = getVertexAIUrl({\n      includeProjectAndLocation: !model.startsWith('projects/'),\n      resourcePath: model,\n      resourceMethod: 'streamGenerateContent',\n      clientOptions,\n    });\n  } else {\n    url = getVertexAIUrl({\n      includeProjectAndLocation: true,\n      resourcePath: `publishers/google/models/${model}`,\n      resourceMethod: 'streamGenerateContent',\n      clientOptions,\n    });\n  }\n  const fetchOptions = await getFetchOptions({\n    method: 'POST',\n    clientOptions,\n    body: JSON.stringify(generateContentRequest),\n  });\n  const response = await makeRequest(url, fetchOptions);\n  return processStream(response);\n}\n\nasync function internalPredict(\n  model: string,\n  body: string,\n  clientOptions: ClientOptions\n): Promise<Response> {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: true,\n    resourcePath: `publishers/google/models/${model}`,\n    resourceMethod: 'predict',\n    clientOptions,\n  });\n\n  const fetchOptions = await getFetchOptions({\n    method: 'POST',\n    clientOptions,\n    body,\n  });\n\n  return await makeRequest(url, fetchOptions);\n}\n\nexport async function embedContent(\n  model: string,\n  embedContentRequest: EmbedContentRequest,\n  clientOptions: ClientOptions\n): Promise<EmbedContentResponse> {\n  const response = await internalPredict(\n    model,\n    JSON.stringify(embedContentRequest),\n    clientOptions\n  );\n  return response.json() as Promise<EmbedContentResponse>;\n}\n\nexport async function imagenPredict(\n  model: string,\n  imagenPredictRequest: ImagenPredictRequest,\n  clientOptions: ClientOptions\n): Promise<ImagenPredictResponse> {\n  const response = await internalPredict(\n    model,\n    JSON.stringify(imagenPredictRequest),\n    clientOptions\n  );\n  return response.json() as Promise<ImagenPredictResponse>;\n}\n\nexport async function lyriaPredict(\n  model: string,\n  lyriaPredictRequest: LyriaPredictRequest,\n  clientOptions: ClientOptions\n): Promise<LyriaPredictResponse> {\n  const response = await internalPredict(\n    model,\n    JSON.stringify(lyriaPredictRequest),\n    clientOptions\n  );\n  return response.json() as Promise<LyriaPredictResponse>;\n}\n\nexport async function veoPredict(\n  model: string,\n  veoPredictRequest: VeoPredictRequest,\n  clientOptions: ClientOptions\n): Promise<VeoOperation> {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: true,\n    resourcePath: `publishers/google/models/${model}`,\n    resourceMethod: 'predictLongRunning',\n    clientOptions,\n  });\n\n  const fetchOptions = await getFetchOptions({\n    method: 'POST',\n    clientOptions,\n    body: JSON.stringify(veoPredictRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  const operation = await response.json();\n  operation.clientOptions = clientOptions; // for the check\n  return operation as Promise<VeoOperation>;\n}\n\nexport async function veoCheckOperation(\n  model: string,\n  veoOperationRequest: VeoOperationRequest,\n  clientOptions: ClientOptions\n): Promise<VeoOperation> {\n  const url = getVertexAIUrl({\n    includeProjectAndLocation: true,\n    resourcePath: `publishers/google/models/${model}`,\n    resourceMethod: 'fetchPredictOperation',\n    clientOptions,\n  });\n  const fetchOptions = await getFetchOptions({\n    method: 'POST',\n    clientOptions,\n    body: JSON.stringify(veoOperationRequest),\n  });\n\n  const response = await makeRequest(url, fetchOptions);\n  const operation = await response.json();\n  operation.clientOptions = clientOptions; // for future checks\n  return operation as Promise<VeoOperation>;\n}\n\nexport function getVertexAIUrl(params: {\n  includeProjectAndLocation: boolean; // False for listModels, true for most others\n  resourcePath: string;\n  resourceMethod?: string;\n  queryParams?: string;\n  clientOptions: ClientOptions;\n}): string {\n  checkSupportedResourceMethod(params);\n\n  const DEFAULT_API_VERSION = 'v1beta1';\n  const API_BASE_PATH = 'aiplatform.googleapis.com';\n\n  let basePath: string;\n\n  if (params.clientOptions.kind == 'regional') {\n    basePath = `${params.clientOptions.location}-${API_BASE_PATH}`;\n  } else {\n    basePath = API_BASE_PATH;\n  }\n\n  let resourcePath = params.resourcePath;\n  if (\n    params.clientOptions.kind != 'express' &&\n    params.includeProjectAndLocation\n  ) {\n    const parent = `projects/${params.clientOptions.projectId}/locations/${params.clientOptions.location}`;\n    resourcePath = `${parent}/${params.resourcePath}`;\n  }\n\n  let url = `https://${basePath}/${DEFAULT_API_VERSION}/${resourcePath}`;\n  if (params.resourceMethod) {\n    url += `:${params.resourceMethod}`;\n  }\n\n  let joiner = '?';\n  if (params.queryParams) {\n    url += `${joiner}${params.queryParams}`;\n    joiner = '&';\n  }\n  if (params.resourceMethod === 'streamGenerateContent') {\n    url += `${joiner}alt=sse`;\n    joiner = '&';\n  }\n  return url;\n}\n\nasync function getFetchOptions(params: {\n  method: 'POST' | 'GET';\n  body?: string;\n  clientOptions: ClientOptions;\n}) {\n  const fetchOptions: RequestInit = {\n    method: params.method,\n    headers: await getHeaders(params.clientOptions),\n  };\n  if (params.body) {\n    fetchOptions.body = params.body;\n  }\n  const signal = getAbortSignal(params.clientOptions);\n  if (signal) {\n    fetchOptions.signal = signal;\n  }\n  return fetchOptions;\n}\n\nfunction getAbortSignal(clientOptions: ClientOptions): AbortSignal | undefined {\n  const hasTimeout = (clientOptions.timeout ?? -1) >= 0;\n  if (clientOptions.signal !== undefined || hasTimeout) {\n    const controller = new AbortController();\n    if (hasTimeout) {\n      setTimeout(() => controller.abort(), clientOptions.timeout);\n    }\n    if (clientOptions?.signal) {\n      clientOptions.signal.addEventListener('abort', () => {\n        controller.abort();\n      });\n    }\n    return controller.signal;\n  }\n  return undefined;\n}\n\nasync function getHeaders(clientOptions: ClientOptions): Promise<HeadersInit> {\n  if (clientOptions.kind == 'express') {\n    const headers: HeadersInit = {\n      'x-goog-api-key': calculateApiKey(clientOptions.apiKey, undefined),\n      'Content-Type': 'application/json',\n      'X-Goog-Api-Client': getGenkitClientHeader(),\n      'User-Agent': getGenkitClientHeader(),\n    };\n    return headers;\n  } else {\n    const token = await getToken(clientOptions.authClient);\n    const headers: HeadersInit = {\n      Authorization: `Bearer ${token}`,\n      'x-goog-user-project': clientOptions.projectId,\n      'Content-Type': 'application/json',\n      'X-Goog-Api-Client': getGenkitClientHeader(),\n      'User-Agent': getGenkitClientHeader(),\n    };\n    if (clientOptions.apiKey) {\n      headers['x-goog-api-key'] = clientOptions.apiKey;\n    }\n    return headers;\n  }\n}\n\nasync function getToken(authClient: GoogleAuth): Promise<string> {\n  const CREDENTIAL_ERROR_MESSAGE =\n    '\\nUnable to authenticate your request\\\n        \\nDepending on your run time environment, you can get authentication by\\\n        \\n- if in local instance or cloud shell: `!gcloud auth login`\\\n        \\n- if in Colab:\\\n        \\n    -`from google.colab import auth`\\\n        \\n    -`auth.authenticate_user()`\\\n        \\n- if in service account or other: please follow guidance in https://cloud.google.com/docs/authentication';\n  const token = await authClient.getAccessToken().catch((e) => {\n    throw new Error(CREDENTIAL_ERROR_MESSAGE, e);\n  });\n  if (!token) {\n    throw new Error(CREDENTIAL_ERROR_MESSAGE);\n  }\n  return token;\n}\n\nasync function makeRequest(\n  url: string,\n  fetchOptions: RequestInit\n): Promise<Response> {\n  try {\n    const response = await fetch(url, fetchOptions);\n    if (!response.ok) {\n      let errorText = await response.text();\n      let errorMessage = errorText;\n      try {\n        const json = JSON.parse(errorText);\n        if (json.error && json.error.message) {\n          errorMessage = json.error.message;\n        }\n      } catch (e) {\n        // Not JSON or expected format, use the raw text\n      }\n      let status: StatusName = 'UNKNOWN';\n      switch (response.status) {\n        case 429:\n          status = 'RESOURCE_EXHAUSTED';\n          break;\n        case 400:\n          status = 'INVALID_ARGUMENT';\n          break;\n        case 500:\n          status = 'INTERNAL';\n          break;\n        case 503:\n          status = 'UNAVAILABLE';\n          break;\n      }\n      throw new GenkitError({\n        status,\n        message: `Error fetching from ${url}: [${response.status} ${response.statusText}] ${errorMessage}`,\n      });\n    }\n    return response;\n  } catch (e: unknown) {\n    logger.error(e);\n    if (e instanceof GenkitError) {\n      throw e;\n    }\n    throw new Error(`Failed to fetch from ${url}: ${extractErrMsg(e)}`);\n  }\n}\n\nexport const TEST_ONLY = {\n  getFetchOptions,\n  getAbortSignal,\n  getHeaders,\n  makeRequest,\n};\n"],"names":["import_utils"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,iBAAA,CAAA;AAAA,SAAA,gBAAA;IAAA,WAAA,IAAA;IAAA,cAAA,IAAA;IAAA,iBAAA,IAAA;IAAA,uBAAA,IAAA;IAAA,gBAAA,IAAA;IAAA,eAAA,IAAA;IAAA,YAAA,IAAA;IAAA,cAAA,IAAA;IAAA,mBAAA,IAAA;IAAA,YAAA,IAAA;AAAA;AAAA,OAAA,OAAA,GAAA,aAAA;AAgBA,IAAA,gBAAwC;AACxC,IAAA,iBAAuB;AAEvB,IAAA,eAIO;AAkBP,IAAAA,gBAA8D;AAE9D,eAAsB,WACpB,aAAA,EACkB;IAClB,MAAM,MAAM,eAAe;QACzB,2BAA2B;QAC3B,cAAc;QACd;IACF,CAAC;IACD,MAAM,eAAe,MAAM,gBAAgB;QACzC,QAAQ;QACR;IACF,CAAC;IACD,MAAM,WAAW,MAAM,YAAY,KAAK,YAAY;IACpD,MAAM,gBAAiB,MAAM,SAAS,IAAA,CAAK;IAC3C,OAAO,cAAc,eAAA;AACvB;AAEA,eAAsB,gBACpB,KAAA,EACA,sBAAA,EACA,aAAA,EACkC;IAClC,IAAI;IACJ,IAAI,MAAM,QAAA,CAAS,YAAY,GAAG;QAEhC,MAAM,eAAe;YACnB,2BAA2B,CAAC,MAAM,UAAA,CAAW,WAAW;YACxD,cAAc;YACd,gBAAgB;YAChB;QACF,CAAC;IACH,OAAO;QACL,MAAM,eAAe;YACnB,2BAA2B;YAC3B,cAAc,CAAA,yBAAA,EAA4B,KAAK,EAAA;YAC/C,gBAAgB;YAChB;QACF,CAAC;IACH;IACA,MAAM,eAAe,MAAM,gBAAgB;QACzC,QAAQ;QACR;QACA,MAAM,KAAK,SAAA,CAAU,sBAAsB;IAC7C,CAAC;IACD,MAAM,WAAW,MAAM,YAAY,KAAK,YAAY;IAEpD,MAAM,eAAgB,MAAM,SAAS,IAAA,CAAK;IAC1C,OAAO;AACT;AAEA,eAAsB,sBACpB,KAAA,EACA,sBAAA,EACA,aAAA,EACsC;IACtC,IAAI;IACJ,IAAI,MAAM,QAAA,CAAS,YAAY,GAAG;QAEhC,MAAM,eAAe;YACnB,2BAA2B,CAAC,MAAM,UAAA,CAAW,WAAW;YACxD,cAAc;YACd,gBAAgB;YAChB;QACF,CAAC;IACH,OAAO;QACL,MAAM,eAAe;YACnB,2BAA2B;YAC3B,cAAc,CAAA,yBAAA,EAA4B,KAAK,EAAA;YAC/C,gBAAgB;YAChB;QACF,CAAC;IACH;IACA,MAAM,eAAe,MAAM,gBAAgB;QACzC,QAAQ;QACR;QACA,MAAM,KAAK,SAAA,CAAU,sBAAsB;IAC7C,CAAC;IACD,MAAM,WAAW,MAAM,YAAY,KAAK,YAAY;IACpD,OAAA,CAAA,GAAO,aAAA,aAAA,EAAc,QAAQ;AAC/B;AAEA,eAAe,gBACb,KAAA,EACA,IAAA,EACA,aAAA,EACmB;IACnB,MAAM,MAAM,eAAe;QACzB,2BAA2B;QAC3B,cAAc,CAAA,yBAAA,EAA4B,KAAK,EAAA;QAC/C,gBAAgB;QAChB;IACF,CAAC;IAED,MAAM,eAAe,MAAM,gBAAgB;QACzC,QAAQ;QACR;QACA;IACF,CAAC;IAED,OAAO,MAAM,YAAY,KAAK,YAAY;AAC5C;AAEA,eAAsB,aACpB,KAAA,EACA,mBAAA,EACA,aAAA,EAC+B;IAC/B,MAAM,WAAW,MAAM,gBACrB,OACA,KAAK,SAAA,CAAU,mBAAmB,GAClC;IAEF,OAAO,SAAS,IAAA,CAAK;AACvB;AAEA,eAAsB,cACpB,KAAA,EACA,oBAAA,EACA,aAAA,EACgC;IAChC,MAAM,WAAW,MAAM,gBACrB,OACA,KAAK,SAAA,CAAU,oBAAoB,GACnC;IAEF,OAAO,SAAS,IAAA,CAAK;AACvB;AAEA,eAAsB,aACpB,KAAA,EACA,mBAAA,EACA,aAAA,EAC+B;IAC/B,MAAM,WAAW,MAAM,gBACrB,OACA,KAAK,SAAA,CAAU,mBAAmB,GAClC;IAEF,OAAO,SAAS,IAAA,CAAK;AACvB;AAEA,eAAsB,WACpB,KAAA,EACA,iBAAA,EACA,aAAA,EACuB;IACvB,MAAM,MAAM,eAAe;QACzB,2BAA2B;QAC3B,cAAc,CAAA,yBAAA,EAA4B,KAAK,EAAA;QAC/C,gBAAgB;QAChB;IACF,CAAC;IAED,MAAM,eAAe,MAAM,gBAAgB;QACzC,QAAQ;QACR;QACA,MAAM,KAAK,SAAA,CAAU,iBAAiB;IACxC,CAAC;IAED,MAAM,WAAW,MAAM,YAAY,KAAK,YAAY;IACpD,MAAM,YAAY,MAAM,SAAS,IAAA,CAAK;IACtC,UAAU,aAAA,GAAgB;IAC1B,OAAO;AACT;AAEA,eAAsB,kBACpB,KAAA,EACA,mBAAA,EACA,aAAA,EACuB;IACvB,MAAM,MAAM,eAAe;QACzB,2BAA2B;QAC3B,cAAc,CAAA,yBAAA,EAA4B,KAAK,EAAA;QAC/C,gBAAgB;QAChB;IACF,CAAC;IACD,MAAM,eAAe,MAAM,gBAAgB;QACzC,QAAQ;QACR;QACA,MAAM,KAAK,SAAA,CAAU,mBAAmB;IAC1C,CAAC;IAED,MAAM,WAAW,MAAM,YAAY,KAAK,YAAY;IACpD,MAAM,YAAY,MAAM,SAAS,IAAA,CAAK;IACtC,UAAU,aAAA,GAAgB;IAC1B,OAAO;AACT;AAEO,SAAS,eAAe,MAAA,EAMpB;IACT,CAAA,GAAA,cAAA,4BAAA,EAA6B,MAAM;IAEnC,MAAM,sBAAsB;IAC5B,MAAM,gBAAgB;IAEtB,IAAI;IAEJ,IAAI,OAAO,aAAA,CAAc,IAAA,IAAQ,YAAY;QAC3C,WAAW,GAAG,OAAO,aAAA,CAAc,QAAQ,CAAA,CAAA,EAAI,aAAa,EAAA;IAC9D,OAAO;QACL,WAAW;IACb;IAEA,IAAI,eAAe,OAAO,YAAA;IAC1B,IACE,OAAO,aAAA,CAAc,IAAA,IAAQ,aAC7B,OAAO,yBAAA,EACP;QACA,MAAM,SAAS,CAAA,SAAA,EAAY,OAAO,aAAA,CAAc,SAAS,CAAA,WAAA,EAAc,OAAO,aAAA,CAAc,QAAQ,EAAA;QACpG,eAAe,GAAG,MAAM,CAAA,CAAA,EAAI,OAAO,YAAY,EAAA;IACjD;IAEA,IAAI,MAAM,CAAA,QAAA,EAAW,QAAQ,CAAA,CAAA,EAAI,mBAAmB,CAAA,CAAA,EAAI,YAAY,EAAA;IACpE,IAAI,OAAO,cAAA,EAAgB;QACzB,OAAO,CAAA,CAAA,EAAI,OAAO,cAAc,EAAA;IAClC;IAEA,IAAI,SAAS;IACb,IAAI,OAAO,WAAA,EAAa;QACtB,OAAO,GAAG,MAAM,GAAG,OAAO,WAAW,EAAA;QACrC,SAAS;IACX;IACA,IAAI,OAAO,cAAA,KAAmB,yBAAyB;QACrD,OAAO,GAAG,MAAM,CAAA,OAAA,CAAA;QAChB,SAAS;IACX;IACA,OAAO;AACT;AAEA,eAAe,gBAAgB,MAAA,EAI5B;IACD,MAAM,eAA4B;QAChC,QAAQ,OAAO,MAAA;QACf,SAAS,MAAM,WAAW,OAAO,aAAa;IAChD;IACA,IAAI,OAAO,IAAA,EAAM;QACf,aAAa,IAAA,GAAO,OAAO,IAAA;IAC7B;IACA,MAAM,SAAS,eAAe,OAAO,aAAa;IAClD,IAAI,QAAQ;QACV,aAAa,MAAA,GAAS;IACxB;IACA,OAAO;AACT;AAEA,SAAS,eAAe,aAAA,EAAuD;IAC7E,MAAM,aAAA,CAAc,cAAc,OAAA,IAAW,CAAA,CAAA,KAAO;IACpD,IAAI,cAAc,MAAA,KAAW,KAAA,KAAa,YAAY;QACpD,MAAM,aAAa,IAAI,gBAAgB;QACvC,IAAI,YAAY;YACd,WAAW,IAAM,WAAW,KAAA,CAAM,GAAG,cAAc,OAAO;QAC5D;QACA,IAAI,eAAe,QAAQ;YACzB,cAAc,MAAA,CAAO,gBAAA,CAAiB,SAAS,MAAM;gBACnD,WAAW,KAAA,CAAM;YACnB,CAAC;QACH;QACA,OAAO,WAAW,MAAA;IACpB;IACA,OAAO,KAAA;AACT;AAEA,eAAe,WAAW,aAAA,EAAoD;IAC5E,IAAI,cAAc,IAAA,IAAQ,WAAW;QACnC,MAAM,UAAuB;YAC3B,kBAAA,CAAA,GAAkB,cAAA,eAAA,EAAgB,cAAc,MAAA,EAAQ,KAAA,CAAS;YACjE,gBAAgB;YAChB,qBAAA,CAAA,GAAqB,aAAA,qBAAA,EAAsB;YAC3C,cAAA,CAAA,GAAc,aAAA,qBAAA,EAAsB;QACtC;QACA,OAAO;IACT,OAAO;QACL,MAAM,QAAQ,MAAM,SAAS,cAAc,UAAU;QACrD,MAAM,UAAuB;YAC3B,eAAe,CAAA,OAAA,EAAU,KAAK,EAAA;YAC9B,uBAAuB,cAAc,SAAA;YACrC,gBAAgB;YAChB,qBAAA,CAAA,GAAqB,aAAA,qBAAA,EAAsB;YAC3C,cAAA,CAAA,GAAc,aAAA,qBAAA,EAAsB;QACtC;QACA,IAAI,cAAc,MAAA,EAAQ;YACxB,OAAA,CAAQ,gBAAgB,CAAA,GAAI,cAAc,MAAA;QAC5C;QACA,OAAO;IACT;AACF;AAEA,eAAe,SAAS,UAAA,EAAyC;IAC/D,MAAM,2BACJ;IAOF,MAAM,QAAQ,MAAM,WAAW,cAAA,CAAe,EAAE,KAAA,CAAM,CAAC,MAAM;QAC3D,MAAM,IAAI,MAAM,0BAA0B,CAAC;IAC7C,CAAC;IACD,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM,wBAAwB;IAC1C;IACA,OAAO;AACT;AAEA,eAAe,YACb,GAAA,EACA,YAAA,EACmB;IACnB,IAAI;QACF,MAAM,WAAW,MAAM,MAAM,KAAK,YAAY;QAC9C,IAAI,CAAC,SAAS,EAAA,EAAI;YAChB,IAAI,YAAY,MAAM,SAAS,IAAA,CAAK;YACpC,IAAI,eAAe;YACnB,IAAI;gBACF,MAAM,OAAO,KAAK,KAAA,CAAM,SAAS;gBACjC,IAAI,KAAK,KAAA,IAAS,KAAK,KAAA,CAAM,OAAA,EAAS;oBACpC,eAAe,KAAK,KAAA,CAAM,OAAA;gBAC5B;YACF,EAAA,OAAS,GAAG,CAEZ;YACA,IAAI,SAAqB;YACzB,OAAQ,SAAS,MAAA,EAAQ;gBACvB,KAAK;oBACH,SAAS;oBACT;gBACF,KAAK;oBACH,SAAS;oBACT;gBACF,KAAK;oBACH,SAAS;oBACT;gBACF,KAAK;oBACH,SAAS;oBACT;YACJ;YACA,MAAM,IAAI,cAAA,WAAA,CAAY;gBACpB;gBACA,SAAS,CAAA,oBAAA,EAAuB,GAAG,CAAA,GAAA,EAAM,SAAS,MAAM,CAAA,CAAA,EAAI,SAAS,UAAU,CAAA,EAAA,EAAK,YAAY,EAAA;YAClG,CAAC;QACH;QACA,OAAO;IACT,EAAA,OAAS,GAAY;QACnB,eAAA,MAAA,CAAO,KAAA,CAAM,CAAC;QACd,IAAI,aAAa,cAAA,WAAA,EAAa;YAC5B,MAAM;QACR;QACA,MAAM,IAAI,MAAM,CAAA,qBAAA,EAAwB,GAAG,CAAA,EAAA,EAAA,CAAA,GAAK,aAAA,aAAA,EAAc,CAAC,CAAC,EAAE;IACpE;AACF;AAEO,MAAM,YAAY;IACvB;IACA;IACA;IACA;AACF"}},
    {"offset": {"line": 3538, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/vertexai/types.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GoogleAuth, GoogleAuthOptions } from 'google-auth-library';\nimport {\n  CitationMetadata,\n  CodeExecutionTool,\n  Content,\n  FunctionCallingMode,\n  FunctionDeclarationsTool,\n  GenerateContentCandidate,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GenerateContentStreamResult,\n  GoogleMaps,\n  GoogleMapsTool,\n  GoogleSearchRetrieval,\n  GoogleSearchRetrievalTool,\n  GroundingMetadata,\n  HarmBlockThreshold,\n  HarmCategory,\n  ImagenInstance,\n  ImagenParameters,\n  ImagenPredictRequest,\n  ImagenPredictResponse,\n  ImagenPrediction,\n  RetrievalTool,\n  TaskType,\n  TaskTypeSchema,\n  Tool,\n  ToolConfig,\n  isCodeExecutionTool,\n  isFunctionDeclarationsTool,\n  isGoogleMapsTool,\n  isGoogleSearchRetrievalTool,\n  isObject,\n  isRetrievalTool,\n} from '../common/types.js';\n\n// This makes it easier to import all types from one place\nexport {\n  FunctionCallingMode,\n  HarmBlockThreshold,\n  HarmCategory,\n  TaskTypeSchema,\n  isCodeExecutionTool,\n  isFunctionDeclarationsTool,\n  isGoogleMapsTool,\n  isGoogleSearchRetrievalTool,\n  isObject,\n  isRetrievalTool,\n  type CitationMetadata,\n  type CodeExecutionTool,\n  type Content,\n  type FunctionDeclarationsTool,\n  type GenerateContentCandidate,\n  type GenerateContentRequest,\n  type GenerateContentResponse,\n  type GenerateContentStreamResult,\n  type GoogleMaps,\n  type GoogleMapsTool,\n  type GoogleSearchRetrieval,\n  type GoogleSearchRetrievalTool,\n  type GroundingMetadata,\n  type ImagenInstance,\n  type ImagenParameters,\n  type ImagenPredictRequest,\n  type ImagenPredictResponse,\n  type ImagenPrediction,\n  type RetrievalTool,\n  type Tool,\n  type ToolConfig,\n};\n\n/** Options for Vertex AI plugin configuration */\nexport interface VertexPluginOptions {\n  /** The Vertex API key for express mode */\n  apiKey?: string | false;\n  /** The Google Cloud project id to call. */\n  projectId?: string;\n  /** The Google Cloud region to call. */\n  location?: string;\n  /** Provide custom authentication configuration for connecting to Vertex AI. */\n  googleAuth?: GoogleAuthOptions;\n  /** Enables additional debug traces (e.g. raw model API call details). */\n  experimental_debugTraces?: boolean;\n  /** Use `responseSchema` field instead of `responseJsonSchema`. */\n  legacyResponseSchema?: boolean;\n}\n\ninterface BaseClientOptions {\n  /** timeout in milli seconds. time out value needs to be non negative. */\n  timeout?: number;\n  signal?: AbortSignal;\n}\n\nexport interface RegionalClientOptions extends BaseClientOptions {\n  kind: 'regional';\n  location: string;\n  projectId: string;\n  authClient: GoogleAuth;\n  apiKey?: string; // In addition to regular auth\n}\n\nexport interface GlobalClientOptions extends BaseClientOptions {\n  kind: 'global';\n  location: 'global';\n  projectId: string;\n  authClient: GoogleAuth;\n  apiKey?: string; // In addition to regular auth\n}\n\nexport interface ExpressClientOptions extends BaseClientOptions {\n  kind: 'express';\n  apiKey: string | false | undefined; // Instead of regular auth\n}\n\n/** Resolved options for use with the client */\nexport type ClientOptions =\n  | RegionalClientOptions\n  | GlobalClientOptions\n  | ExpressClientOptions;\n\n/**\n * Request options params.\n */\nexport interface RequestOptions {\n  /** an apiKey to use for this request if applicable */\n  apiKey?: string | false | undefined;\n  /** timeout in milli seconds. time out value needs to be non negative. */\n  timeout?: number;\n  /**\n   * Version of API endpoint to call (e.g. \"v1\" or \"v1beta\"). If not specified,\n   * defaults to 'v1beta'.\n   */\n  apiVersion?: string;\n  /**\n   * Value for x-goog-api-client header to set on the API request. This is\n   * intended for wrapper SDKs to set additional SDK identifiers for the\n   * backend.\n   */\n  apiClient?: string;\n  /**\n   * Value for custom HTTP headers to set on the HTTP request.\n   */\n  customHeaders?: Headers;\n}\n\n// Vertex AI  model definition\nexport interface Model {\n  name: string;\n  launchStage: string;\n}\n\n// Vertex AI list models response\nexport interface ListModelsResponse {\n  publisherModels: Model[];\n}\n\n// https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/text-embeddings-api#request_body\ninterface TextEmbeddingInstance {\n  task_type?: TaskType;\n  content: string;\n  title?: string;\n}\n\n// https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/multimodal-embeddings-api#request_body\ninterface MultimodalEmbeddingInstance {\n  text?: string;\n  image?: {\n    // Union field can only be one of the following:\n    bytesBase64Encoded?: string;\n    gcsUri?: string;\n    // End of list of possible types for union field.\n    mimeType?: string;\n  };\n  video?: {\n    // Union field can only be one of the following:\n    bytesBase64Encoded?: string;\n    gcsUri?: string;\n    // End of list of possible types for union field.\n    videoSegmentConfig?: {\n      startOffsetSec: number;\n      endOffsetSec: number;\n      intervalSec: number;\n    };\n  };\n  parameters?: {\n    dimension: number;\n  };\n}\n\nexport declare type EmbeddingInstance =\n  | TextEmbeddingInstance\n  | MultimodalEmbeddingInstance;\n\nexport declare interface TextEmbeddingPrediction {\n  embeddings: {\n    statistics: {\n      truncated: boolean;\n      token_count: number;\n    };\n    values: number[];\n  };\n}\n\nexport declare interface VideoEmbedding {\n  startOffsetSec: number;\n  endOffsetSec: number;\n  embedding: number[];\n}\n\nexport declare interface MultimodalEmbeddingPrediction {\n  textEmbedding?: number[];\n  imageEmbedding?: number[];\n  videoEmbeddings?: VideoEmbedding[];\n}\n\nexport function isMultimodalEmbeddingPrediction(\n  value: unknown\n): value is MultimodalEmbeddingPrediction {\n  if (!isObject(value)) {\n    return false;\n  }\n  if (!value.textEmbedding && !value.imageEmbedding && !value.videoEmbeddings) {\n    return false;\n  }\n  if (value.textEmbedding && !Array.isArray(value.textEmbedding)) {\n    return false;\n  }\n  if (value.imageEmbedding && !Array.isArray(value.imageEmbedding)) {\n    return false;\n  }\n  if (value.videoEmbeddings && !Array.isArray(value.videoEmbeddings)) {\n    return false;\n  }\n  if (value.videoEmbeddings) {\n    for (const emb of value.videoEmbeddings as Array<unknown>) {\n      if (!isObject(emb)) {\n        return false;\n      }\n      if (!emb.embedding || !Array.isArray(emb.embedding)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nexport declare type EmbeddingPrediction =\n  | TextEmbeddingPrediction\n  | MultimodalEmbeddingPrediction;\n\nexport declare interface EmbedContentRequest {\n  instances: EmbeddingInstance[];\n  parameters: EmbedContentConfig;\n}\n\nexport declare interface EmbedContentResponse {\n  predictions: EmbeddingPrediction[];\n}\n\n/** Optional parameters for the embed content method. */\nexport declare interface EmbedContentConfig {\n  /** Type of task for which the embedding will be used. */\n  taskType?: string;\n  /** Title for the text. Only applicable when TaskType is\n      `RETRIEVAL_DOCUMENT`.\n       */\n  title?: string;\n  /** Reduced dimension for the output embedding. If set,\n      excessive values in the output embedding are truncated from the end.\n      Supported by newer models since 2024 only. You cannot set this value if\n      using the earlier model (`models/embedding-001`).\n       */\n  outputDimensionality?: number;\n  /** The MIME type of the input. */\n  mimeType?: string;\n  /** Vertex API only. Whether to silently truncate inputs longer than\n      the max sequence length. If this option is set to false, oversized inputs\n      will lead to an INVALID_ARGUMENT error, similar to other text APIs.\n       */\n  autoTruncate?: boolean;\n}\n\nexport declare type EmbeddingResult = {\n  embedding: number[];\n  metadata?: Record<string, unknown>;\n};\n\nexport declare interface VeoMedia {\n  bytesBase64Encoded?: string;\n  gcsUri?: string;\n  mimeType?: string;\n}\n\nexport declare interface VeoReferenceImage {\n  image: VeoMedia;\n  referenceType: string;\n}\n\nexport declare interface VeoMask extends VeoMedia {\n  mask: string;\n}\n\nexport declare interface VeoInstance {\n  prompt: string;\n  image?: VeoMedia;\n  lastFrame?: VeoMedia;\n  video?: VeoMedia;\n  referenceImages?: VeoReferenceImage[];\n}\n\nexport declare interface VeoParameters {\n  aspectRatio?: string;\n  durationSeconds?: number;\n  enhancePrompt?: boolean;\n  generateAudio?: boolean;\n  negativePrompt?: string;\n  personGeneration?: string;\n  resolution?: string; // Veo 3\n  sampleCount?: number;\n  seed?: number;\n  storageUri?: string;\n}\n\nexport declare interface VeoPredictRequest {\n  instances: VeoInstance[];\n  parameters: VeoParameters;\n}\n\nexport declare interface Operation {\n  name: string;\n  done?: boolean;\n  error?: {\n    code: number;\n    message: string;\n    details?: unknown;\n  };\n  clientOptions?: ClientOptions; // Added so we can call check with the same ones\n}\n\nexport declare interface VeoOperation extends Operation {\n  response?: {\n    raiMediaFilteredCount?: number;\n    videos: VeoMedia[];\n  };\n}\n\nexport declare interface VeoOperationRequest {\n  operationName: string;\n}\n\nexport declare interface LyriaParameters {\n  sampleCount?: number;\n}\n\nexport declare interface LyriaPredictRequest {\n  instances: LyriaInstance[];\n  parameters: LyriaParameters;\n}\n\nexport declare interface LyriaPredictResponse {\n  predictions: LyriaPrediction[];\n}\n\nexport declare interface LyriaPrediction {\n  bytesBase64Encoded: string; // Base64 encoded Wav string\n  mimeType: string; // audio/wav\n}\n\nexport declare interface LyriaInstance {\n  prompt: string;\n  negativePrompt?: string;\n  seed?: number;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,gBAAA,CAAA;AAAA,SAAA,eAAA;IAAA,qBAAA,IAAA,aAAA,mBAAA;IAAA,oBAAA,IAAA,aAAA,kBAAA;IAAA,cAAA,IAAA,aAAA,YAAA;IAAA,gBAAA,IAAA,aAAA,cAAA;IAAA,qBAAA,IAAA,aAAA,mBAAA;IAAA,4BAAA,IAAA,aAAA,0BAAA;IAAA,kBAAA,IAAA,aAAA,gBAAA;IAAA,6BAAA,IAAA,aAAA,2BAAA;IAAA,iCAAA,IAAA;IAAA,UAAA,IAAA,aAAA,QAAA;IAAA,iBAAA,IAAA,aAAA,eAAA;AAAA;AAAA,OAAA,OAAA,GAAA,aAAA;AAiBA,IAAA,eAiCO;AAqLA,SAAS,gCACd,KAAA,EACwC;IACxC,IAAI,CAAA,CAAA,GAAC,aAAA,QAAA,EAAS,KAAK,GAAG;QACpB,OAAO;IACT;IACA,IAAI,CAAC,MAAM,aAAA,IAAiB,CAAC,MAAM,cAAA,IAAkB,CAAC,MAAM,eAAA,EAAiB;QAC3E,OAAO;IACT;IACA,IAAI,MAAM,aAAA,IAAiB,CAAC,MAAM,OAAA,CAAQ,MAAM,aAAa,GAAG;QAC9D,OAAO;IACT;IACA,IAAI,MAAM,cAAA,IAAkB,CAAC,MAAM,OAAA,CAAQ,MAAM,cAAc,GAAG;QAChE,OAAO;IACT;IACA,IAAI,MAAM,eAAA,IAAmB,CAAC,MAAM,OAAA,CAAQ,MAAM,eAAe,GAAG;QAClE,OAAO;IACT;IACA,IAAI,MAAM,eAAA,EAAiB;QACzB,KAAA,MAAW,OAAO,MAAM,eAAA,CAAmC;YACzD,IAAI,CAAA,CAAA,GAAC,aAAA,QAAA,EAAS,GAAG,GAAG;gBAClB,OAAO;YACT;YACA,IAAI,CAAC,IAAI,SAAA,IAAa,CAAC,MAAM,OAAA,CAAQ,IAAI,SAAS,GAAG;gBACnD,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 3622, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/vertexai/embedder.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { z, type Document } from 'genkit';\nimport {\n  EmbedderInfo,\n  embedderRef,\n  type EmbedderAction,\n  type EmbedderReference,\n} from 'genkit/embedder';\nimport { embedder as pluginEmbedder } from 'genkit/plugin';\nimport { embedContent } from './client.js';\nimport {\n  ClientOptions,\n  EmbedContentRequest,\n  EmbeddingInstance,\n  EmbeddingPrediction,\n  EmbeddingResult,\n  TaskTypeSchema,\n  VertexPluginOptions,\n  isMultimodalEmbeddingPrediction,\n  isObject,\n} from './types.js';\nimport { checkModelName, extractVersion } from './utils.js';\n\nexport const EmbeddingConfigSchema = z\n  .object({\n    /**\n     * The `task_type` parameter is defined as the intended downstream application\n     * to help the model produce better quality embeddings.\n     **/\n    taskType: TaskTypeSchema.optional(),\n    title: z.string().optional(),\n    location: z.string().optional(),\n    version: z.string().optional(),\n    /**\n     * The `outputDimensionality` parameter allows you to specify the dimensionality of the embedding output.\n     * By default, the model generates embeddings with 768 dimensions.\n     * By selecting a smaller output dimensionality, users can save memory and storage space, leading to more efficient computations.\n     **/\n    outputDimensionality: z.number().min(1).optional(),\n    /**\n     * For newly released embedders this parameter provides a hint for the proper\n     * way to call the embedder. (Multimodal embedders have a different request\n     * structure than non-multimodal embedders).\n     * For well-known embedders, this value will be ignored since we will already\n     * know if it's multimodal or not.\n     */\n    multimodal: z.boolean().optional(),\n  })\n  .passthrough();\nexport type EmbeddingConfigSchemaType = typeof EmbeddingConfigSchema;\nexport type EmbeddingConfig = z.infer<EmbeddingConfigSchemaType>;\n\n// for commonRef\ntype ConfigSchemaType = EmbeddingConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: EmbedderInfo,\n  configSchema: ConfigSchemaType = EmbeddingConfigSchema\n): EmbedderReference<ConfigSchemaType> {\n  return embedderRef({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      dimensions: 768,\n      supports: {\n        input: ['text'],\n      },\n    },\n  });\n}\n\nconst GENERIC_TEXT_MODEL = commonRef('text', {\n  dimensions: 3072,\n  supports: { input: ['text'] },\n});\nconst GENERIC_MULTIMODAL_MODEL = commonRef('multimodal', {\n  dimensions: 768,\n  supports: { input: ['text', 'image', 'video'] },\n});\n\nexport const KNOWN_MODELS = {\n  'text-embedding-005': commonRef('text-embedding-005'),\n  'text-multilingual-embedding-002': commonRef(\n    'text-multilingual-embedding-002'\n  ),\n  'multimodalembedding@001': commonRef('multimodalembedding@001', {\n    dimensions: 768,\n    supports: { input: ['text', 'image', 'video'] },\n  }),\n  'gemini-embedding-001': commonRef('gemini-embedding-001', {\n    dimensions: 3072,\n    supports: { input: ['text'] },\n  }),\n} as const;\n\nexport function model(\n  version: string,\n  config: EmbeddingConfig = {}\n): EmbedderReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  if (KNOWN_MODELS[name]) {\n    return embedderRef({\n      name: `vertexai/${name}`,\n      configSchema: EmbeddingConfigSchema,\n      config,\n      info: {\n        ...KNOWN_MODELS[name].info,\n      },\n    });\n  }\n  if (config.multimodal) {\n    // Generic multimodal embedder format\n    return embedderRef({\n      name: `vertexai/${name}`,\n      configSchema: EmbeddingConfigSchema,\n      config,\n      info: {\n        ...GENERIC_MULTIMODAL_MODEL.info,\n      },\n    });\n  }\n  // Generic text-only embedder format\n  return embedderRef({\n    name: `vertexai/${name}`,\n    configSchema: EmbeddingConfigSchema,\n    config,\n    info: {\n      ...GENERIC_TEXT_MODEL.info,\n    },\n  });\n}\n\nexport function listKnownModels(\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n) {\n  return Object.keys(KNOWN_MODELS).map((name) =>\n    defineEmbedder(name, clientOptions, pluginOptions)\n  );\n}\n\nexport function defineEmbedder(\n  name: string,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n): EmbedderAction<any> {\n  const ref = model(name);\n\n  return pluginEmbedder(\n    {\n      name: ref.name,\n      configSchema: ref.configSchema,\n      info: ref.info!,\n    },\n    async (request) => {\n      const embedContentRequest: EmbedContentRequest = {\n        instances: request.input.map((doc: Document) =>\n          toEmbeddingInstance(ref, doc, request.options)\n        ),\n        parameters: {\n          outputDimensionality: request.options?.outputDimensionality,\n        },\n      };\n\n      const response = await embedContent(\n        extractVersion(ref),\n        embedContentRequest,\n        clientOptions\n      );\n\n      return {\n        embeddings: response.predictions\n          .map(toEmbeddingResult)\n          .reduce((accumulator, value) => {\n            return accumulator.concat(value);\n          }, []),\n      };\n    }\n  );\n}\n\nfunction toEmbeddingInstance(\n  embedder: EmbedderReference<ConfigSchemaType>,\n  doc: Document,\n  options?: EmbeddingConfig\n): EmbeddingInstance {\n  let instance: EmbeddingInstance;\n  if (\n    isMultiModalEmbedder(embedder) ||\n    embedder.config?.multimodal ||\n    options?.multimodal\n  ) {\n    instance = {};\n    if (doc.text) {\n      instance.text = doc.text;\n    }\n    for (var media of doc.media) {\n      if (\n        isObject(media) &&\n        typeof media.url === 'string' &&\n        typeof media.contentType === 'string'\n      ) {\n        if (media.contentType?.startsWith('image/')) {\n          if (media.url.startsWith('http') || media.url.startsWith('gs://')) {\n            instance.image = {\n              gcsUri: media.url,\n              mimeType: media.contentType,\n            };\n          } else {\n            instance.image = {\n              bytesBase64Encoded: media.url,\n              mimeType: media.contentType,\n            };\n          }\n        } else if (media.contentType.startsWith('video/')) {\n          if (media.url.startsWith('http') || media.url.startsWith('gs://')) {\n            instance.video = {\n              gcsUri: media.url,\n            };\n          } else {\n            instance.video = {\n              bytesBase64Encoded: media.url,\n            };\n          }\n          if (\n            instance.video &&\n            doc.metadata &&\n            doc.metadata.videoSegmentConfig\n          ) {\n            instance.video.videoSegmentConfig = doc.metadata.videoSegmentConfig;\n          }\n        } else {\n          throw new Error(`Unsupported contentType: '${media.contentType}`);\n        }\n      } else {\n        // It needs to be a {url:string, contentType:string} object.\n        throw new Error('Invalid media specified.');\n      }\n    }\n  } else {\n    // Text only embedder\n    instance = {\n      content: doc.text,\n      task_type: options?.taskType,\n      title: options?.title,\n    };\n  }\n  return instance;\n}\n\n/**\n * Converts an `EmbeddingPrediction` object to an array of `EmbeddingResult` objects.\n *\n * There will only be multiple EmbeddingResult objects in the array if it is a\n * multimodal embedding prediction for a video.\n * A single video gets automatically broken into chunks and an embedding is\n * returned for each chunk. The metadata identifies which chunk of the video\n * it is for.\n *\n * @param prediction The input `EmbeddingPrediction` object.\n * @returns An array of `EmbeddingResult` objects, each representing a different embedding.\n */\nfunction toEmbeddingResult(prediction: EmbeddingPrediction): EmbeddingResult[] {\n  if (isMultimodalEmbeddingPrediction(prediction)) {\n    const eArray: EmbeddingResult[] = [];\n    if (prediction.imageEmbedding?.length) {\n      const imageResult: EmbeddingResult = {\n        embedding: prediction.imageEmbedding,\n        metadata: { embedType: 'imageEmbedding' },\n      };\n      eArray.push(imageResult);\n    }\n    if (prediction.textEmbedding?.length) {\n      const textResult: EmbeddingResult = {\n        embedding: prediction.textEmbedding,\n        metadata: { embedType: 'textEmbedding' },\n      };\n      eArray.push(textResult);\n    }\n    if (prediction.videoEmbeddings?.length) {\n      for (const ve of prediction.videoEmbeddings) {\n        if (ve.embedding?.length) {\n          const { embedding, ...metadata } = ve;\n          (metadata as Record<string, unknown>).embedType = 'videoEmbedding';\n          const videoResult: EmbeddingResult = {\n            embedding,\n            metadata,\n          };\n          eArray.push(videoResult);\n        }\n      }\n    }\n    return eArray;\n  } else {\n    // Text-only embedding\n    return [\n      {\n        embedding: prediction.embeddings.values,\n      },\n    ];\n  }\n}\n\nfunction isMultiModalEmbedder(\n  embedder: EmbedderReference<ConfigSchemaType>\n): boolean {\n  if (embedder.config?.multimodal) {\n    return true;\n  }\n  const input = embedder.info?.supports?.input || '';\n  return (input.includes('text') && input.includes('image')) || false;\n}\n\nexport const TEST_ONLY = { KNOWN_MODELS };\n"],"names":["pluginEmbedder"],"mappings":"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"}},
    {"offset": {"line": 3906, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/vertexai/converters.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  GenerateRequest,\n  GenerateResponseData,\n  GenkitError,\n  MediaPart,\n  Operation,\n  z,\n} from 'genkit';\nimport { CandidateData, getBasicUsageStats } from 'genkit/model';\nimport {\n  HarmBlockThreshold,\n  HarmCategory,\n  ImagenInstance,\n  ImagenParameters,\n  ImagenPredictRequest,\n  ImagenPredictResponse,\n  ImagenPrediction,\n  SafetySetting,\n} from '../common/types.js';\nimport { extractMediaArray } from '../common/utils.js';\nimport { SafetySettingsSchema } from './gemini.js';\nimport { ImagenConfigSchemaType } from './imagen.js';\nimport { LyriaConfigSchemaType } from './lyria.js';\nimport {\n  ClientOptions,\n  LyriaInstance,\n  LyriaParameters,\n  LyriaPredictRequest,\n  LyriaPredictResponse,\n  LyriaPrediction,\n  VeoInstance,\n  VeoMedia,\n  VeoOperation,\n  VeoOperationRequest,\n  VeoPredictRequest,\n} from './types.js';\nimport {\n  checkSupportedMimeType,\n  extractMedia,\n  extractMimeType,\n  extractText,\n} from './utils.js';\nimport { VeoConfigSchemaType } from './veo.js';\n\nexport function toGeminiSafetySettings(\n  genkitSettings?: z.infer<typeof SafetySettingsSchema>[]\n): SafetySetting[] | undefined {\n  if (!genkitSettings) return undefined;\n  return genkitSettings.map((s) => {\n    return {\n      category: s.category as HarmCategory,\n      threshold: s.threshold as HarmBlockThreshold,\n    };\n  });\n}\n\nexport function toGeminiLabels(\n  labels?: Record<string, string>\n): Record<string, string> | undefined {\n  if (!labels) {\n    return undefined;\n  }\n  const keys = Object.keys(labels);\n  const newLabels: Record<string, string> = {};\n  for (const key of keys) {\n    const value = labels[key];\n    if (!key) {\n      continue;\n    }\n    newLabels[key] = value;\n  }\n\n  if (Object.keys(newLabels).length == 0) {\n    return undefined;\n  }\n  return newLabels;\n}\n\nexport function toImagenPredictRequest(\n  request: GenerateRequest<ImagenConfigSchemaType>\n): ImagenPredictRequest {\n  return {\n    instances: toImagenInstances(request),\n    parameters: toImagenParameters(request),\n  };\n}\n\nfunction toImagenInstances(\n  request: GenerateRequest<ImagenConfigSchemaType>\n): ImagenInstance[] {\n  let instance: ImagenInstance = {\n    prompt: extractText(request),\n  };\n\n  const imageMedia = extractMedia(request, {\n    metadataType: 'image',\n    isDefault: true,\n  });\n  if (imageMedia) {\n    const image = imageMedia.url.split(',')[1];\n    instance.image = {\n      bytesBase64Encoded: image,\n    };\n  }\n\n  const maskMedia = extractMedia(request, { metadataType: 'mask' });\n  if (maskMedia) {\n    const mask = maskMedia.url.split(',')[1];\n    instance.mask = {\n      image: {\n        bytesBase64Encoded: mask,\n      },\n    };\n  }\n\n  return [instance];\n}\n\nfunction toImagenParameters(\n  request: GenerateRequest<ImagenConfigSchemaType>\n): ImagenParameters {\n  const params = {\n    sampleCount: request.candidates ?? 1,\n    ...request?.config,\n  };\n\n  for (const k in params) {\n    if (!params[k]) delete params[k];\n  }\n\n  return params;\n}\n\nfunction fromImagenPrediction(p: ImagenPrediction, i: number): CandidateData {\n  const b64data = p.bytesBase64Encoded;\n  const mimeType = p.mimeType;\n  return {\n    index: i,\n    finishReason: 'stop',\n    message: {\n      role: 'model',\n      content: [\n        {\n          media: {\n            url: `data:${mimeType};base64,${b64data}`,\n            contentType: mimeType,\n          },\n        },\n      ],\n    },\n  };\n}\n\n/**\n *\n * @param response The response to convert\n * @param request The request (for usage stats)\n * @returns The converted response\n */\nexport function fromImagenResponse(\n  response: ImagenPredictResponse,\n  request: GenerateRequest\n): GenerateResponseData {\n  const candidates = response.predictions.map(fromImagenPrediction);\n  return {\n    candidates,\n    usage: {\n      ...getBasicUsageStats(request.messages, candidates),\n      custom: { generations: candidates.length },\n    },\n    custom: response,\n  };\n}\n\nexport function toLyriaPredictRequest(\n  request: GenerateRequest<LyriaConfigSchemaType>\n): LyriaPredictRequest {\n  return {\n    instances: toLyriaInstances(request),\n    parameters: toLyriaParameters(request),\n  };\n}\n\nfunction toLyriaInstances(\n  request: GenerateRequest<LyriaConfigSchemaType>\n): LyriaInstance[] {\n  let config = { ...request.config };\n  delete config.sampleCount; // Sample count goes in parameters, the rest go in instances\n  return [\n    {\n      prompt: extractText(request),\n      ...config,\n    },\n  ];\n}\n\nfunction toLyriaParameters(\n  request: GenerateRequest<LyriaConfigSchemaType>\n): LyriaParameters {\n  return {\n    sampleCount: request.config?.sampleCount || 1,\n  };\n}\n\nfunction fromLyriaPrediction(p: LyriaPrediction, i: number): CandidateData {\n  const b64data = p.bytesBase64Encoded;\n  const mimeType = p.mimeType;\n  return {\n    index: i,\n    finishReason: 'stop',\n    message: {\n      role: 'model',\n      content: [\n        {\n          media: {\n            url: `data:${mimeType};base64,${b64data}`,\n            contentType: mimeType,\n          },\n        },\n      ],\n    },\n  };\n}\n\nexport function fromLyriaResponse(\n  response: LyriaPredictResponse,\n  request: GenerateRequest\n): GenerateResponseData {\n  const candidates: CandidateData[] =\n    response.predictions.map(fromLyriaPrediction);\n  return {\n    candidates,\n    usage: {\n      ...getBasicUsageStats(request.messages, candidates),\n      custom: { generations: candidates.length },\n    },\n    custom: response,\n  };\n}\n\nexport function toVeoPredictRequest(\n  request: GenerateRequest<VeoConfigSchemaType>\n): VeoPredictRequest {\n  return {\n    instances: toVeoInstances(request),\n    parameters: { ...request.config },\n  };\n}\n\nfunction toVeoInstances(\n  request: GenerateRequest<VeoConfigSchemaType>\n): VeoInstance[] {\n  let instance: VeoInstance = {\n    prompt: extractText(request),\n  };\n\n  const supportedImageTypes = ['image/jpeg', 'image/png', 'image/webp'];\n  const supportedVideoTypes = [\n    'video/mov',\n    'video/mpeg',\n    'video/mp4',\n    'video/mpg',\n    'video/avi',\n    'video/wmv',\n    'video/mpegps',\n    'video/flv',\n  ];\n\n  const imageMedia = extractMedia(request, {\n    metadataType: 'image',\n    isDefault: true,\n  });\n  if (imageMedia) {\n    checkSupportedMimeType(imageMedia, supportedImageTypes);\n    instance.image = toVeoMedia(imageMedia);\n  }\n\n  const lastFrameMedia = extractMedia(request, { metadataType: 'lastFrame' });\n  if (lastFrameMedia) {\n    checkSupportedMimeType(lastFrameMedia, supportedImageTypes);\n    instance.lastFrame = toVeoMedia(lastFrameMedia);\n  }\n\n  const videoMedia = extractMedia(request, { metadataType: 'video' });\n  if (videoMedia) {\n    checkSupportedMimeType(videoMedia, supportedVideoTypes);\n    instance.video = toVeoMedia(videoMedia);\n  }\n\n  const referenceImages = extractMediaArray(request, {\n    metadataType: 'referenceImages',\n  });\n  if (referenceImages) {\n    instance.referenceImages = referenceImages.map((refImage) => ({\n      image: toVeoMedia(refImage.media),\n      referenceType: refImage.metadata?.referenceType as string,\n    }));\n  }\n\n  return [instance];\n}\n\nexport function toVeoMedia(media: MediaPart['media']): VeoMedia {\n  let mimeType = media.contentType;\n  if (!mimeType) {\n    mimeType = extractMimeType(media.url);\n    if (!mimeType) {\n      throw new GenkitError({\n        status: 'INVALID_ARGUMENT',\n        message: 'Content type is required.',\n      });\n    }\n  }\n  if (media.url.startsWith('data:')) {\n    return {\n      bytesBase64Encoded: media.url?.split(',')[1],\n      mimeType,\n    };\n  } else if (media.url.startsWith('gs://')) {\n    return {\n      gcsUri: media.url,\n      mimeType,\n    };\n  } else if (media.url.startsWith('http')) {\n    throw new GenkitError({\n      status: 'INVALID_ARGUMENT',\n      message:\n        'Veo does not support http(s) URIs. Please specify a Cloud Storage URI.',\n    });\n  } else {\n    // Assume it's a non-prefixed data url\n    return {\n      bytesBase64Encoded: media.url,\n      mimeType,\n    };\n  }\n}\n\nexport function fromVeoOperation(\n  fromOp: VeoOperation\n): Operation<GenerateResponseData> {\n  const toOp: Operation<GenerateResponseData> = { id: fromOp.name };\n  if (fromOp.done !== undefined) {\n    toOp.done = fromOp.done;\n  }\n  if (fromOp.error) {\n    toOp.error = { message: fromOp.error.message };\n  }\n  if (fromOp.clientOptions) {\n    toOp.metadata = {\n      clientOptions: fromOp.clientOptions,\n    };\n  }\n\n  if (fromOp.response) {\n    toOp.output = {\n      finishReason: 'stop',\n      raw: fromOp.response,\n      message: {\n        role: 'model',\n        content: fromOp.response.videos.map((veoMedia) => {\n          if (veoMedia.bytesBase64Encoded) {\n            return {\n              media: {\n                url: `data:${veoMedia.mimeType}:base64,${veoMedia.bytesBase64Encoded}`,\n                contentType: veoMedia.mimeType,\n              },\n            };\n          }\n\n          return {\n            media: {\n              url: veoMedia.gcsUri ?? '',\n              contentType: veoMedia.mimeType,\n            },\n          };\n        }),\n      },\n    };\n  }\n\n  return toOp;\n}\n\nexport function toVeoModel(op: Operation<GenerateResponseData>): string {\n  return op.id.substring(\n    op.id.indexOf('models/') + 7,\n    op.id.indexOf('/operations/')\n  );\n}\n\nexport function toVeoOperationRequest(\n  op: Operation<GenerateResponseData>\n): VeoOperationRequest {\n  return {\n    operationName: op.id,\n  };\n}\n\nexport function toVeoClientOptions(\n  op: Operation<GenerateResponseData>,\n  clientOpt: ClientOptions\n): ClientOptions {\n  return op.metadata?.clientOptions ?? clientOpt;\n}\n"],"names":["import_utils"],"mappings":"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"}},
    {"offset": {"line": 4276, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/vertexai/gemini.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ActionMetadata, GenkitError, modelActionMetadata, z } from 'genkit';\nimport {\n  CandidateData,\n  GenerationCommonConfigDescriptions,\n  GenerationCommonConfigSchema,\n  ModelAction,\n  ModelInfo,\n  ModelMiddleware,\n  ModelReference,\n  getBasicUsageStats,\n  modelRef,\n} from 'genkit/model';\nimport { downloadRequestMedia } from 'genkit/model/middleware';\nimport { model as pluginModel } from 'genkit/plugin';\nimport { runInNewSpan } from 'genkit/tracing';\nimport {\n  fromGeminiCandidate,\n  toGeminiFunctionModeEnum,\n  toGeminiMessage,\n  toGeminiSystemInstruction,\n  toGeminiTool,\n} from '../common/converters.js';\nimport {\n  generateContent,\n  generateContentStream,\n  getVertexAIUrl,\n} from './client.js';\nimport { toGeminiLabels, toGeminiSafetySettings } from './converters.js';\nimport {\n  ClientOptions,\n  Content,\n  GenerateContentRequest,\n  GenerateContentResponse,\n  GoogleSearchRetrieval,\n  GoogleSearchRetrievalTool,\n  Model,\n  Tool,\n  ToolConfig,\n  VertexPluginOptions,\n} from './types.js';\nimport {\n  calculateRequestOptions,\n  checkModelName,\n  cleanSchema,\n  extractVersion,\n  modelName,\n} from './utils.js';\n\nexport const SafetySettingsSchema = z\n  .object({\n    category: z.enum([\n      /** The harm category is unspecified. */\n      'HARM_CATEGORY_UNSPECIFIED',\n      /** The harm category is hate speech. */\n      'HARM_CATEGORY_HATE_SPEECH',\n      /** The harm category is dangerous content. */\n      'HARM_CATEGORY_DANGEROUS_CONTENT',\n      /** The harm category is harassment. */\n      'HARM_CATEGORY_HARASSMENT',\n      /** The harm category is sexually explicit content. */\n      'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n    ]),\n    threshold: z.enum([\n      'BLOCK_LOW_AND_ABOVE',\n      'BLOCK_MEDIUM_AND_ABOVE',\n      'BLOCK_ONLY_HIGH',\n      'BLOCK_NONE',\n    ]),\n  })\n  .passthrough();\n\nconst VertexRetrievalSchema = z\n  .object({\n    datastore: z\n      .object({\n        projectId: z.string().describe('Google Cloud Project ID.').optional(),\n        location: z\n          .string()\n          .describe('Google Cloud region e.g. us-central1.')\n          .optional(),\n        dataStoreId: z\n          .string()\n          .describe(\n            'The data store id, when project id and location are provided as ' +\n              'separate options. Alternatively, the full path to the data ' +\n              'store should be provided in the form: \"projects/{project}/' +\n              'locations/{location}/collections/default_collection/dataStores/{data_store}\".'\n          ),\n      })\n      .describe('Vertex AI Search data store details')\n      .passthrough(),\n    disableAttribution: z\n      .boolean()\n      .describe(\n        'Disable using the search data in detecting grounding attribution. This ' +\n          'does not affect how the result is given to the model for generation.'\n      )\n      .optional(),\n  })\n  .passthrough();\n\nconst GoogleSearchRetrievalSchema = z\n  .object({\n    disableAttribution: z\n      .boolean()\n      .describe(\n        'Disable using the search data in detecting grounding attribution. This ' +\n          'does not affect how the result is given to the model for generation.'\n      )\n      .optional(),\n  })\n  .passthrough();\n\n/**\n * Zod schema of Gemini model options.\n * Please refer to: https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference#generationconfig, for further information.\n */\nexport const GeminiConfigSchema = GenerationCommonConfigSchema.extend({\n  apiKey: z\n    .string()\n    .describe('Overrides the plugin-configured API key, if specified.')\n    .optional(),\n  labels: z\n    .record(z.string())\n    .optional()\n    .describe('Key-value labels to attach to the request for cost tracking.'),\n  temperature: z\n    .number()\n    .min(0.0)\n    .max(2.0)\n    .describe(\n      GenerationCommonConfigDescriptions.temperature +\n        ' The default value is 1.0.'\n    )\n    .optional(),\n  topP: z\n    .number()\n    .min(0)\n    .max(1.0)\n    .describe(\n      GenerationCommonConfigDescriptions.topP + ' The default value is 0.95.'\n    )\n    .optional(),\n  location: z\n    .string()\n    .describe('Google Cloud region e.g. us-central1.')\n    .optional(),\n\n  /**\n   * Safety filter settings. See: https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/configure-safety-filters#configurable-filters\n   *\n   * E.g.\n   *\n   * ```js\n   * config: {\n   *   safetySettings: [\n   *     {\n   *       category: 'HARM_CATEGORY_HATE_SPEECH',\n   *       threshold: 'BLOCK_LOW_AND_ABOVE',\n   *     },\n   *     {\n   *       category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\n   *       threshold: 'BLOCK_MEDIUM_AND_ABOVE',\n   *     },\n   *     {\n   *       category: 'HARM_CATEGORY_HARASSMENT',\n   *       threshold: 'BLOCK_ONLY_HIGH',\n   *     },\n   *     {\n   *       category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n   *       threshold: 'BLOCK_NONE',\n   *     },\n   *   ],\n   * }\n   * ```\n   */\n  safetySettings: z\n    .array(SafetySettingsSchema)\n    .describe(\n      'Adjust how likely you are to see responses that could be harmful. ' +\n        'Content is blocked based on the probability that it is harmful.'\n    )\n    .optional(),\n\n  /**\n   * Vertex retrieval options.\n   *\n   * E.g.\n   *\n   * ```js\n   *   config: {\n   *     vertexRetrieval: {\n   *       datastore: {\n   *         projectId: 'your-cloud-project',\n   *         location: 'us-central1',\n   *         collection: 'your-collection',\n   *       },\n   *       disableAttribution: true,\n   *     }\n   *   }\n   * ```\n   */\n  vertexRetrieval: VertexRetrievalSchema.describe(\n    'Retrieve from Vertex AI Search data store for grounding ' +\n      'generative responses.'\n  ).optional(),\n\n  /**\n   * Google Search retrieval options.\n   *\n   * ```js\n   *   config: {\n   *     googleSearchRetrieval: {\n   *       disableAttribution: true,\n   *     }\n   *   }\n   * ```\n   */\n  googleSearchRetrieval: GoogleSearchRetrievalSchema.describe(\n    'Retrieve public web data for grounding, powered by Google Search.'\n  ).optional(),\n\n  /**\n   * Function calling options.\n   *\n   * E.g. forced tool call:\n   *\n   * ```js\n   *   config: {\n   *     functionCallingConfig: {\n   *       mode: 'ANY',\n   *     }\n   *   }\n   * ```\n   */\n  functionCallingConfig: z\n    .object({\n      mode: z.enum(['MODE_UNSPECIFIED', 'AUTO', 'ANY', 'NONE']).optional(),\n      allowedFunctionNames: z.array(z.string()).optional(),\n      /**\n       * When set to true, arguments of a single function call will be streamed out in\n       * multiple parts/contents/responses. Partial parameter results will be returned in the\n       * [FunctionCall.partial_args] field. This field is not supported in Gemini API.\n       */\n      streamFunctionCallArguments: z.boolean().optional(),\n    })\n    .describe(\n      'Controls how the model uses the provided tools (function declarations). ' +\n        'With AUTO (Default) mode, the model decides whether to generate a ' +\n        'natural language response or suggest a function call based on the ' +\n        'prompt and context. With ANY, the model is constrained to always ' +\n        'predict a function call and guarantee function schema adherence. ' +\n        'With NONE, the model is prohibited from making function calls.'\n    )\n    .passthrough()\n    .optional(),\n  /**\n   * Retrieval config for search grounding and maps grounding\n   */\n  retrievalConfig: z\n    .object({\n      /**\n       * User location for search grounding or\n       * place location for maps grounding.\n       */\n      latLng: z\n        .object({\n          latitude: z.number().optional(),\n          longitude: z.number().optional(),\n        })\n        .describe('User location for Google search or Google maps grounding.')\n        .optional(),\n      /**\n       * Language code for the request. e.g. 'en-us'\n       */\n      languageCode: z.string().optional(),\n    })\n    .passthrough()\n    .optional(),\n  thinkingConfig: z\n    .object({\n      includeThoughts: z\n        .boolean()\n        .describe(\n          'Indicates whether to include thoughts in the response.' +\n            'If true, thoughts are returned only if the model supports ' +\n            'thought and thoughts are available.'\n        )\n        .optional(),\n      thinkingBudget: z\n        .number()\n        .min(0)\n        .max(24576)\n        .describe(\n          'For Gemini 2.5 - Indicates the thinking budget in tokens. 0 is DISABLED. ' +\n            '-1 is AUTOMATIC. The default values and allowed ranges are model ' +\n            'dependent. The thinking budget parameter gives the model guidance ' +\n            'on the number of thinking tokens it can use when generating a ' +\n            'response. A greater number of tokens is typically associated with ' +\n            'more detailed thinking, which is needed for solving more complex ' +\n            'tasks. '\n        )\n        .optional(),\n      thinkingLevel: z\n        .enum(['LOW', 'MEDIUM', 'HIGH'])\n        .describe(\n          'For Gemini 3.0 - Indicates the thinking level. A higher level ' +\n            'is associated with more detailed thinking, which is needed for solving ' +\n            'more complex tasks.'\n        )\n        .optional(),\n    })\n    .passthrough()\n    .optional(),\n}).passthrough();\nexport type GeminiConfigSchemaType = typeof GeminiConfigSchema;\n/**\n * Gemini model configuration options.\n *\n * E.g.\n * ```js\n *   config: {\n *     temperature: 0.9,\n *     maxOutputTokens: 300,\n *     safetySettings: [\n *       {\n *         category: 'HARM_CATEGORY_HATE_SPEECH',\n *         threshold: 'BLOCK_LOW_AND_ABOVE',\n *       },\n *       {\n *         category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\n *         threshold: 'BLOCK_MEDIUM_AND_ABOVE',\n *       },\n *       {\n *         category: 'HARM_CATEGORY_HARASSMENT',\n *         threshold: 'BLOCK_ONLY_HIGH',\n *       },\n *       {\n *         category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n *         threshold: 'BLOCK_NONE',\n *       },\n *     ],\n *     functionCallingConfig: {\n *       mode: 'ANY',\n *     }\n *   }\n * ```\n */\nexport type GeminiConfig = z.infer<GeminiConfigSchemaType>;\n\nexport const GeminiImageConfigSchema = GeminiConfigSchema.extend({\n  imageConfig: z\n    .object({\n      aspectRatio: z\n        .enum([\n          '1:1',\n          '2:3',\n          '3:2',\n          '3:4',\n          '4:3',\n          '4:5',\n          '5:4',\n          '9:16',\n          '16:9',\n          '21:9',\n        ])\n        .optional(),\n      imageSize: z.enum(['1K', '2K', '4K']).optional(),\n    })\n    .passthrough()\n    .optional(),\n}).passthrough();\nexport type GeminiImageConfigSchemaType = typeof GeminiImageConfigSchema;\nexport type GeminiImageConfig = z.infer<GeminiImageConfigSchemaType>;\n\n// This contains all the Gemini config schema types\ntype ConfigSchemaType = GeminiConfigSchemaType | GeminiImageConfigSchemaType;\ntype ConfigSchema = z.infer<ConfigSchemaType>;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = GeminiConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        multiturn: true,\n        media: true,\n        tools: true,\n        toolChoice: true,\n        systemRole: true,\n        constrained: 'no-tools',\n      },\n    },\n  });\n}\n\nconst GENERIC_MODEL = commonRef('gemini');\nconst GENERIC_IMAGE_MODEL = commonRef(\n  'gemini-image',\n  undefined,\n  GeminiImageConfigSchema\n);\n\nexport const KNOWN_GEMINI_MODELS = {\n  'gemini-3-pro-preview': commonRef('gemini-3-pro-preview'),\n  'gemini-2.5-flash-lite': commonRef('gemini-2.5-flash-lite'),\n  'gemini-2.5-pro': commonRef('gemini-2.5-pro'),\n  'gemini-2.5-flash': commonRef('gemini-2.5-flash'),\n  'gemini-2.0-flash-001': commonRef('gemini-2.0-flash-001'),\n  'gemini-2.0-flash': commonRef('gemini-2.0-flash'),\n  'gemini-2.0-flash-lite': commonRef('gemini-2.0-flash-lite'),\n  'gemini-2.0-flash-lite-001': commonRef('gemini-2.0-flash-lite-001'),\n} as const;\nexport type KnownGeminiModels = keyof typeof KNOWN_GEMINI_MODELS;\nexport type GeminiModelName = `gemini-${string}`;\nexport function isGeminiModelName(value?: string): value is GeminiModelName {\n  return !!(\n    value?.startsWith('gemini-') &&\n    !value.includes('embedding') &&\n    !value.includes('-image')\n  );\n}\n\nexport const KNOWN_IMAGE_MODELS = {\n  'gemini-3-pro-image-preview': commonRef(\n    'gemini-3-pro-image-preview',\n    { ...GENERIC_IMAGE_MODEL.info },\n    GeminiImageConfigSchema\n  ),\n  'gemini-2.5-flash-image': commonRef(\n    'gemini-2.5-flash-image',\n    undefined,\n    GeminiImageConfigSchema\n  ),\n} as const;\nexport type KnownImageModels = keyof typeof KNOWN_IMAGE_MODELS;\nexport type ImageModelName = `gemini-${string}-image${string}`;\nexport function isImageModelName(value?: string): value is ImageModelName {\n  return !!(value?.startsWith('gemini-') && value.includes('-image'));\n}\n\nconst KNOWN_MODELS = {\n  ...KNOWN_GEMINI_MODELS,\n  ...KNOWN_IMAGE_MODELS,\n};\nexport type KnownModels = keyof typeof KNOWN_MODELS;\n\nexport function model(\n  version: string,\n  config: ConfigSchema = {}\n): ModelReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n\n  if (isImageModelName(name)) {\n    return modelRef({\n      name: `vertexai/${name}`,\n      config,\n      configSchema: GeminiImageConfigSchema,\n      info: { ...GENERIC_IMAGE_MODEL.info },\n    });\n  }\n\n  return modelRef({\n    name: `vertexai/${name}`,\n    config,\n    configSchema: GeminiConfigSchema,\n    info: {\n      ...GENERIC_MODEL.info,\n    },\n  });\n}\n\nexport function listActions(models: Model[]): ActionMetadata[] {\n  const KNOWN_DECOMISSIONED_MODELS = [\n    'gemini-pro-vision',\n    'gemini-pro',\n    'gemini-ultra',\n    'gemini-ultra-vision',\n  ];\n\n  return models\n    .filter(\n      (m) =>\n        (isGeminiModelName(modelName(m.name)) ||\n          isImageModelName(modelName(m.name))) &&\n        !KNOWN_DECOMISSIONED_MODELS.includes(modelName(m.name) || '')\n    )\n    .map((m) => {\n      const ref = model(m.name);\n      return modelActionMetadata({\n        name: ref.name,\n        info: ref.info,\n        configSchema: ref.configSchema,\n      });\n    });\n}\n\nexport function listKnownModels(\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n) {\n  return Object.keys(KNOWN_MODELS).map((name) =>\n    defineModel(name, clientOptions, pluginOptions)\n  );\n}\n\n/**\n * Define a Vertex AI Gemini model.\n */\nexport function defineModel(\n  name: string,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n): ModelAction {\n  const ref = model(name);\n  const middlewares: ModelMiddleware[] = [];\n  if (ref.info?.supports?.media) {\n    // the gemini api doesn't support downloading media from http(s)\n    middlewares.push(\n      downloadRequestMedia({\n        maxBytes: 1024 * 1024 * 20,\n        filter: (part) => {\n          try {\n            const url = new URL(part.media.url);\n            if (\n              // Gemini can handle these URLs\n              ['www.youtube.com', 'youtube.com', 'youtu.be'].includes(\n                url.hostname\n              )\n            )\n              return false;\n          } catch {}\n          return true;\n        },\n      })\n    );\n  }\n\n  return pluginModel(\n    {\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n      use: middlewares,\n    },\n    async (request, { streamingRequested, sendChunk, abortSignal }) => {\n      let clientOpt = { ...clientOptions, signal: abortSignal };\n\n      // Make a copy of messages to avoid side-effects\n      const messages = structuredClone(request.messages);\n      if (messages.length === 0) throw new Error('No messages provided.');\n\n      // Handle system instructions separately\n      let systemInstruction: Content | undefined = undefined;\n      const systemMessage = messages.find((m) => m.role === 'system');\n      if (systemMessage) {\n        messages.splice(messages.indexOf(systemMessage), 1);\n        systemInstruction = toGeminiSystemInstruction(systemMessage);\n      }\n\n      const requestConfig: ConfigSchema = { ...request.config };\n\n      const {\n        apiKey: apiKeyFromConfig,\n        functionCallingConfig,\n        retrievalConfig,\n        version: versionFromConfig,\n        googleSearchRetrieval,\n        tools: toolsFromConfig,\n        vertexRetrieval,\n        location,\n        safetySettings,\n        labels: labelsFromConfig,\n        ...restOfConfig\n      } = requestConfig;\n\n      clientOpt = calculateRequestOptions(clientOpt, {\n        location,\n        apiKey: apiKeyFromConfig,\n      });\n\n      const labels = toGeminiLabels(labelsFromConfig);\n\n      const tools: Tool[] = [];\n      if (request.tools?.length) {\n        tools.push({\n          functionDeclarations: request.tools.map(toGeminiTool),\n        });\n      }\n\n      let toolConfig: ToolConfig | undefined;\n      if (functionCallingConfig) {\n        toolConfig = {\n          functionCallingConfig: {\n            ...functionCallingConfig,\n            allowedFunctionNames: functionCallingConfig.allowedFunctionNames,\n            mode: toGeminiFunctionModeEnum(functionCallingConfig.mode),\n          },\n        };\n      } else if (request.toolChoice) {\n        toolConfig = {\n          functionCallingConfig: {\n            mode: toGeminiFunctionModeEnum(request.toolChoice),\n          },\n        };\n      }\n\n      if (retrievalConfig) {\n        if (!toolConfig) {\n          toolConfig = {};\n        }\n        toolConfig.retrievalConfig = structuredClone(retrievalConfig);\n      }\n\n      // Cannot use tools and function calling at the same time\n      const jsonMode =\n        (request.output?.format === 'json' || !!request.output?.schema) &&\n        tools.length === 0;\n\n      if (toolsFromConfig) {\n        tools.push(...(toolsFromConfig as any[]));\n      }\n\n      if (googleSearchRetrieval) {\n        // Gemini 1.5 models use googleSearchRetrieval, newer models use googleSearch.\n        if (ref.name.startsWith('vertexai/gemini-1.5')) {\n          tools.push({\n            googleSearchRetrieval:\n              googleSearchRetrieval as GoogleSearchRetrieval,\n          } as GoogleSearchRetrievalTool);\n        } else {\n          tools.push({\n            googleSearch: googleSearchRetrieval as GoogleSearchRetrieval,\n          } as GoogleSearchRetrievalTool);\n        }\n      }\n\n      if (vertexRetrieval) {\n        const _projectId =\n          vertexRetrieval.datastore.projectId ||\n          (clientOptions.kind != 'express'\n            ? clientOptions.projectId\n            : undefined);\n        const _location =\n          vertexRetrieval.datastore.location ||\n          (clientOptions.kind == 'regional'\n            ? clientOptions.location\n            : undefined);\n        const _dataStoreId = vertexRetrieval.datastore.dataStoreId;\n        if (!_projectId || !_location || !_dataStoreId) {\n          throw new GenkitError({\n            status: 'INVALID_ARGUMENT',\n            message:\n              'projectId, location and datastoreId are required for vertexRetrieval and could not be determined from configuration',\n          });\n        }\n        const datastore = `projects/${_projectId}/locations/${_location}/collections/default_collection/dataStores/${_dataStoreId}`;\n        tools.push({\n          retrieval: {\n            vertexAiSearch: {\n              datastore,\n            },\n            disableAttribution: vertexRetrieval.disableAttribution,\n          },\n        });\n      }\n\n      const generateContentRequest: GenerateContentRequest = {\n        systemInstruction,\n        generationConfig: {\n          ...restOfConfig,\n          candidateCount: request.candidates || undefined,\n          responseMimeType: jsonMode ? 'application/json' : undefined,\n        },\n        tools,\n        toolConfig,\n        safetySettings: toGeminiSafetySettings(safetySettings),\n        contents: messages.map((message) => toGeminiMessage(message, ref)),\n        labels,\n      };\n\n      const modelVersion = versionFromConfig || extractVersion(ref);\n\n      if (jsonMode && request.output?.constrained) {\n        if (pluginOptions?.legacyResponseSchema) {\n          generateContentRequest.generationConfig!.responseSchema = cleanSchema(\n            request.output.schema\n          );\n        } else {\n          generateContentRequest.generationConfig!.responseJsonSchema =\n            request.output.schema;\n        }\n      }\n\n      const callGemini = async () => {\n        let response: GenerateContentResponse;\n\n        // Handle streaming and non-streaming responses\n        if (streamingRequested) {\n          const result = await generateContentStream(\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n\n          const chunks: CandidateData[] = [];\n          for await (const item of result.stream) {\n            (item as GenerateContentResponse).candidates?.forEach(\n              (candidate) => {\n                const c = fromGeminiCandidate(candidate, chunks);\n                chunks.push(c);\n                sendChunk({\n                  index: c.index,\n                  content: c.message.content,\n                });\n              }\n            );\n          }\n          response = await result.response;\n        } else {\n          response = await generateContent(\n            modelVersion,\n            generateContentRequest,\n            clientOpt\n          );\n        }\n\n        if (!response.candidates?.length) {\n          throw new GenkitError({\n            status: 'FAILED_PRECONDITION',\n            message: 'No valid candidates returned.',\n          });\n        }\n\n        const candidateData = response.candidates.map((c) =>\n          fromGeminiCandidate(c)\n        );\n\n        return {\n          candidates: candidateData,\n          custom: response,\n          usage: {\n            ...getBasicUsageStats(request.messages, candidateData),\n            inputTokens: response.usageMetadata?.promptTokenCount,\n            outputTokens: response.usageMetadata?.candidatesTokenCount,\n            thoughtsTokens: response.usageMetadata?.thoughtsTokenCount,\n            totalTokens: response.usageMetadata?.totalTokenCount,\n            cachedContentTokens:\n              response.usageMetadata?.cachedContentTokenCount,\n          },\n        };\n      };\n\n      // If debugTraces is enabled, we wrap the actual model call with a span,\n      // add raw API params as for input.\n      const msg = toGeminiMessage(messages[messages.length - 1], ref);\n      return pluginOptions?.experimental_debugTraces\n        ? await runInNewSpan(\n            {\n              metadata: {\n                name: streamingRequested ? 'sendMessageStream' : 'sendMessage',\n              },\n            },\n            async (metadata) => {\n              metadata.input = {\n                apiEndpoint: getVertexAIUrl({\n                  includeProjectAndLocation: false,\n                  resourcePath: '',\n                  clientOptions: clientOpt,\n                }),\n                cache: {},\n                model: modelVersion,\n                generateContentOptions: generateContentRequest,\n                parts: msg.parts,\n                options: clientOpt,\n              };\n              const response = await callGemini();\n              metadata.output = response.custom;\n              return response;\n            }\n          )\n        : await callGemini();\n    }\n  );\n}\n\nexport const TEST_ONLY = {\n  KNOWN_GEMINI_MODELS,\n  KNOWN_IMAGE_MODELS,\n  KNOWN_MODELS,\n};\n"],"names":["import_converters","pluginModel"],"mappings":"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"}},
    {"offset": {"line": 4785, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/vertexai/imagen.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ActionMetadata, modelActionMetadata, z } from 'genkit';\nimport {\n  GenerationCommonConfigSchema,\n  ModelAction,\n  ModelInfo,\n  ModelReference,\n  modelRef,\n} from 'genkit/model';\nimport { model as pluginModel } from 'genkit/plugin';\nimport { imagenPredict } from './client.js';\nimport { fromImagenResponse, toImagenPredictRequest } from './converters.js';\nimport { ClientOptions, Model, VertexPluginOptions } from './types.js';\nimport {\n  calculateRequestOptions,\n  checkModelName,\n  extractVersion,\n  modelName,\n} from './utils.js';\n\n/**\n * See https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/imagen-api.\n */\nexport const ImagenConfigSchema = GenerationCommonConfigSchema.extend({\n  // TODO: Remove common config schema extension since Imagen models don't support\n  // most of the common config parameters. Also, add more parameters like sampleCount\n  // from the above reference.\n  language: z\n    .enum(['auto', 'en', 'es', 'hi', 'ja', 'ko', 'pt', 'zh-TW', 'zh', 'zh-CN'])\n    .describe('Language of the prompt text.')\n    .optional(),\n  aspectRatio: z\n    .enum(['1:1', '9:16', '16:9', '3:4', '4:3'])\n    .describe('Desired aspect ratio of the output image.')\n    .optional(),\n  negativePrompt: z\n    .string()\n    .describe(\n      'A description of what to discourage in the generated images. ' +\n        'For example: \"animals\" (removes animals), \"blurry\" ' +\n        '(makes the image clearer), \"text\" (removes text), or ' +\n        '\"cropped\" (removes cropped images).'\n    )\n    .optional(),\n  seed: z\n    .number()\n    .int()\n    .min(1)\n    .max(2147483647)\n    .describe(\n      'Controls the randomization of the image generation process. Use the ' +\n        'same seed across requests to provide consistency, or change it to ' +\n        'introduce variety in the response.'\n    )\n    .optional(),\n  location: z\n    .string()\n    .describe('Google Cloud region e.g. us-central1.')\n    .optional(),\n  personGeneration: z\n    .enum(['dont_allow', 'allow_adult', 'allow_all'])\n    .describe('Control if/how images of people will be generated by the model.')\n    .optional(),\n  safetySetting: z\n    .enum(['block_most', 'block_some', 'block_few', 'block_fewest'])\n    .describe('Adds a filter level to safety filtering.')\n    .optional(),\n  addWatermark: z\n    .boolean()\n    .describe('Add an invisible watermark to the generated images.')\n    .optional(),\n  storageUri: z\n    .string()\n    .describe('Cloud Storage URI to store the generated images.')\n    .optional(),\n  mode: z\n    .enum(['upscale'])\n    .describe('Mode must be set for upscaling requests.')\n    .optional(),\n  /**\n   * Describes the editing intention for the request.\n   *\n   * See https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/imagen-api#edit_images_2 for details.\n   */\n  editConfig: z\n    .object({\n      editMode: z\n        .enum([\n          'inpainting-insert',\n          'inpainting-remove',\n          'outpainting',\n          'product-image',\n        ])\n        .describe('Editing intention for the request.')\n        .optional(),\n      maskMode: z\n        .object({\n          maskType: z\n            .enum(['background', 'foreground', 'semantic'])\n            .describe(\n              '\"background\" automatically generates a mask for all ' +\n                'regions except the primary subject(s) of the image, ' +\n                '\"foreground\" automatically generates a mask for the primary ' +\n                'subjects(s) of the image. \"semantic\" segments one or more ' +\n                'of the segmentation classes using class ID.'\n            ),\n          classes: z\n            .array(z.number())\n            .describe('List of class IDs for segmentation.')\n            .length(5)\n            .optional(),\n        })\n        .describe(\n          'Prompts the model to generate a mask instead of you ' +\n            'needing to provide one. Consequently, when you provide ' +\n            'this parameter you can omit a mask object.'\n        )\n        .passthrough()\n        .optional(),\n      maskDilation: z\n        .number()\n        .describe('Dilation percentage of the mask provided.')\n        .min(0.0)\n        .max(1.0)\n        .optional(),\n      guidanceScale: z\n        .number()\n        .describe(\n          'Controls how much the model adheres to the text prompt. ' +\n            'Large values increase output and prompt alignment, but may ' +\n            'compromise image quality. Suggested values are 0-9 ' +\n            '(low strength), 10-20 (medium strength), 21+ (high strength).'\n        )\n        .optional(),\n      productPosition: z\n        .enum(['reposition', 'fixed'])\n        .describe(\n          'Defines whether the product should stay fixed or be ' +\n            'repositioned.'\n        )\n        .optional(),\n    })\n    .passthrough()\n    .optional(),\n  upscaleConfig: z\n    .object({\n      upscaleFactor: z\n        .enum(['x2', 'x4'])\n        .describe('The factor to upscale the image.'),\n    })\n    .describe('Configuration for upscaling.')\n    .passthrough()\n    .optional(),\n}).passthrough();\nexport type ImagenConfigSchemaType = typeof ImagenConfigSchema;\nexport type ImagenConfig = z.infer<ImagenConfigSchemaType>;\n\n// for commonRef\ntype ConfigSchemaType = ImagenConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = ImagenConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        media: true,\n        multiturn: false,\n        tools: false,\n        toolChoice: false,\n        systemRole: false,\n        output: ['media'],\n      },\n    },\n  });\n}\n\n// Allow all the capabilities for unknown future models\nconst GENERIC_MODEL = commonRef('imagen', {\n  supports: {\n    media: true,\n    multiturn: true,\n    tools: true,\n    systemRole: true,\n    output: ['media'],\n  },\n});\n\nexport const KNOWN_MODELS = {\n  'imagen-3.0-generate-002': commonRef('imagen-3.0-generate-002'),\n  'imagen-3.0-generate-001': commonRef('imagen-3.0-generate-001'),\n  'imagen-3.0-capability-001': commonRef('imagen-3.0-capability-001'),\n  'imagen-3.0-fast-generate-001': commonRef('imagen-3.0-fast-generate-001'),\n  'imagen-4.0-generate-preview-06-06': commonRef(\n    'imagen-4.0-generate-preview-06-06'\n  ),\n  'imagen-4.0-ultra-generate-preview-06-06': commonRef(\n    'imagen-4.0-ultra-generate-preview-06-06'\n  ),\n} as const;\nexport type KnownModels = keyof typeof KNOWN_MODELS;\nexport type ImagenModelName = `imagen=${string}`;\nexport function isImagenModelName(value?: string): value is ImagenModelName {\n  return !!value?.startsWith('imagen-');\n}\n\nexport function model(\n  version: string,\n  config: ImagenConfig = {}\n): ModelReference<typeof ImagenConfigSchema> {\n  const name = checkModelName(version);\n  if (KNOWN_MODELS[name]) {\n    return KNOWN_MODELS[name].withConfig(config);\n  }\n  return modelRef({\n    name: `vertexai/${name}`,\n    config,\n    configSchema: ImagenConfigSchema,\n    info: {\n      ...GENERIC_MODEL.info,\n    },\n  });\n}\n\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return models\n    .filter((m: Model) => isImagenModelName(modelName(m.name)))\n    .map((m: Model) => {\n      const ref = model(m.name);\n      return modelActionMetadata({\n        name: ref.name,\n        info: ref.info,\n        configSchema: ref.configSchema,\n      });\n    });\n}\n\nexport function listKnownModels(\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n) {\n  return Object.keys(KNOWN_MODELS).map((name: string) =>\n    defineModel(name, clientOptions, pluginOptions)\n  );\n}\n\nexport function defineModel(\n  name: string,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n): ModelAction {\n  const ref = model(name);\n\n  return pluginModel(\n    {\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n    },\n    async (request, { abortSignal }) => {\n      const clientOpt = calculateRequestOptions(\n        { ...clientOptions, signal: abortSignal },\n        request.config\n      );\n\n      const imagenPredictRequest = toImagenPredictRequest(request);\n\n      const response = await imagenPredict(\n        extractVersion(ref),\n        imagenPredictRequest,\n        clientOpt\n      );\n\n      if (!response.predictions || response.predictions.length == 0) {\n        throw new Error(\n          'Model returned no predictions. Possibly due to content filters.'\n        );\n      }\n\n      return fromImagenResponse(response, request);\n    }\n  );\n}\n\nexport const TEST_ONLY = {\n  GENERIC_MODEL,\n  KNOWN_MODELS,\n};\n"],"names":["pluginModel"],"mappings":"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"}},
    {"offset": {"line": 5005, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/vertexai/lyria.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  modelActionMetadata,\n  modelRef,\n  ModelReference,\n  z,\n} from 'genkit';\nimport { ModelAction, ModelInfo } from 'genkit/model';\nimport { model as pluginModel } from 'genkit/plugin';\nimport { lyriaPredict } from './client.js';\nimport { fromLyriaResponse, toLyriaPredictRequest } from './converters.js';\nimport { ClientOptions, Model, VertexPluginOptions } from './types.js';\nimport {\n  calculateRequestOptions,\n  checkModelName,\n  extractVersion,\n} from './utils.js';\n\nexport const LyriaConfigSchema = z\n  .object({\n    negativePrompt: z\n      .string()\n      .optional()\n      .describe(\n        'Optional. A description of what to exclude from the generated audio.'\n      ),\n    seed: z\n      .number()\n      .optional()\n      .describe(\n        'Optional. A seed for deterministic generation. If provided, the model will attempt to produce the same audio given the same prompt and other parameters. Cannot be used with sample_count in the same request.'\n      ),\n    sampleCount: z\n      .number()\n      .optional()\n      .describe(\n        'Optional. The number of audio samples to generate. Default is 1 if not specified and seed is not used. Cannot be used with seed in the same request.'\n      ),\n    location: z\n      .string()\n      .describe(\n        'Lyria is only available in global. If you initialize your plugin with a different region, you must set this to global.'\n      )\n      .optional(),\n  })\n  .passthrough();\nexport type LyriaConfigSchemaType = typeof LyriaConfigSchema;\nexport type LyriaConfig = z.infer<LyriaConfigSchemaType>;\n\ntype ConfigSchemaType = LyriaConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = LyriaConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `vertexai/${name}`,\n    configSchema,\n    info: info ?? {\n      supports: {\n        media: true,\n        multiturn: false,\n        tools: false,\n        systemRole: false,\n        output: ['media'],\n      },\n    },\n  });\n}\n\nconst GENERIC_MODEL = commonRef('lyria');\n\nconst KNOWN_MODELS = {\n  'lyria-002': commonRef('lyria-002'),\n} as const;\nexport type KnownModels = keyof typeof KNOWN_MODELS; // For autocorrect\nexport type LyriaModelName = `lyria-${string}`;\nexport function isLyriaModelName(value?: string): value is LyriaModelName {\n  return !!value?.startsWith('lyria-');\n}\n\nexport function model(\n  version: string,\n  config: LyriaConfig = {}\n): ModelReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  return modelRef({\n    name: `vertexai/${name}`,\n    config,\n    configSchema: LyriaConfigSchema,\n    info: { ...GENERIC_MODEL.info },\n  });\n}\n\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return models\n    .filter((m: Model) => isLyriaModelName(m.name))\n    .map((m: Model) => {\n      const ref = model(m.name);\n      return modelActionMetadata({\n        name: ref.name,\n        info: ref.info,\n        configSchema: ref.configSchema,\n      });\n    });\n}\n\nexport function listKnownModels(\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n) {\n  return Object.keys(KNOWN_MODELS).map((name: string) =>\n    defineModel(name, clientOptions, pluginOptions)\n  );\n}\n\nexport function defineModel(\n  name: string,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n): ModelAction {\n  const ref = model(name);\n\n  return pluginModel(\n    {\n      name: ref.name,\n      ...ref.info,\n      configSchema: ref.configSchema,\n    },\n    async (request, { abortSignal }) => {\n      const clientOpt = calculateRequestOptions(\n        { ...clientOptions, signal: abortSignal },\n        request.config\n      );\n      const lyriaPredictRequest = toLyriaPredictRequest(request);\n\n      const response = await lyriaPredict(\n        extractVersion(ref),\n        lyriaPredictRequest,\n        clientOpt\n      );\n\n      if (!response.predictions || response.predictions.length == 0) {\n        throw new Error(\n          'Model returned no predictions. Possibly due to content filters.'\n        );\n      }\n\n      return fromLyriaResponse(response, request);\n    }\n  );\n}\n\nexport const TEST_ONLY = {\n  GENERIC_MODEL,\n  KNOWN_MODELS,\n};\n"],"names":["pluginModel"],"mappings":"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"}},
    {"offset": {"line": 5134, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/vertexai/veo.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ActionMetadata,\n  ModelReference,\n  modelActionMetadata,\n  modelRef,\n  z,\n} from 'genkit';\nimport { BackgroundModelAction, ModelInfo } from 'genkit/model';\nimport { backgroundModel as pluginBackgroundModel } from 'genkit/plugin';\nimport { veoCheckOperation, veoPredict } from './client.js';\nimport {\n  fromVeoOperation,\n  toVeoClientOptions,\n  toVeoModel,\n  toVeoOperationRequest,\n  toVeoPredictRequest,\n} from './converters.js';\nimport { ClientOptions, Model, VertexPluginOptions } from './types.js';\nimport {\n  calculateRequestOptions,\n  checkModelName,\n  extractVersion,\n} from './utils.js';\n\nexport const VeoConfigSchema = z\n  .object({\n    sampleCount: z.number().optional().describe('Number of output videos'),\n    storageUri: z\n      .string()\n      .optional()\n      .describe('The gcs bucket where to save the generated videos'),\n    fps: z\n      .number()\n      .optional()\n      .describe('Frames per second for video generation'),\n    durationSeconds: z\n      .number()\n      .optional()\n      .describe('Duration of the clip for video generation in seconds'),\n    seed: z\n      .number()\n      .optional()\n      .describe(\n        'The RNG seed. If RNG seed is exactly same for each request with unchanged ' +\n          'inputs, the prediction results will be consistent. Otherwise, a random RNG ' +\n          'seed will be used each time to produce a different result. If the sample ' +\n          'count is greater than 1, random seeds will be used for each sample.'\n      ),\n    aspectRatio: z\n      .enum(['9:16', '16:9'])\n      .optional()\n      .describe('The aspect ratio for the generated video'),\n    resolution: z\n      .enum(['720p', '1080p'])\n      .optional()\n      .describe('The resolution for the generated video'),\n    personGeneration: z\n      .enum(['dont_allow', 'allow_adult', 'allow_all'])\n      .optional()\n      .describe(\n        'Specifies the policy for generating persons in videos, including age restrictions'\n      ),\n    pubsubTopic: z\n      .string()\n      .optional()\n      .describe('The pubsub topic to publish the video generation progress to'),\n    negativePrompt: z\n      .string()\n      .optional()\n      .describe(\n        'In addition to the text context, negative prompts can be explicitly stated here to help generate the video'\n      ),\n    enhancePrompt: z\n      .boolean()\n      .optional()\n      .describe(\n        'If true, the prompt will be improved before it is used to generate videos. ' +\n          'The RNG seed, if provided, will not result in consistent results if prompts are enhanced.'\n      ),\n    generateAudio: z\n      .boolean()\n      .optional()\n      .describe('If true, audio will be generated along with the video'),\n    compressionQuality: z\n      .enum(['optimized', 'lossless'])\n      .default('optimized')\n      .optional()\n      .describe('Compression quality of the generated video'),\n    resizeMode: z\n      .enum(['pad', 'crop'])\n      .default('pad')\n      .optional()\n      .describe(\n        'Veo 3 only. The resize mode that the model uses to resize the video'\n      ),\n    location: z\n      .string()\n      .describe('Google Cloud region e.g. us-central1. or global')\n      .optional(),\n  })\n  .passthrough();\nexport type VeoConfigSchemaType = typeof VeoConfigSchema;\nexport type VeoConfig = z.infer<VeoConfigSchemaType>;\n\n// This contains all the Veo config schema types\ntype ConfigSchemaType = VeoConfigSchemaType;\n\nfunction commonRef(\n  name: string,\n  info?: ModelInfo,\n  configSchema: ConfigSchemaType = VeoConfigSchema\n): ModelReference<ConfigSchemaType> {\n  return modelRef({\n    name: `vertexai/${name}`,\n    configSchema,\n    info:\n      info ??\n      ({\n        supports: {\n          media: true,\n          multiturn: false,\n          tools: false,\n          systemRole: false,\n          output: ['media'],\n          longRunning: true,\n        },\n      } as ModelInfo), // TODO(ifielker): Remove this cast if we fix longRunning\n  });\n}\n\nconst GENERIC_MODEL = commonRef('veo');\n\nconst KNOWN_MODELS = {\n  'veo-2.0-generate-001': commonRef('veo-2.0-generate-001'),\n  'veo-3.0-generate-001': commonRef('veo-3.0-generate-001'),\n  'veo-3.0-fast-generate-001': commonRef('veo-3.0-fast-generate-001'),\n  'veo-3.1-fast-generate-001': commonRef('veo-3.1-fast-generate-001'),\n  'veo-3.1-fast-generate-preview': commonRef('veo-3.1-fast-generate-preview'),\n  'veo-3.1-generate-001': commonRef('veo-3.1-generate-001'),\n  'veo-3.1-generate-preview': commonRef('veo-3.1-generate-preview'),\n} as const;\nexport type KnownModels = keyof typeof KNOWN_MODELS; // For autocomplete\nexport type VeoModelName = `veo-${string}`;\nexport function isVeoModelName(value?: string): value is VeoModelName {\n  return !!value?.startsWith('veo-');\n}\n\nexport function model(\n  version: string,\n  config: VeoConfig = {}\n): ModelReference<ConfigSchemaType> {\n  const name = checkModelName(version);\n  return modelRef({\n    name: `vertexai/${name}`,\n    config,\n    configSchema: VeoConfigSchema,\n    info: { ...GENERIC_MODEL.info },\n  });\n}\n\n// Takes a full list of models, filters for current Veo models only\n// and returns a modelActionMetadata for each.\nexport function listActions(models: Model[]): ActionMetadata[] {\n  return models\n    .filter((m: Model) => isVeoModelName(m.name))\n    .map((m: Model) => {\n      const ref = model(m.name);\n      return modelActionMetadata({\n        name: ref.name,\n        info: ref.info,\n        configSchema: ref.configSchema,\n      });\n    });\n}\n\nexport function listKnownModels(\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n) {\n  return Object.keys(KNOWN_MODELS).map((name: string) =>\n    defineModel(name, clientOptions, pluginOptions)\n  );\n}\n\nexport function defineModel(\n  name: string,\n  clientOptions: ClientOptions,\n  pluginOptions?: VertexPluginOptions\n): BackgroundModelAction<VeoConfigSchemaType> {\n  const ref = model(name);\n\n  return pluginBackgroundModel({\n    name: ref.name,\n    ...ref.info,\n    configSchema: ref.configSchema,\n    async start(request) {\n      const clientOpt = calculateRequestOptions(clientOptions, request.config);\n      const veoPredictRequest = toVeoPredictRequest(request);\n\n      const response = await veoPredict(\n        extractVersion(ref),\n        veoPredictRequest,\n        clientOpt\n      );\n\n      return fromVeoOperation(response);\n    },\n    async check(operation) {\n      const response = await veoCheckOperation(\n        toVeoModel(operation),\n        toVeoOperationRequest(operation),\n        toVeoClientOptions(operation, clientOptions)\n      );\n      return fromVeoOperation(response);\n    },\n  });\n}\n\nexport const TEST_ONLY = {\n  GENERIC_MODEL,\n  KNOWN_MODELS,\n};\n"],"names":["pluginBackgroundModel"],"mappings":"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"}},
    {"offset": {"line": 5296, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/vertexai/index.ts"],"sourcesContent":["/**\n * @license\n *\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @module /\n */\n\nimport { EmbedderReference, ModelReference, z } from 'genkit';\nimport {\n  GenkitPluginV2,\n  ResolvableAction,\n  genkitPluginV2,\n} from 'genkit/plugin';\nimport { ActionType } from 'genkit/registry';\nimport { listModels } from './client.js';\n\nimport * as embedder from './embedder.js';\nimport * as gemini from './gemini.js';\nimport * as imagen from './imagen.js';\nimport * as lyria from './lyria.js';\nimport * as veo from './veo.js';\n\nimport { VertexPluginOptions } from './types.js';\nimport { getDerivedOptions } from './utils.js';\n\nexport { type EmbeddingConfig } from './embedder.js';\nexport { type GeminiConfig } from './gemini.js';\nexport { type ImagenConfig } from './imagen.js';\nexport { type LyriaConfig } from './lyria.js';\nexport { type VertexPluginOptions } from './types.js';\nexport { type VeoConfig } from './veo.js';\n\nasync function initializer(pluginOptions?: VertexPluginOptions) {\n  const clientOptions = await getDerivedOptions(pluginOptions);\n  return [\n    ...veo.listKnownModels(clientOptions, pluginOptions),\n    ...imagen.listKnownModels(clientOptions, pluginOptions),\n    ...lyria.listKnownModels(clientOptions, pluginOptions),\n    ...gemini.listKnownModels(clientOptions, pluginOptions),\n    ...embedder.listKnownModels(clientOptions, pluginOptions),\n  ];\n}\n\nasync function resolver(\n  actionType: ActionType,\n  actionName: string,\n  pluginOptions?: VertexPluginOptions\n): Promise<ResolvableAction | undefined> {\n  const clientOptions = await getDerivedOptions(pluginOptions);\n  switch (actionType) {\n    case 'model':\n      if (lyria.isLyriaModelName(actionName)) {\n        return lyria.defineModel(actionName, clientOptions, pluginOptions);\n      } else if (imagen.isImagenModelName(actionName)) {\n        return imagen.defineModel(actionName, clientOptions, pluginOptions);\n      } else if (veo.isVeoModelName(actionName)) {\n        return undefined;\n      } else {\n        return gemini.defineModel(actionName, clientOptions, pluginOptions);\n      }\n      break;\n    case 'background-model':\n      if (veo.isVeoModelName(actionName)) {\n        return veo.defineModel(actionName, clientOptions, pluginOptions);\n      }\n      break;\n    case 'embedder':\n      return embedder.defineEmbedder(actionName, clientOptions, pluginOptions);\n      break;\n  }\n  return undefined;\n}\n\nasync function listActions(options?: VertexPluginOptions) {\n  try {\n    const clientOptions = await getDerivedOptions(options);\n    const models = await listModels(clientOptions);\n    return [\n      ...gemini.listActions(models),\n      ...imagen.listActions(models),\n      ...lyria.listActions(models),\n      ...veo.listActions(models),\n      // We don't list embedders here\n    ];\n  } catch (e: unknown) {\n    // Errors are already logged in the client code.\n    return [];\n  }\n}\n\n/**\n * Add Google Cloud Vertex AI to Genkit. Includes Gemini and Imagen models and text embedder.\n */\nfunction vertexAIPlugin(options?: VertexPluginOptions): GenkitPluginV2 {\n  let listActionsCache;\n  return genkitPluginV2({\n    name: 'vertexai',\n    init: async () => await initializer(options),\n    resolve: async (actionType: ActionType, actionName: string) =>\n      await resolver(actionType, actionName, options),\n    list: async () => {\n      if (listActionsCache) return listActionsCache;\n      listActionsCache = await listActions(options);\n      return listActionsCache;\n    },\n  });\n}\n\nexport type VertexAIPlugin = {\n  (pluginOptions?: VertexPluginOptions): GenkitPluginV2;\n  model(\n    name: gemini.KnownImageModels | (gemini.ImageModelName & {}),\n    config?: gemini.GeminiImageConfig\n  ): ModelReference<gemini.GeminiImageConfigSchemaType>;\n  model(\n    name: gemini.KnownGeminiModels | (gemini.GeminiModelName & {}),\n    config?: gemini.GeminiConfig\n  ): ModelReference<gemini.GeminiConfigSchemaType>;\n  model(\n    name: imagen.KnownModels | (imagen.ImagenModelName & {}),\n    config?: imagen.ImagenConfig\n  ): ModelReference<imagen.ImagenConfigSchemaType>;\n  model(\n    name: lyria.KnownModels | (lyria.LyriaModelName & {}),\n    config: lyria.LyriaConfig\n  ): ModelReference<lyria.LyriaConfigSchemaType>;\n  model(\n    name: veo.KnownModels | (veo.VeoModelName & {}),\n    config: veo.VeoConfig\n  ): ModelReference<veo.VeoConfigSchemaType>;\n  model(name: string, config?: any): ModelReference<z.ZodTypeAny>;\n\n  embedder(\n    name: string,\n    config?: embedder.EmbeddingConfig\n  ): EmbedderReference<embedder.EmbeddingConfigSchemaType>;\n};\n\n/**\n * Google Cloud Vertex AI plugin for Genkit.\n * Includes Gemini and Imagen models and text embedder.\n */\nexport const vertexAI = vertexAIPlugin as VertexAIPlugin;\n// provide generic implementation for the model function overloads.\n(vertexAI as any).model = (\n  name: string,\n  config?: any\n): ModelReference<z.ZodTypeAny> => {\n  if (imagen.isImagenModelName(name)) {\n    return imagen.model(name, config);\n  }\n  if (lyria.isLyriaModelName(name)) {\n    return lyria.model(name, config);\n  }\n  if (veo.isVeoModelName(name)) {\n    return veo.model(name, config);\n  }\n  // gemini, image and unknown model families\n  return gemini.model(name, config);\n};\nvertexAI.embedder = (\n  name: string,\n  config?: embedder.EmbeddingConfig\n): EmbedderReference<embedder.EmbeddingConfigSchemaType> => {\n  return embedder.model(name, config);\n};\n\nexport default vertexAI;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5447, "column": 0}, "map": {"version":3,"sources":["file:///Users/vinish/Documents/Workspace/Frontend/EduPlayz/node_modules/%40genkit-ai/google-genai/src/index.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport {\n  googleAI,\n  type EmbeddingConfig,\n  type GeminiConfig,\n  type GeminiTtsConfig,\n  type GoogleAIPluginOptions,\n  type ImagenConfig,\n} from './googleai/index.js';\nexport { vertexAI } from './vertexai/index.js';\n"],"names":[],"mappings":";AAgBA;AAQA,SAAS,gBAAgB"}}]
}